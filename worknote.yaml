

ms60 who need to backup what for quit?
mbed os how to init()?
nuconsole update for KEIL UM
            
    
;ccma       01120180   09/11/2012    now 12.49 days off,  have been 2.51, 經智分 2018/9/07(五)	2018/12/04(二)        
    (wait) m2351 pdid rule isp UID HK told me

    sylvia secureISP english     
    2 samples merge with clockconfig and pinconfig gen code
    eclipse py-binascii.py C:\work\project\v8m\TC8234_BSP\SampleCode\FlashTool\FlashTool-eclipse-m2351-2nd\M2351_AP_NS (MKROM)_mp        
        keyword not "$t, $d" but "POP", and don't need pre_s0
                    
    ;truestudio
        stack analyzer (pro)  gcc can do this by -fstack-usage
        auto test, unit test code generate. code coverage - can be done by stlink, and very detail.         
                
    ;;efficient
        paste in worknote, and tab indent all lines
        paste module chunk, agile code python
        install UOW in 2773
        remove 換行符號, 合併多行
        二進制比對工具                    
        bookmark opensource/word2html
        python 蟻穴式 copy , change icon on the whole path, to backup 2nd flash algo source code 
                
    ;minor
        http://www.nuvoton.com/export/sites/nuvoton/enu/Documents/ChangeLog.txt           
        dynamic power measurement (ask tien sir data)
        又把 private key 傳出來, pAxf->PowMod_Finish(auPwdB2);
        jlink xom        
        about 投稿雜誌    
        (openocd?) nucmdtool and winhid incorportate 
        study 
            ice2 hid_transfer.cpp call hex library study        
            icplib - func in axf.c call calltargetfunc. but targetfunc is virtual in axf.c and implement in axf_m0.c, and axf_m0 inherit axf class
            context switch - thread has schedule and context switch, how to interact with process?                
            dh bits 256 ram usage, aes buffer need
            pinconfig autotest (20%), check jquery of pinconfig
        ;install        
            white nb , old xp.   winXP keil crack, jisun cert, dropbox/google drive                
            vc6, - nulink build                
            cygwin, UOW, vim, yotta, hcrdgit4, command line, ssh vs powershell   
        ;tech
            tty , modem, mbed uVisor, function programming
            Linux System Programming, Linux就該這麼學, 自己動手從0到1寫嵌入式操作系統
        ;codegen
            ip owner provide hal init() and assert() situation
            
            TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq)
            freq 最大是多少? even 純 call api 不知道
            
            在merge dac/adc 時, 2者 timer 的 PCLK 各是多少是否相同不好查
            
            pdma and spi init 交織
            pdma trigger and spi_write_tx0 spi_trigger code
        ;built-in keil/iar
            (wait next MDK, christopher) keil built in driver pinview can't see chip
            IAR chip series classification sync with nulink
            BSP select built-in IAR driver, chip series of IAR change to ours
    
;Fri    
    walter
        打卡異常通知, 出缺勤紀錄寄給 manager (health check can record)    
        ISP 2201 gitweb tag        
    jc what is module test?
        
;Thur           
    ;;host              
        keil/iar/icp 系列分法
        
        upload all m2351B tool 6/E
            release nulink
            nuCMDtool for 2351            
            isp, secureISP B version
                        
        tool support table        
        file://///nuvoton.com/prjshare/MCU_FAE/Temp/01_Tool_NuLink/ MCU tools develop status.xlsx.lnk
        
        code review 6741             
        
        3600 (cctu, ycc, cyyu, ccli, ychsu, ccma)                           
        code排版 - 痛一次
        
    ;;ccli0
        [ICP tool] 選擇N76E003時，ICP tool不能導出/導入。    
        NM1230 7/E package back               
        * yt auto-it to link 5 tiny board                 
        整理code, nucmdtool, chipdef.h               
        
        * PGFF 應用在 m251 checksum+burncode mode組合
        * m480 otp        

        m480 program speed (pingpong, spi flash read speed)
            * m4521 flash performance
            perofmrance left items - sram use all (icp limited at 4KB of nuc100 smallest package), offline/keil pingpong
                * JTRACE auto clock , clock and sram size can be adjustable
            calculate spi flash read spec - slow 1.5 vs 0.25, related to decrypt??
            sprom reload flash algo why? why reload algo so many times?
            use gpio to benchmark speed            
            
        coding standard of ice2, build bin and compare
        * m2351 Config 取名統一
        * warning when use checksum to verify SN must be 0xff, checksum value in dataflash? SN can be put in data flash?
        * 于處 SWD 波型分析 memory read fail 會出現那個error 嗎? 改成 timeout 延長, 只看 DHCSR halt bit 決定斷線
        * auto test enhance -key devices x 5 at a time  -review test items        
        debounce how to modify??
        * online + batch mode 是檢查 ID_CODE, 為何不要學 offline 重連到連上為止, 即一定要target 被 unplug 再重插才會 upgrade 下一塊, online / offline batch mode 機制差異??
        keil config0 modify notice user that will do chip erase        
        Command Line Tool support certificate by yhtu
        
        unclear bug
            nuc122an pingpong will encounter hw bug
            
        TODO                 
            m480 iap, to add save history in lua, no checksum & size info
            PSIO tool on normal GPIO
            VHD, multi os
            [Nu-Link] firmware upgrade flow refine (TBD)
               Verify APROM bit-wise while ICE fw update (todo)
               Verify LDROM while ICE fw update (done)
            (ccli) nuCMD chip reset 電掉不下去, 但之前Nano100接著 target好像反而是會掉下去而連不上去??
            advice lunaII
            target dll has been cancelled , debugger aborted
            Data Flash Emulates EEPROM, add alert            
            (autotest) nano112 config0 跑不過, 手測ok. ychsu flash select and config0 要設一樣才能進 debug mode, auto test can't find??
            icptool 印出 寫入大小超過了數據Flash的限制 不斷重連 
            Nano112 SPROM in KEIL need to set .ini verify=0??
            (pending) Checking tool developing        
                
    ;;ycc    
        hex look address, bin look first two word
        
        ?? m2351 nuCMDTool support nulink2? should be ok.
        can merge with original nuCMD?
            config0 write 3, chip will die
            xom address set overlap, need chip erase
            
        swd library for m2351 ns
        
        auto firmware upgrade, because config1 dataflash didn't modify
        
                    
        m2351 simplify the download flow of APROM & APROM_NS. (Suspended)
                                    
                                        
        8051 connect too long argue by mb20        
        如果沒有使用憑證, icptool need no key exchange
        .icp import and jump out of offline mode        
        mbed for nulink2
        
        ** CMSIS DAP index from 0x0 ~ 0x20, 0x7f. can coexist with nulink2.0 ? 0x40 ~ 0x6f                                                
        
        david iar no reset                
        ** icp 讀取image 另存為hex file  Help for bootloader sample code by CAN bus        
        ?? M2351 MP FPGA ULINK use M2351 flash algo will timeout, but use TC8234 is ok        
        * xom offline program to m4 chip, is xom bin been programmed?
        * offline to dongle data flash, block burning
        * nulink gang checksum, display layout

        nugang load hex file, keil build .hex load by nugang will fail, hex2bin not called library. not different.    
        * serial number word alignment
        mbed support SPIM
        burn code mode of m2351        
        >> ICP Lib release
        >> NUC505 sector erase, backup or sector align
        >> SPIN button DFBA 問題: Mini51DE/58DE, NUC029AE, NUC200. ICP tool更改Bass address後Config1不會跟著變動

        wish 
            iar 8051 (select 1T waveform, tell us selected part)                               
            xom numbers information read from chip

    ;;yung;;ychsu       
        * nulink2 trace UM
        
        IAR M252 系列  M23 SP display 問題 MSP_S, MSP_NS
                
        pinview for mL51
                
        ** 1MB/s sram access, m4 mem read ack fail first (拖累數據?)
        
        cmsis dap
                        
        ** some sample has small size, EBI_SRAM ETM Branch, ETM P-header: 11E  1N each packet size the same??        
        * tp.ini in dll driver, event viewer, itm function display 排版, print to nuTrace terminal too slow, UI for DWT config, add traceclk_div option
        * swo UART
        * cpu clock measurement to validate PLL 
        * power down then wakeup, ETM behavior??
        * M480 read all SPI flash, should read 1st and last to keep the unburn part. Will you patch?
        m480 ldrom use sprom
        etm (code coverage)
        * use crypto hw in nulink2 ICE
        ETM data on-the-fly
        ETM to IAR,eclipse
        
        minor
            nuconsole 和 nulink fw 脫勾                        
            newICE LCD display error message? or separate blink freq.
            
            pinview - offd display, CPU clock

            
        >> (check) ICPTool download finish read flash (cy0, should be remove) 時切走 ice pin 會一直重連 (reset and run enable), batch mode 也會, 若是 online download 用 offline download 的方式, connect (normal then under) instead of check_usb 似可解

        unclear bug
            yt m2351 scrlock can't' connect, icptool

    ;;cyyu;;zale
        ** pinconfig m4521/m2351B/mL51 version pin assignment pinconfig, m031/nuc2201 (no code gen)
                
        eclipse
            * openocd burn code at linux, pinview
            * add XOM (but GCC not supported XOM now) - if there is XOM enable, must chip erase (4 pair)
                        XOMR0BASE (Address = 0x0020_0000) [23:0]
                        XOMR0SIZE (Address = 0x0020_0004) [7:0]
                        XOMR0CTRL (Address = 0x0020_0008) [7:0] default 0x5a is off
                        XOMR1BASE (Address = 0x0020_0010) [23:0]
                        XOMR1SIZE (Address = 0x0020_0014) [7:0]
                        XOMR1CTRL (Address = 0x0020_0018) [7:0] default 0x5a is off
                        2, 3 omit
            * m480 ice protocol need to modify  mail "M480 ICE protocol" 2017/9/8 (週五) 下午 05:31, 
            * eclipse live watch       ?? can't refresh memory window                  
            * SPIM burning
            * configuration dialog create by javascript (can be dynamically modified)   
            mutex of openocd with icptool             
            flash breakpoint
            etm function port to openocd
            m2351 Config 取名統一        
            
        code backup to SVN? (WU, openocd eclipse, pinconfig, windows driver)
            
        pinconfig                 
            * pinconfig online, to get information from OpenOCD
            pinconfig remove MFC web version
            * 49pin BGA version, now can QFP only (目前是四方出pin, 圓形無法)        
            power down setting version
            
        clockconfig 
            ** clockConfig HXT 不能輸入小數 e.g. 22.1184MHz (仍在 4Mhz ~ 24Mhz之前，符合條件)        
            ** (CLYu) PLL config 反填值去 show clock             
            * show disable node or not
            >> PLL/Clock config default 選 NUC121, 加 cookie keep previous setting
            >> __HXT 120000000 寫死
            clock configure 設計問題
                1. pin 選了 ip, 傳給 clock 繼續用 (stored selected ip) 反之亦然
                2. stored ip list 只記錄選的 ip, 出 pin 另外存
                3. selection guide 並不一定都能出 pin 完整, 要如何克服 pass to pinconfig?
                >> switch off the tips, tips move with cursor
            >> clyu low power of nano100
            >> clock configure (PLL 範圍, PLL警告視窗跳出來的規則)
                (SPEC) 自動最佳解 (bese performance -> UART highest baudrate + SPI highest clock rate, best power saving) 如 UCH 使用 PLL2 for performance, PLL1 for power
                (SPEC) USB PHY in PLL2 not work by YCHuang3 -  it can not be ignored
                (SPEC) 未滿足之 module 要先反灰, 並 prompt 未滿足條件	  
                (SPEC) 先把必要條件的 path 填上, 如 UCH 使用 PLL1 48MHz, 並讓 PLL1 限制於 48MHz, 若 CPU 想改成 84MHz, 顯示 limitation
                (limit) PLL 有 range 限制, mini51 只能開 HXT/LXT 其一, USB一定要HXT, LCD一定要LXT	 
                //(improve) config0 有一些 CPU clock, X32, XT 的 reset default value - 這個有需要做在 clock configure? 不設 config0 有關係嗎?
                //(improve) code gen 之 AHBCLK, 因為是enable module, 應該要在最後一個設定的 register, 等其它 clock register 都 ready 好之後再設定
                //(improve) clock module 沒有 CPU? 
                //放在 nusmart - (improve) gen uVision project uvproj file 
        NuWizard 
            CPU clock 加入選型表?
            pin 選型表選完, 己經知道 user 對週邊的需求, 是否能在 pinConfigure 幫 user 帶好設定?
            clock 透過每個 module 是否有需要在 standby work, 選擇 LIRC or HIRC
                clock config 應該要根據 pinconfig 使用到多少 module 直接帶入 used modules information (如選型表到pinConfig)
                  tool 之間的連動, 要先 enable external clock pin (of pinConfig), external clock 才可以起作用
                在 pin config -> clock config 間跳一窗問 user 哪些 module 要 power down work? (auto gen clock DIV plan) 讓user 自己選擇哪些module 是要在低速運行
            ip 設定想要的 clock speed, 分析是否可達需求. 剩下的 module init					
        
    ;cctu       server \\Oapcd01504\BSP\               
        otp ecc aes
        ecc prv 256 pub 512
        m031 how to recover UART transfer? drop if timeout and uart not receive 8bytes (so usci can't work)
        
        * 2201 hid fail, nuc240 only
                
        status
            nuc2201 board, USB ok UART未測
            m4521 add USBD SOF trim, code size over
            
        2351 UM (EN/CH), 480 UM
        * free type font, read true type font
                
        * openocd config dialog
        * command line         
        (minor) DFU ISP BULK        
        
        icptool archtecture (cctu) ICP tool 起始畫面 auto select
        Nu-Bridge WinUsbLib API說明文件
        
        b2b
            ethernet isp
            NUC122 I2C ISP MF10 JLIU 
        
        wish
            m480 secureISP => build in usb_open, IB at aprom, IB calculate by mkrom
            m2351 secureISP => write config0 not to chip reset, kprom lock 無法 erase, isptool call usb_open() clear 0x2000c000 sram will fail
        
    ;ms60TBD
        anders feedback 2018/5/23. no error message if the NuLink probe can’t be detected. Instead there is an error message that the ELF file can’t be loaded or is corrupt.
        offline cert 
        dual core SWD   

        nutool
            NuConsole 和 NuBridge 搞不好有相同之處 
            >> CPU clock 加入選型表?
        nulink
            KEIL - if we didn't update config0 lock bit, we should need no chip erase. 

        	[Nu-Link] R/W RAM with pingpong buffer of PC<->ICE 
        	[ICP] Serial number steps 
        	[ICP] ICP Open source
        	[ICP] Make use of UID
        	[ICP offline] multi binary
        	[ICP batch mode] debounce (pending)
        	[NuCMD] Report status to PC tool - multiple bytes        
        
            chip series rename to chip name perfix        
            ** remove allmutex old compatible
            
            keil 
                ** conditional bp bug from jcliu, bs pk==10 will pop up error     
                add "auto select" chip type
            icp  
                remove the startup dialog to select chip
                ** AMCHANG ICP SN自增时采用10進位 BCD 碼 mail (nuvoton 量产工具问题)            
                
            nulink fw port to M2351 secure, can sell for customize
            icptool support hex, burn bin files separately
            keil clear flash algo in SRAM after program
            ICPTool offline 超過size燒寫失敗 error msg 不明確 ICE: Cmd error: ERROR_FLASH_WRITE 
            [nuCMD] talk with AP, how to? can only return one byte status            
            [ice] offline fail 的閃燈無法 identify error            
        ;to be arrangement
            if((flashInfo.uConfig0 & NUC1XX_FLASH_CONFIG_LOCK) != 0) in HasFlashForOfflineDownload() always false
            >> The Nu-Link device may be detached temporarily, Continue to wait for the device
            >> VCOM driver of NuLink, remove VCOM, send \\nuvoton.com\public\MS20\YT\vcom_driver_signed to ms10, ms20
            >> ytlu auto test, not reset 測的到嗎? 語系問題, flash lock 之後的chip erase + download, ICE pin switch to GPIO, config modify then download test.
                [autotest]增加測項  簡体和日文檔名, nulink vcom

            KEIL/IAR user manual (html devices merge into user manual)
                使用說明書增加項目
                >> [KEIL] Trace.log EnableLog = 1, Memaccr, bulk USB driver install, conditional breakpoint, ICP merge exe file
                >> [ICPTool] offline flash verify fail : exception all LED on, quick start, green group word remove
                >> [nulink] error message
                >> [nulink dongle] detect target power

        ;minor
            (patent) GPIO/UART/I2C timing protocol generator
            icptool scroll bar 用拉的的確是放開才反應, 用滾的即時反應 from CLYu2
            >> ICP tools .icp project 導入 不給改
            
;worknote;note   
    
    ;json
        物件（Object）：{}
        陣列（Array）：[]
        字串（String）：以 "" 括起來
        數值（number）：0-9 的數字組合（整數、小數或負數）
        布林（boolean）：true 或 false
        空值（Null）：null        
        
        {
          "uart": {
            "baudrate": [115200, 38400, 9600],
            "word length": [8, 9]
            "parity": ["none", "even", "odd"]
            "stop bits": [1, 2]
            "data direction": ["receive and transmit", "receive only", "transmit only"]
            "over sampling": [8,16]
            "interrupt": true,
          },
          
          
          "boolean": true,
          "null": null,
          "number": 123,
          "string": "Hello World"
        }
    
        type() <- JSON has unicode (from .py), str (from cmd line)
            JSON	Python
            object	dict
            array	list
            string	unicode
            number (int)	int, long
            number (real)	float
            true	True
            false	False
            null	None
        e.g
            json_string = """
            {
                "gg":true,
                "pk": 1, 
                "fa": "cc.ee", 
                "fb": {
                    "fc": "", 
                    "fd_id": "12345"
                }
            }"""

            import json

            data = json.loads(json_string)
            if type (data["pk"]) == int:
                data["fb"]["new_key"] = "terry tried and get into here"
            print json.dumps(data, indent=4)

            #load from file
            with open("uart.json") as myjson:
                data = json.load(myjson)
        


    ;DAPLink SWDAP-LPC11U35 
        firmware upgrade, www.mbed.org/swdap pre-build image NXP LPC1768
        
        daplink/cmsis-dap/usbd_user_hid.c
        daplink/cmsis-dap/DAP.c  DAP_ProcessCommand()
        daplink/cmsis-dap/SW_DP.c  SWD_Transfer()

        DAPLINK_HIC_ID=0x97969902        
        const char *board_id = "9012";
        read_unique_id(host_id);
        memcpy(target_id, uuid_data, 16);
        
        
        thread
            timer_task_30mS
            hid_process
            main_task
        config
            usb_config USBD_MSC_ENABLE
        
        arm swdap 小板
            黑線為 GND
        LPC11U35FHI33/501 pinout
            swio - 最右上
            swck - 右倒數第三
            reset - 左二
        
        build- 
            tools\build_release_uvision.bat
            if not install in default location, need to set environmental variable UV4 to that location
        
            ..\..\..\tools\pre_build_script.bat  若直接從 windows 開 uvision 舊的 shell enviroment 還留在 python3 所以帶出錯的 python version, (reboot can fix it)
            直接在 cmder 輸入 python 確定是 python 2.7, 從cmder 開 project \DAPLink\projectfiles\uvision\lpc11u35_tiny_if\lpc11u35_tiny_if.uvproj

        m480 hsusbd_mass_storage_dataflash  
        
        ;c skill
            #define COMPILER_CONCAT_(a, b) a##b
            #define COMPILER_CONCAT(a, b) COMPILER_CONCAT_(a, b)
            #define COMPILER_ASSERT(e) enum { COMPILER_CONCAT(compiler_assert_, __COUNTER__) = 1/((e) ? 1 : 0) }
                        
            #define DECZERO(x)              (x ? --x : 0)
                if (DECZERO(usb_state_count) == 0) {
                
    ;pyocd
TD pyocd svd, gdb_server
TD 目前算法程式是強制在 NUC100 init 後面插 asm BKPT, 應該要從pyocd插在LR
            [2017wk39]  C:\weekly-report\note\code\pyocd\nuc100_flash_algo\NUC100_Nuvoton
                        python lib - binary to text of word (e.g. 0x12345678)
                        C:\work\python\lib\bin2text_word
                        C:\weekly-report\note\code\pyocd\nuc100_flash_algo\NUC100_Nuvoton\NUC1xx_ICE_M0.bin\

        help
            λ pyocd-tool help
            Commands:
            ---------
            break                     ADDR                 Set a breakpoint address
            core                      [NUM]                Select CPU core by number or print selected core
            d, disasm                 [-c/--center] ADDR [LEN] Disassemble instructions at an address        
            
            λ pyocd-tool help break
            Usage: break ADDR
            Set a breakpoint address
                        
        disasm instruction needs install capstone library
        
        USB command write interface
            pyOCD/
                gdbserver/gdbserver.py      resume
                core/coresight_target.py      getState
                coresight/cortex_m.py   getState
                coresight/ap.py   readMemory 
                pyDAPAccess/dap_access_cmsis_dap.py    write_reg -> _write -> _send_packet
                pyDAPAccess/interface/pyusb-backend.py      write
            command list
                tools/pyocd.py command_list
            trace
                pyocd.py -> run() it seems you can add some cmds -> MbedBoard.chooseBoard(board_id is None here, 
                    -> pyDAPAccess/dap_access_cmsis_dap.py _get_interfaces()
                    -> pyDAPAccess/intefrace/pyusb_backend.py(158) getAllConnectedInterface()
                (linux) /home/cm/.local/lib/python2.7/site-packages/usb/core.py(844) manufacturer() -> util.get_string()
                
                
        gotcha
            be using linux with python2.7
            if you can't find module -> python setup.py install
                把 pyocd.py copy 到第一層 pyOCD下可以跑
            connect 2 usb cable in the same white NB
            it will chooseBoard() in board/mbed_board.py 
            our flash algo has no BKPT instruction at function end

    ;lua
        --lua sleep function, s unit is second
        function sleep(s)
          local ntime = os.time() + s
          repeat until os.time() > ntime
        end
    
        
    ;openocd 
        file:///C:/Program%20Files/GNU%20Tools%20ARM%20Embedded/6%202017-q1-update/arm-none-eabi/share/gdb/python/gdb
        file:///C:/work/eclipse/openocd-0.9.0/contrib/rpc_examples
        
        telnet localhost 4444
        openocd -f ../scripts/interface/nulink.cfg -f ../scripts/target/numicro.cfg
        COMMAND
        halt
        resume [addr]
        step [addr]
        bp [addr len[hw]]
        rbp addr <- remove bp at addr 
        wp [addr len [(r|w|a) [value[mask]]]]
        mdw [phys] addr [count]  <-display memory, e.g. mdw 0 0x100
        mww [phys] addr value [count]  <- write memory words
        shutdown [error]
        numicro chip_erase
        reset [init|halt|run]  ;init -halt immediately and run reset-init script, halt -halt immediately, run -let target run     
        flash write_image [erase] [unlock] filename [offset] [type]   ;erase means erase befor program, type is bin,hex,elf,s19
                                                                      ;flash write_image erase C:\\NU.bin 0x10040000
                                                                      ;flash write_image C:\\NU.bin 0x0
        regregreg [(number|name) value|'force')]]

    ;eclipse               
        Q: MS20 OpenOCD path找不到
        A: 當user第一次使用Eclipse時，我們Nuvoton plug-in會去下面五個地方search OpenOCD.exe
        1.	C:/Program Files/Nuvoton Tools/OpenOCD/bin
        2.	C:/Program Files (x86)/Nuvoton Tools/OpenOCD;
        3.	D:/Program Files/Nuvoton Tools/OpenOCD;
        4.	D:/Program Files (x86)/Nuvoton Tools/OpenOCD;
        5.	OpenOCD/bin(相對Eclipse.exe的路徑)
        一般用安裝包install的時候，安裝包會copy OpenOCD至1或2的位置(取決於Win32 or Win64)。Search到的path會存在workspace裡的.metadata內
        ms20的M2351遇到的問題是你們習慣在開Eclipse時直接指定workspace到各個project內的GCC。
        這樣會導致每個project會被當成workspace，並在裡面儲存.metadata資料。
        如果你在切換平台的時候沒有把project內被當成workspace而多儲存的preferences檔給刪掉，
        這會發生OpenOCD path會找不到的issue。
        若Win32 to Win64, 你各個project內存的preferences會一直是C:/Program Files/Nuvoton Tools/OpenOCD/bin。
        反之，
        若Win64 to Win32, 你各個project內存的preferences會一直是C:/Program Files (x86)/Nuvoton Tools/OpenOCD/bin。
        但若你正確地使用一個固定的folder作為workspace，你的project內就不會有多餘的preferences檔了

        [2017wk16]eclipse flash algo
            Include "file:///C:/work/project/v8m/TC8234_BSP/SampleCode/FlashTool/FlashTool-eclipse-m451/M451/ini.ini" 
            C:\work\v8m\TC8234_BSP\SampleCode\FlashTool\FlashTool_eclipse\M451\obj>arm-none-eabi-objcopy -O binary 00_TC8237.axf binbin
            Using sed replace every character with itself followed by a newline
            sed 's/\(.\)/\1\n/g' -i filename
            concatenate 2 files
            ??awk 'NR%2{printf "%s ",$0;next;}1' yourFile
            
            [wk17]                
            eclipse machine code of programpage (PC alignment problem -- LDR loads a word, if target address not word align, it chopped off 2bytes offset)    
                include C:\temp\v8m\TC8234_BSP\SampleCode\FlashTool\FlashTool_eclipse\KEIL\ini-eclipse-code-on-keil.ini
                include file:///C:/work/project/v8m/TC8234_BSP/SampleCode/FlashTool/FlashTool-eclipse-m2351-2nd/KEIL/ iprogram.ini
                
                run eclipse orignal machine code on keil -- seems work, notice their machine code didn't set ISPCMD, and i have to do ISPINIT by myself
                        
                in function definition, always inline
                unsigned char CheckXOMRange(unsigned int u32Addr) __attribute__((always_inline))
                
                __attribute__((aligned))    
                struct link list idata _at_ 0x40;            The keyword _at_ overrules the alignment.

            [wk18]
            eclipse machine code
                make it aligned, one function per section (independable), inline

                one function one section will reflect to xx.o, readelf -S print section info and you will see
                    Section Headers:
                    [ 1] i.BlankCheck      PROGBITS        00000000 000034 000044 00  AX  0   0  4
                    [ 2] i.EraseChip       PROGBITS        00000000 000078 000018 00  AX  0   0  4

                    Section Headers:
                    [ 1] .text             PROGBITS        00000000 000034 000148 00  AX  0   0  4
                    [ 2] .arm_vfe_header   PROGBITS        00000000 00017c 000004 00      0   0  4
                
                NS0 flash algorithm 會 call 到該 function address range 以外, 是因為要 call 到 MKROM 要透過 veneer
                veneer 是在 linkder 後產生, 在 .axf 可以看到相關處理
                而上述 one function one section, 可以在 build 出來的 .o 檔看到, 而 linker 後 .axf 裡沒用到的 function of section 就會不見

            [wk20] m2351 eclispe 2nd flash algo shuttle final
                    file:///C:/work/project/v8m/TC8234_BSP/SampleCode/FlashTool/FlashTool-eclipse-m2351-2nd-shuttle
                m2351 eclipse 2nd connect experiments            
                    C://work/project/v8m/TC8234_BSP/SampleCode/FlashTool/FlashTool-eclipse-m2351-2nd
                    file:///C:/weekly-report/note/code/FlashTool-eclipse-m2351-2nd/golden_pattern
                        /KEIL                   NS code, move NS flash algo to 0x30010000 and call it (set pc to the start) as experiment
                        /M2351_AP_NS (MKROM)    NS flash algorithm, use py-binascii.py and key-in start & end address and that will output a ascii hex format               
                    N: secure code 要跳到對的 NS address, 不然亂跳到某一secure address hardfault, scrlock 之後, 一直 trap 在 secure mode, NS debug 將永無法連上
                    N: 2nd flash algo KEIL test project 要 run 直接搬到sram 的 flash algo , 除了pc , r0 - r2, 注意 sp, 我們pc tool的axf.c loader 處理了 sp & lr 
                    N: stack pointer 由 openOCD 拿 numicroM23_NS.cfg 中的 sram base + size 設為 SP. 0x30018000
                    N: MKROM NSC API- erase/program bit28 will be checked, program 1 page one time, if > 1page, return fail and no any byte of data programmed
                                
    ;icp
        [2017WK2] batch mode, 
            Nulinkpro will switch ICE pin to input (while disconnect), 
            So read IDCODE will fail, ICE 會以為是斷線又去重連, 所以就一直 loop 燒.
            下Chip reset , 就不需要去下 disconnect, 因為chip reset 己把debug mode 清除掉, 在批量燒是目前想的解決法
            
        m_bIsEncrypted_LDROM <- .icp + cert, it means this LDROM encrypted
    ;iar
        iar .board describe what flash range to what .flash, .flash point to certain .out file
        
        [2017wk13]
            ycc: m2351 2nd iar - 1st if kprom enable, chip erase, 2nd ask user keyin kprom key
            [wk14]
            ccli: iar support spi flash
            [wk18]
            iar WS select m0+ for m2351 
                    iar     compiler--[tie]--debug--[separate]--flash
                                debugger is related to ARM register, M0 is subset of M4, but M23 has different breakpoint mechanism with M4, M4 ice will read M23 CPUID and use different breakpoint mechanism, M4 ice of nulink driver will read breakpoint number
                                flash loader is related to numicro 0x40000000 & 0x50000000
                                
                    keil    compiler--[separate]--debug--[tie]--flash
        
        [2017wk27] 
        Q: IAR 7.5 之後 sp 有時會show psp.  
            Ans: SP 有三組 SP, MSP, PSP. IAR的做法all core regs 都需要driver去init. 我們少做了init CONTROL register動作, 而bit1 means MSP or PSP, 
            沒有 init CONTROL 會是 memory 殘存未知值, 所以 SP 可能去抓 MSP or PSP 顯示. 而 KEIL 因為直接讀 SP, 所以沒問題. 
        IAR 8.1 sdk 留下 interface 要我們完成, 用 vs2015 build 810.dll, 舊的 780.dll等仍由 vs2008 編, 因其 sdk 就是用vs2008 不能改用 vs2015
            nulink.dll 會自動去判斷用戶是 IAR810 or IAR780 去選用 810.dll or 780.dll, source code 是同一份, 在裡面判斷 sdk 版本.
    
        license (from 2017/7/12)
            if new IAR version can't compile, menu -> license -> check for license renewal
            help -> license manager -> my dongle choose standalone license 7100-046-014-7165
            network license: NTHCRDIAR01
        
    ;keil
        [2017wk6] KEIL flash algo , run on SRAM to check
        sector size means erase size, General type flash algo will read that value, if it sets larger than page size (say page 512B, sector 1KB)
        sector erase will miss to erase some page, AP will offset 1KB, but it actually erase 512B only

        [2017wk10] close KEIL, KEIL will issue DISCONNECT TARGET to NuLink, FW will reset CTRL_STAT (SYSPWR, DBGPWR) and didn't clear (HALT, DEBUGEN), M0 then free run, M4 stand still
        CY0 has issue a flash lock problem, that is because flashLock & DEBUGEN, CPU won't run. CCLI0 Disconnect and clear CTRL_STAT and no clear DEBUGEN. After cancelling ICPTool popped up flash lock dialog.
        
        [2017wk13ccli] keil spi burn 32MB, page erase 4KB 7min, block 64KB erase 2.5min, chip erase 2min, full but scatter no spi, not to erase spi     

        接ULinkPro 時若是config0 設成 boot from LDROM, 只能燒 APROM. 
        目前 keil 是打開 icpen, 所以不管 boot from, IAR 則是要燒 ap or ld 前切換 boot from 至另一邊, 所以可以不care config0
        
        KEIL press config0/1 button, will try our best to connect target, including connect under reset.
        KEIL press debug button, will use user's reset option to do the reset.

        cmsis driver
            typedef struct _ARM_DRIVER_SPI { 
              ARM_DRIVER_VERSION   (*GetVersion)      (void); 
              ARM_SPI_CAPABILITIES (*GetCapabilities) (void); 
              int32_t              (*Initialize)      (ARM_SPI_SignalEvent_t cb_event); 
              int32_t              (*Uninitialize)    (void); 
              int32_t              (*PowerControl)    (ARM_POWER_STATE state); 
              int32_t              (*Send)            (const void *data, uint32_t num); 
              int32_t              (*Receive)         (void *data, uint32_t num); 
              int32_t              (*Transfer)        (const void *data_out, void *data_in, uint32_t num); 
              uint32_t             (*GetTxCount)      (void); 
              uint32_t             (*GetRxCount)      (void); 
              int32_t              (*Control)         (uint32_t control, uint32_t arg); 
              ARM_SPI_STATUS       (*GetStatus)       (void); 
            } const ARM_DRIVER_SPI;

            ARM_DRIVER_SPI Driver_SPI1; // access functions for SPI1 interface 
            ARM_DRIVER_SPI Driver_SPI2; // access functions for SPI2 interface 

            #include "Driver_SPI.h" 
            extern ARM_DRIVER_SPI Driver_SPI0;                          // SPI Driver 
            void mySPI_callback(uint32_t event) { 
              switch (event) { 
              case ARM_SPI_EVENT_TRANSFER_COMPLETE:                     // Success 
                break; 
              case ARM_SPI_EVENT_MODE_FAULT:                            // Error 
                break; } 
            } 
            const uint8_t testdata_out[8] = { 0, 1, 2, 3, 4, 5, 6, 7 }; // Test data buffers 
            uint8_t testdata_in [8]; 
            void mySPI_func(void const* arg) { 
              ARM_DRIVER_SPI* SPIdrv = &Driver_SPI0; 
              SPIdrv->Initialize(mySPI_callback);                       // Initialize the SPI driver 
              SPIdrv->PowerControl(ARM_POWER_FULL);                     // Power up the SPI peripheral 
              SPIdrv->Control(ARM_SPI_MODE_MASTER | ARM_SPI_CPOL1_CPHA1 | ARM_SPI_MSB_LSB | ARM_SPI_SS_MASTER_SW | 
                              ARM_SPI_DATA_BITS(8), 10000000);          // Configure the SPI to Master, 8-bit mode @10000 kBits/sec 
              SPIdrv->Control(ARM_SPI_CONTROL_SS, ARM_SPI_SS_INACTIVE); // Set CS line 
              SPIdrv->Control(ARM_SPI_CONTROL_SS, ARM_SPI_SS_ACTIVE);   // Clear CS line 
              while (1) { 
                SPIdrv->Send(testdata_out, sizeof(testdata_in));        // Transmit some data 
                SPIdrv->Receive(testdata_in, 8);                        // Receive 8 bytes of reply 
              } 
            }   
            
        registry
            (these four decide double click .uv2, .uvproj...'s default program, change property by right click is invalid)
            HKEY_LOCAL_MACHINE\SOFTWARE\Classes\UV2FILE\Shell\open\command
            HKEY_LOCAL_MACHINE\SOFTWARE\Classes\UVMPWFILE\Shell\open\command
            HKEY_LOCAL_MACHINE\SOFTWARE\Classes\UVPROJFILE\Shell\open\command
            HKEY_LOCAL_MACHINE\SOFTWARE\Classes\UVPROJXFILE\Shell\open\command  
            (these three not investigated yet)
            HKEY_LOCAL_MACHINE\SOFTWARE\Keil\Products\MDK                       
            HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Keil μVision4
            HKEY_LOCAL_MACHINE\SOFTWARE\Nuvoton\NuLinkKeil          
    
        
        license of keil
            四種MDK edition -- Professional	        Plus	        Essential(cortex M)	        Lite
            Cortex-M edition只能只用在不帶TrustZone的Cortex-M23 (such as TC8237 / M251)，要用到TrustZone (such as TC8234 / M2351)，只能使用Plus edition。
            
            nuvoton license 8224@10.22.90.101
            
            CID keil->license can see 
            
            02773 CID C2F52-HT697
            mdk4 xxx, 8VRHL-0UTRK-8S6YU-SLZ5M-VPY10-ATZNB
            
            asus white CID CRXVN-XXQ0N, pc-name H4DPJ48
            mdk4 xxx, 32B45-GB1DH-X75RZ-J9HYH-0MQ32-KC9LR
            
        command, count is works in our keil driver
            BS 'addr'
            BS 'addr',2                   ;BS 0x123 at 2nd time
            BS write 'global_var'
            BS main
            BS main,10,"Myfun()"          ;run main() 10 times and call Myfun()
            BS 'var' == 8
            BS 'var'>5, 3                 ;halt when 3rd time larger than 5
            BS read 
            BS WRITE savefirst == 5 && acc == 0x12
                BS WRITE 0x20000018 == 0x00000003                        /* Invalid expression */ SIZE is not clear
            BS WRITE * ((unsigned int*)0x20000018) == 0x00000003     /* Valid expression */
            BS \\cpp_template\../../source/RVCT/STM32F10x.s\136, 1
        
            fromelf --text -c ".\@L.axf" --output ".\@L.txt"
            fromelf --bin ".\obj\@L.axf" --output "NUC1xx_ICE_M0.bin"
            cmd /c dir "NUC1xx_ICE_M0.bin"
            cmd.exe /C copy NUC100_AP_128.axf ..\NUC100_AP_128.FLM
        
        ;ini
            _WDWORD(0x40000100, 0x59);
            _WDWORD(0x40000100, 0x16);
            _WDWORD(0x40000100, 0x88);
            _WDWORD(0x4000c000, 0x1);
            _WDWORD(0x4000c01c, 0x3);

            R0=0x100;      
            R1=0x5000;     
            R2=0x200
            PC=0x119;
            SP=0x20001000;

            printf("var %x\n", _RDWORD(0x20000044)); <- KEIL script 這樣寫可以work
            printf("varrr %x\n", TEST1()); <- 這樣寫也可以work. TEST1() is a function return _RDWORD(0x20000044);

        Q: i can't put global veriable when build flash algo? write position independent
        A: you can, armcc build&link, prog&data are allocated in sequencial, instruction will access myglobal by pc-relative access, but there is a R9 as static base (SB)
            If you need to use writable global data (or you use library functions that use writable global data) then you'll have to use /rwpi and things are more complicated still. Your loader will have to allocate/initialize the globals and point R9 at the appropriate global at the appropriate time. 

        Q: if addr 0x4 bit0 is 0 meaning jump to ARM mode    
        A: the address 0x4 bit0 is 1 means branch to it and switch to thumb mode, if you filled in PC value, don't need to set bit0 of PC to 1.
            test M0, 0x4 bit0 modified to 0, seems still jump to reset_handler and Thumb mode
            but if BLX R0, and I modify R0 bit 0 as 0, then it will hardfault
            
        Q: cannot set Watchpoints on-the-fly while the program is running like you can with hardware breakpoints??
        A: yes, i can on-the-fly set bp, but can't do that on watchpoint.  
                    
                    
        ;armcc
            int myglob __attribute__((at(0x3f00))) ; <- not supported in PIC
            weak symbol
                void symbol1() __attribute__ ((weak,alias("symbol222")));  //?一包与下面的asm()一句是等效的。
                asm(".weak symbol1\n\t .set symbol1, symbol222\n\t");
                extern void symbol1() __attribute__((weak));
                        
            arm assembly code push {r1-r3, lr} see stack point from keil memory window the order 'r1, r2, r3, lr'
            LDR r3, [pc, #16] ;@0x0000113c    --> addr 0x113c value 0x14d8, addr 0x113e value 0x0000   --> result r3= 0x000014d8
            
            MOVW     R0,#0x100
            MOVT     R0,#0x4000
            MOVW	R0, :lower16:SystemInit
            MOVT	R0, :upper16:SystemInit
            BLX     R0                          

            ;stack and heap
            Stack_Size      EQU     0x00000200
            Heap_Size       EQU     0x00000200
            __heap_base                              0x200000a0   Data           0  startup_m058s.o(HEAP)
            __heap_limit                             0x200002a0   Data           0  startup_m058s.o(HEAP)
            __initial_sp                             0x200004a0   Data           0  startup_m058s.o(STACK)

            [2017wk6] can't assign string to array type ar="abc", 
                   char str[20]="abc" <- "abc" 固定是 .rodata 安置在 .text section. 若 str[] 是 global 則分配到 .data 段, 
                                         因為有初始化, 在 startup 時將 rodata copy to .data 段時做 initial, 若沒有初始化, 則分配到 .bss 段. 之後再自行 strcpy
                                         若放 func 裡就配置到 stack address

    ;fat
        layout "mbr|1st fat area|2nd fat area|root|data area"
        "file:///C:\weekly-report\note\htm\FAT_filesystem_FAT.html"
    
    ;cortexM
        support-cores@arm.com
                fabric
                sw
        blogs.arm.com
        silver.arm.com
        
        Q: DWT PC sampling prescaler minimun?
        A: minimin is 64x1, if core clock set 10MHz, it means periodic is 6.4us
        
        Q: 如果 cpu 沒有 halt, 直接硬指 pc to sram run code 可? scrlocked, 如果 m2351 run 在 secure 跑不到 NS, 指定PC到 ns ram run code 可行? 
        A: 沒有 halt cpu 能存取 memory, 但無法存取 register (M series 都不行)

        [2017WK21] M2351 use step to collect r0-r15
            B 4 cycle 
            LDR 5
            ADDS 4
            STR 4
            enter systick exception 8 cycle
            SysTick->VAL   = 0;    8 cycle 
            exit 12 cycle        
        SysTick_Config
            SysTick->LOAD
            SysTick->VAL   = 0; 將 counter 歸0, 下一行會從SysTick->LOAD 重 load, 不會進 interrupt, 要跑到0才會進systick interrupt
            SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;    
            
        ;swd
            CONNECT在示波器上真實為 51 ones + 79E7 (0111 1001 ...) + 54 ones 4 zero 
            "C:\work\project\TC8226verification\SWDH_test_note.txt"
        
    
        ;joseph's book, definitive guide 
            ;NVIC
                In the ARM architecture, interrupts are one type of exception
                the interrupt latency of the Cortex-M3 and Corex-M4 is very low, only 12 clock cycles
                Reset is a special kind of exception. When the processor exits from a reset, itexecutes the reset handler in Thread mode (rather than Handler mode as in other exceptions). Also the exception number in IPSR is read as zero
                
                The setup of the MSP is necessary because some exceptions such as the NMI or HardFault handler could potentially occur shortly after the reset (Terry - so it's must reside in first word of binary)
                This two-step stack initialization allows a microcontroller device with external memory to use the external memory for the stack.
                    use SRAM as SP in ResetHandler, init external memory in ResetHandler, and set SP to external memory before go into main()
                
                The NVIC can handle various types of interrupt sources
                    • Pulsed interrupt request e the interrupt request is at least one clock cycle long.
                    When the NVIC receives a pulse at its interrupt input, the pending status is set and held until the interrupt gets serviced.
                    • Level triggered interrupt request e the interrupt source holds the request high until the interrupt is serviced.
                Note that for the SVC exception, if the SVC instruction is accidentally used in an exception handler that has the same or higher priority than the SVC exception itself, it will cause the HardFault exception handler to execute

                如果一個exception handler正在執行，其他例外發生時，如果group priority優先權比你高就可以插隊，如果跟你一樣或比你低，就乖乖等
                如果有多個相同優先權的例外處理在等待執行(Pending)，那麼先比較subpriority，優先權比較高的排前面，如果還是一樣，Exception Number小的優先。
                GGGG GGGS GGSS GSSS SSSS
                
                Cortex-M3 or Cortex-M4 processors are based on full descending stack (SP decrement before store)

                LDREX/STREX exclusive
                    The STREX instruction has a return status, which indicates whether the exclusive store has been successful.
                    If two tasks try to lock a device at the same time, the return status will be 1
                    從 ARMv6 之後才引進 LDREX/STREX, 之前是 SWP (atomic instruction) 但是要在同一條 memory bus 才管用, 新架構多條 memory bus 要用 LDREX/STREX
                
                    Inside the processor, there is a small hardware unit called the local monitor. In a
                    normal situation it is in the Open Access state. After executing an exclusive load
                    instruction, it switches to the Exclusive Access state. An exclusive store can only
                    be carried out if the local monitor is in the Exclusive Access state and if the bus
                    system does not response with an exclusive fail response.
                    The exclusive write (e.g., STREX) can fail if one of the following operations has taken place
                    • A CLREX instruction has been executed, switching the local monitor to the Open Access state.
                    • A context switch has occurred (e.g., an interrupt).
                    • There wasn’t a LDREX executed beforehand.
                    • An external hardware returns an exclusive fail status to the processor via a side-band signal on the bus interface.            
                
                exception priority 設定從 LSB mask 是為了 porting 方便, cortex M3最少3bit 切出 8個level
                The PRIMASK register is a 1-bit wide interrupt mask register. When set, it blocks all exceptions (including interrupts) apart from NMI and HardFault exception
                The FAULTMASK register is very similar to PRIMASK, but it also blocksthe HardFault exception
                BASEPRI, which masks exceptions or interrupts based on priority level

                In some processor architectures, a special instruction is used for exception return. However, this means that the exception handlers cannot be written and compiled as normal C code.
                ARM 的 EXCEPT_RETURN 機制讓 exception handler 用 c 寫 build 起來和其它 function 無異, 因為return 一樣是 BX LR. (把 EXCEPT_RETURN 放入 LR register 等等的其它動作都是硬件會處理掉)
                EXCEPT_RETURN generated by BX LR, POP {PC}, LDR/LDM PC
                
                exception entrance, push "return addr" and "psr" first to address N+28 & N+24, then r0 r1.. to address N, N+4...
                exception exit, pop "return addr" to PC and "psr" first, that can fetch next instruction faster, and then r0-r3, r12, LR

                Unlike NVIC->ISPR[n], which can only be accessed in privileged access level, you can enable unprivileged program code to trigger a software interrupt by setting bit 1 (USERSETMPEND) of the Conﬁguration Control Register (address 0xE000ED14)
                
                interrupt 若 priority 相同, 不會 preempt 前人
                interrupt 來會拉 pend bit , 若軟體來得及在進入isr 前清掉 pend bit , interrupt 就不會發生, 若進入 isr 主體, hardware 會自己清掉pend bit.  在isr內 interrupt 又來還是會讓 pend bit再起, 然後一出 handler 後又馬上重進
                
                hardfault handler write in assembler, and use R0-R3, R12 only, will prevent error caused by SP corrupted, and get into hardfault handler no need do stacking
                可以寫一段 assembly 先確定 sp 正常, 其它 handler 要做的事再用c 寫. NMI 也可以用 c 寫, 因 sp fail 會先進 hardfault
                
                NMI: source is from watchdog, BOD

            ;low power
                Active current Usually measured in uA/MHz, Sleep mode current Usually measured in uA
                Energy efficiency Dhrystone (DMIPS/ uW) or CoreMark (CoreMark/ uW).
                Wake-up latency Usually measured in number of clock cycles, or sometime uSec.
                   In some designs, you can use a very low power sleep mode, but might take longer to wake-up (e.g., clock circuitry like the PLL could be turned off and it will take longer to resume normal clock output). Product designers need to decide which sleep mode should be used for their applications.
                有些應用可能需要快的wakeup latency, 有些電池的應用可能注重 energy efficiency, it depends on application
                you can run the microcontroller at a lower clock frequency, or have the processor finish the processing task quicker and stay in sleep longer.
                
                low power design
                    Reducing the active power
                        Choose the right microcontroller device (flash/sram size affect the power consumption)
                        Run at the right clock frequency (low cpu clock, or high cpu clock plus sleep)
                        Select the right clock source (e.g. external crystal cause extra power)
                        Turn off unused clock signals
                        Utilize clock system features (like peripheral divider)
                        Power supply design
                            power conversion will cause some waste, choose matched power
                        Running the program from SRAM
                            run part of critical code on sram and disable flash, enable flash only when needed
                            after disable flash, you can WFI, and after receive wakeup interrupt, enable flash in sram code
                        Using the right I/O port conﬁgurations
                             lower drive strength or slower skew rate might save some power
                    Reduction of active cycles
                        Utilizing sleep modes (as long as possible)
                        Reducing run-time (run code faster can stay in sleep mode longer)
                                    
            The design philosophy of uVisor is to provide hardware-enforced compartments (sandboxes) for individual code blocks by limiting access to memories and peripherals using the existing hardware security features of the Cortex-M microcontrollers.

            ;;systick
                The reason for having the timer inside the processor is to help software portability
                If you do not need an embedded OS in your application, the SysTick timer can be used as a simple timer peripheral for periodic interrupt generation, delay generation, or timing measurement    (假如有用 OS, 就規定一定要留給 OS 用)
                The processor design also ensures that the application tasks running at unprivileged level cannot disable this timer; otherwise, these tasks could disable the SysTick timer and lock out the whole system            
                • The SysTick Timer stops counting when the processor is halted during debugging.
                • Depending on the design of the microcontroller, the SysTick timer may stop in certain sleep modes.

            The execution of an OS kernel can be triggered by:
                • Execution of SVC instruction from application tasks.
                • Periodic SysTick exception.

            pendSV
                "file:///C:/weekly-report/note/pic/Joseph_M3M4_pendSV_effect.JPG"
                "file:///C:/weekly-report/note/pic/Joseph_M3M4_pendSV_nonOS_effect.JPG"
                "file:///C:/weekly-report/note/pic/Joseph_M3M4_pendSV_why.JPG"
            debugger has halt mode and debug monitor mode
            Debug monitor mode:
                • Processor executes exception handler type 12 (debug monitor)
                • SYSTICK counter continues to run
                • New arrive interrupts may or may not preempt, depending on the priority of the debug monitor
                • If the debug event takes place when a higher-priority interrupt is running, the debug event will be missed
                • Supports single-step operations
                • Memory contents (e.g., stack memory) could be changed by the debug monitor handler during stacking and handler execution
                • need UART communicate and debug agent in DEBUG_MON HANDLER code
            
                One of the debug events is an external debug request signal, called EDBGREQ, the design is a multi-processor system
                After debugging is completed, program execution can be returned to normal by clearing the C_HALT bit in DHCSR
                The breakpoint instruction (BKPT #immed8) is a 16-bit Thumb instruction with the encoding 0xBExx
                If DHCSR.C_DEBUGEN is set to 1, the processor ignores the value of this bit MON_EN.

                When debug monitor stepping is enabled, the processor performs a debug monitor step as follows:
                1. Either:
                    • Execute the next instruction.
                    • Perform an exception entry sequence to a pending exception with a priority below that of the 
                      DebugMonitor exception. In this case, the processor does not execute an instruction in this step.
                2. Set the DEMCR.MON_PEND bit to 1.
                3. Take any pending exception of sufficient priority
                
            assembler Language: Unified assembler Language
            syntax of ARM assembler
                AND R0, R1 ; Traditional Thumb syntax
                ANDS R0, R0, R1 ; Equivalent UAL syntax (S suffix is added, 要加才表示 APSR should be update)
                ADDS R0, #1 ; Use 16-bit Thumb instruction by default for smaller size
                ADDS.N R0, #1 ; Use 16-bit Thumb instruction (N=Narrow)
                ADDS.W R0, #1 ; Use 32-bit Thumb-2 instruction (W=wide)
                ARM assembler tool, a program code header with “CODE16”  directive implies the code is in the traditional Thumb syntax, and “THUMB” directive implies the code  is in the new UAL syntax.

                UBFX extracts a bit field from a register starting from any location (specified by #lsb) with any 
                width (specified by #width), zero extends it, and puts it in the destination register. For example,
                LDR R0,=0x5678ABCD
                UBFX.W R1, R0, #4, #8
                This will give R1 = 0x000000BC.
                Similarly, SBFX extracts a bit field, but its sign extends it before putting it in a destination register. 
                For example,
                LDR R0,=0x5678ABCD
                SBFX.W R1, R0, #4, #8
                This will give R1 = 0xFFFFFFBC.            
            
            Sleep-On-Exit Feature, interrupt 來做完事不用軟體介入就馬上睡覺
            
            RTOS
                The key beneﬁt of using an embedded OS is to provide a scalable way of enabling several concurrent tasks to run in parallel. If the tasks are all fairly short and don’t overlap each other most of the time, you can simply use an interrupt-driven arrangement to support multiple tasks.
                
                TCP/IP stack might run as a task inside a multi-tasking system and might need to spawn out additional child tasks when certain service requests are received. Traditionally these middleware (e.g.,lightweight IP, lwIP) can include an OS emulation layer that a software integrator needs to port when using a different OS.
        
            The MPU can be used to make an embedded system more robust, and in some cases it can make the system more secure by:
                • Preventing application tasks from corrupting stack or data memory used by other tasks and the OS kernel
                • Preventing unprivileged tasks from accessing certain peripherals that can be critical to the reliability or security of the system
                • Deﬁning SRAM or RAM space as non-executable (eXecute Never, XN) to prevent code injection attacks
                The exception handler can then decide if the system should be reset or just terminate the offending task in an OS environment

                • Setting a RAM/SRAM region to be read-only to protect important data from accidental corruption
                • Making a portion of RAM/SRAM space at the bottom of the stack inaccessible to detect stack overﬂow
                • Deﬁning memory attribute settings that can be used by system level cache (level 2) or the memory controllers
                In systems with an embedded OS, the MPU can be programmed at each context
                switch so that each application task can have a different MPU conﬁguration. In this way, you can:
                • Deﬁne memory access permissions so that stack operations of an application task can only access their own allocated stack space, thus preventing stack corruptions of other stacks in the case of a stack leak
                • Deﬁne memory access permissions so that an application task can only have access to a limited set of peripherals
                • Deﬁne memory access permissions so that an application task can only access its own data, or access its own program data (these are much trickier to set up because in most cases the OS and the program code are compiled together, so the data could be mixed together in the memory map)                
                
        
        Q: NVIC. bit 數決定 priority 分幾 level, 每個IRQ_handler 有自己的4個bit去設定它自己屬於哪一個 level, 如 systick 是 IRQ15, 若有4個bit 可以設, 我們可以設 15 最低 priority
        
        
        N: handler/thread mode -- handler must be privilege, thread can be privilege or user mode
            privilege thread (boot) can program CONTROL[0] to enter user mode thread, 
            once exception happen all go into handler mode (privilege, for sure, and it can set CONTROL[0] to switch back to user mode while exception returned)
        CONTROL register [0] 0:privilege 1:user (of thread mode, in handler mode this bit is don't care), [1] thread mode use 0:MSP 1:PSP 
                                                                                                        (can be R/W in thread & privilege mode, handler mode must be privilege and use MSP)
                             在 privilege mode 可以去改 CONTROL[1] 的值, 出 exception 硬件會看此bit 決定要不要切 psp. EXC_RETURN 的狀態會在 R14 LR   
        __get_CONTROL(); MRS r0, CONTROL;           __set_CONTROL();  MSR   CONTROL, r0;
        __set_PSP(addr); <- PSP 要手動設定, 不像MSP從 addr 0x0 load來
        System control block (e.g. systick, VTOR, HFSR) 通常要求是在 privilege mode 才能寫, 否則 hardfault. 
        除了STIR Software Trigger Interrupt Register 能被設定 user mode 也可以寫, STIR 是寫幾就可以軟體觸發幾號的interrupt, M4有M0沒有, M0可以直接去寫IPSR意思同
            
        [2017wk17]
            inline assembly code 
                keil.  comiler 5.4 ok, 4.1 is not worked
                    __asm{
                        bkpt #0
                    }
                                                            
                    __asm  void __SetMMMM()  // If you don't want to call CMSIS for some reason
                    {
                        BX      LR
                    }       
                    __SetMMMM();
                    
                keil.  comiler 6.7
                    NOP assembly code
                        __asm("mov r0,r0");
                    RETURN 0 and BKPT
                        __asm("movs r0,#0");
                        __asm("bkpt #0");
    
                gnu assembler
                    inline assembly的 通式是
                    __asm__(asm statements : outputs : inputs : clobber);
                    
                    The following code will adjust a value to a multiple of four.
                    asm volatile(
                        "ands    r3, %1, #3"     "\n\t"
                        "eor     %0, %0, r3" "\n\t"
                        "addne   %0, #4"
                        : "=r" (len)
                        : "0" (len)
                        : "cc", "r3"
                      );    

    ;;;mbed
        mass mode
        If GPA.1 = 0
            if GPB.14 = 0       
                    Mass Storage ISP. 
            else
                    Boot from AP.
                    MBED (MSC + VCOM)
        else
            ICP Tool, KEIL比對ICE Firmware的版本.跑既有Firmware Update的流程.            
            not mass mode, PE5 接地才有 vcom (PB1 TXD (output from ice)-rst, PB0 RXD-GND, NUC12SRE3DN 0x40012009)
        
        mbed ID of nuvoton
            "1302": "NUMAKER_PFM_NUC472",
            "1303": "NUMAKER_PFM_M453",
            "1304": "NUMAKER_PFM_M487",
            "1305": "NUMAKER_PFM_M2351",
            0x3 (0x409: 1302000000B40021011DA9E00000007F) 

        //svn6598  For MBED, use board code and UID as unique target id (from 24 char. to 32 char.)
        ICE2/HID/HID_Transfer.cpp 二個地方偷換 HID_StartProcess()  void MSC_ReadMedia()
        
        freescale frdm kw41z
        descriptior
            self = DEVICE ID 0d28:0204 on Bus 002 Address 029 =================
            bLength : 0x12 (18 bytes)
            bDescriptorType : 0x1 Device
            bcdUSB : 0x200 USB 2.0
            bDeviceClass : 0xef Miscellaneous
            bDeviceSubClass : 0x2
            bDeviceProtocol : 0x1
            bMaxPacketSize0 : 0x40 (64 bytes)
            idVendor : 0x0d28
            idProduct : 0x0204
            bcdDevice : 0x1000 Device 16.0
            iManufacturer : 0x1 ARM
            iProduct : 0x2 DAPLink CMSIS-DAP
            iSerialNumber : 0x3 0240000028884e45004670116bf000448021000097969900
            bNumConfigurations : 0x1
                CONFIGURATION 1: 500 mA ==================================
                bLength : 0x9 (9 bytes)
                bDescriptorType : 0x2 Configuration
                wTotalLength : 0x82 (130 bytes)
                bNumInterfaces : 0x4
                bConfigurationValue : 0x1
                iConfiguration : 0x0 
                bmAttributes : 0x80 Bus Powered
                bMaxPower : 0xfa (500 mA)
                    INTERFACE 0: Mass Storage ==============================
                    bLength : 0x9 (9 bytes)
                    bDescriptorType : 0x4 Interface
                    bInterfaceNumber : 0x0
                    bAlternateSetting : 0x0
                    bNumEndpoints : 0x2
                    bInterfaceClass : 0x8 Mass Storage
                    bInterfaceSubClass : 0x6
                    bInterfaceProtocol : 0x50
                    iInterface : 0x7 USB_MSC
                        ENDPOINT 0x82: Bulk IN ===============================
                        bLength : 0x7 (7 bytes)
                        bDescriptorType : 0x5 Endpoint
                        bEndpointAddress : 0x82 IN
                        bmAttributes : 0x2 Bulk
                        wMaxPacketSize : 0x40 (64 bytes)
                        bInterval : 0x0
                        ENDPOINT 0x2: Bulk OUT ===============================
                        bLength : 0x7 (7 bytes)
                        bDescriptorType : 0x5 Endpoint
                        bEndpointAddress : 0x2 OUT
                        bmAttributes : 0x2 Bulk
                        wMaxPacketSize : 0x40 (64 bytes)
                        bInterval : 0x0
                    
                    INTERFACE 3: Human Interface Device ====================
                    bLength : 0x9 (9 bytes)
                    bDescriptorType : 0x4 Interface
                    bInterfaceNumber : 0x3
                    bAlternateSetting : 0x0
                    bNumEndpoints : 0x2
                    bInterfaceClass : 0x3 Human Interface Device
                    bInterfaceSubClass : 0x0
                    bInterfaceProtocol : 0x0
                    iInterface : 0x6 CMSIS-DAP
                        ENDPOINT 0x81: Interrupt IN ==========================
                        bLength : 0x7 (7 bytes)
                        bDescriptorType : 0x5 Endpoint
                        bEndpointAddress : 0x81 IN
                        bmAttributes : 0x3 Interrupt
                        wMaxPacketSize : 0x40 (64 bytes)
                        bInterval : 0x1
                        ENDPOINT 0x1: Interrupt OUT ==========================
                        bLength : 0x7 (7 bytes)
                        bDescriptorType : 0x5 Endpoint
                        bEndpointAddress : 0x1 OUT
                        bmAttributes : 0x3 Interrupt
                        wMaxPacketSize : 0x40 (64 bytes)
                        bInterval : 0x1
                    
                    INTERFACE 1: CDC Communication =========================
                    bLength : 0x9 (9 bytes)
                    bDescriptorType : 0x4 Interface
                    bInterfaceNumber : 0x1
                    bAlternateSetting : 0x0
                    bNumEndpoints : 0x1
                    bInterfaceClass : 0x2 CDC Communication
                    bInterfaceSubClass : 0x2
                    bInterfaceProtocol : 0x1
                    iInterface : 0x4 mbed Serial Port
                        ENDPOINT 0x83: Interrupt IN ==========================
                        bLength : 0x7 (7 bytes)
                        bDescriptorType : 0x5 Endpoint
                        bEndpointAddress : 0x83 IN
                        bmAttributes : 0x3 Interrupt
                        wMaxPacketSize : 0x10 (16 bytes)
                        bInterval : 0x20
                        
                    INTERFACE 2: CDC Data ==================================
                    bLength : 0x9 (9 bytes)
                    bDescriptorType : 0x4 Interface
                    bInterfaceNumber : 0x2
                    bAlternateSetting : 0x0
                    bNumEndpoints : 0x2
                    bInterfaceClass : 0xa CDC Data
                    bInterfaceSubClass : 0x0
                    bInterfaceProtocol : 0x0
                    iInterface : 0x5 mbed Serial Port
                        ENDPOINT 0x4: Bulk OUT ===============================
                        bLength : 0x7 (7 bytes)
                        bDescriptorType : 0x5 Endpoint
                        bEndpointAddress : 0x4 OUT
                        bmAttributes : 0x2 Bulk
                        wMaxPacketSize : 0x40 (64 bytes)
                        bInterval : 0x0
                        ENDPOINT 0x84: Bulk IN ===============================
                        bLength : 0x7 (7 bytes)
                        bDescriptorType : 0x5 Endpoint
                        bEndpointAddress : 0x84 IN
                        bmAttributes : 0x2 Bulk
                        wMaxPacketSize : 0x40 (64 bytes)
                        bInterval : 0x0
    
    ;writer
        nulink gang - main chip nuc240sd2ae (use i2c talk to 4 slaves)
        
    
    ;;numicro (ap,ld,data,sram,cpu)   
        PDID
            0xN7 N6 N5 N4 N3 N2 N1 N0 (7版別, 65系列, 432 功能, 1 package, 0 流水號)
            
        CFGXT1  PF[4:3] Multi-Function Select
        CFOSC   CPU Clock Source Selection After Reset
            <- if CFOSC switch to HXT, but CFGXT1 not as crystal but GPIO. CPU still run on HIRC and HXT not enabled. 
            <- if CFOSC switch to HXT, and CFGXT1 as crystal. CPU still run HXT and HXT enabled. 
    
        semihosting
            m480 bsp -> 
                1. enable DEBUG_ENABLE_SEMIHOST both c/c++ and asm
                2. printf("more than 16 bytes and may need extra line feed")
                3. check UART#1 windows in KEIL
            
        bsp coding standard astyle format
            --style=bsd --indent=spaces=4 --convert-tabs
        
		for (;i<200;i++){
			CLK_SysTickLongDelay(100);
			SYS->GPC_MFP = i;
			if (i==199) i=0;  //若寫 if (i==200) 是永不會進的
		}
    
        N: for general M0 -- hw reset 會 reload config0, system reset 不會 reload
                
        outpw(0x50000100,0x00000059);                
        if (inpw(0x5000c008) == 0)
    
        page size m0 general 512 (except m0564 2k)
                  m4 general 2k (m481 4k)
                  m23 (m251 512, m2351 2k)
                  
        mini51                  4,8,16          2       conf        2               24 
        mini57 (gag014,kc)                                                                                                                      nm1120
        mini58                  32              2.5     conf        4               50
        m031 (fa8269,ppkc,m0_AHB4)
        m051                    8,16,32,64      4       4           4               50    
        m0518                   36,68           4       conf        8               50                                                          nuc131,nm1320
        m0519                   64,128          8       4,conf      16              72                                                          nm1500
        m0564 (fa8262,ws) 
        m2351
        m252 (lag026,cccke)     
        m451                    40,72,128,256   4       conf        16,16,32,32     72              USB 452/453         (451,452,453,m4tk)
        m4521 (fa8268,ya)
        m480
        nuc100                  32,64,128       4       4,4,conf    4,8,16          50              nuc120/140 USB      (100,120,130,140)
        nuc123                  36,68           4       conf        12,20           72              USB
        nuc131                  36,68           4       conf        8               50      
        nuc200                  32,64,128       4       4,4,conf    8,8,16          50              nuc220 USB          (200,220)
        nuc230/240              32,64,128       4       4,4,conf    8,8,16          72              nuc240 USB          (230,240)
        nano100                 32,64,64,128    4       conf        8,8,16,16       42              120,130 USB         (100,110,120,130)
        nano102/112             16,32           4       conf        4,8             32                          
        nuc442/472              256,512         16                  64              84              USB FS/HS                     
        nuc505                  512,2048                            128             100(m4f core)   USB HS
        nm1120                  16,29.5         2       conf        2,4             48
        nm1200                  17.5            2       conf        2               48                                  (1100,1200)
        nm1500                  32,64,128       8       4,4,conf    4-16(by part)   72                                  (1510,1520,1530)
        nm1820                  17.5            2       conf        2               48                                  
                    
        n76e003                 18                                  1               16
        n76e616                 18                                  0.5             16
        n76e885                 18                                  0.5             25
        n78/n79/w78/w79 (4T/6T/12T) 
        
        
        
        NUC100 	DA8230	NUC100/120AN
                DA8232	NUC100/120BN
                DA8245	NUC130/140CN
                FA8239	NUC100/120DN
                FA8236	NUC122AN
                FA8248	NUC123AN
                FB8248	NUC123AE
        NUC121	FA8266A	NUC121
        NUC125		
                
        NUC200	FA8239	NUC200/220AN
                FB8239	NUC230/240AE
        NUC2201	FA8267	
                
        NUC029	FB8243  NUC029AN
                FC8244  NUC029AE
                FA8273  NUC029LGE/NUC029SGE 
                FA8267  NUC029LEE/NUC029SEE
                FA8258  NUC029LDE/NUC029SDE
                
        NUC131	FA8258	NUC131AE
        M0518	FA8258	M0518
        NM1320	FA8258	NM1320
        
        M4521         FA8268
        M031_C(32K)     FA8269  
        M031_E(128K)    FA8270
        M031_D(64K)     FA8271  
        M031_B(16K)     FA8272  
        NUC1261       FA8273
        
        M051	DA8233	M051AN
                FA8243	M051BN
                FB8243	M051DN
                FC8243	M051DE
                FA8252	M058SAN                                
        M0564	FA8262	M0564
        NUC126		
                
        Mini51	FA8244	Mini51AN
                FC8244	Mini51DE
                FA8260	Mini58
                FA8255	Mini51X
        NM1200	FA8255	NM1200
                
        NM1500	FC8238	NM1500AE
        M0519	FC8238	M0519
                
        Nano100	FA8240	Nano100/120/AN
                FB8240	Nano100/110/120/130BN
                FA8253	Nano112/102AN
        Nano103	FA8263	Nano103
                
        NM1120	GAG014	NM1120
        NM1230  HAG025        
        NUC400	FA8249	NUC442/472AE
                
        M451	FA8256	M451AE
                FA8259	M451LD
        M480	LAG018	
        M4521	FA8268	
                
        M251	TC8237	
     	M252_D (64/12KB)    HAG028
        M252_G (256/32KB)   HAG026
        M252_E (128/16KB)
        M252_C  HAG029
                
        M2351	LAG021	
                
        NUC505	HAD009	NUC505
                
        Audio	FA8242	N572
                GAG015	I91000/N569/N570
                FA8241	I91100/N575
                FA8254	I91300/N576
                FA8241	I9160
                GAG017	I91200
                LAG020	I94100
                FA5C84	N571
                
        8051	FA8235	N79E855
                FA8261	N76E616
                FA8265	N76E003
                HAG023	ML51
                HAG030  N76E013
        
        相似系列by ccli
            M031
            M051 / NM1330
            M0518 / NUC131 / NM1320 / NUC030
            M0519 / NM1500
            M0564 / M05641 / NUC126 / NUC1261
            M2351
            M251/M252
            M451/M4521
            M480
            Mini51 / NM1820
            Mini55 / NM1200
            Mini57 / NM1120 / NM1810 / NM1230
            Mini58
            NUC029
            NUC100
            NUC121/NUC125
            NUC200AN
            NUC240AE / NUC2201
            NUC472
            NUC505
            Nano100
            Nano112
            Nano103
        
        
        schematic
            "\\nuvoton.com\prjshare\MCU\86.LAG021_M2351\Schematic\Nu_Auto_Tiny\Schematic\m2351_lqfp128_nu_auto.pdf"
        
        __I  uint32_t PDID;                  /*!< [0x0000] Part Device Identification Number Register                       */
        __IO uint32_t RSTSTS;                /*!< [0x0004] System Reset Status Register                                     */   
        __IO uint32_t PORCTL;                /*!< [0x0024] Power-on Reset Controller Register                               */
        
        0x40000008[0]   chip reset
        0x40000100      REGLCTL      0x59 0x16 0x88
        0x4000c000      FMC_ISPCTL ISPEN bit0
        0x4000c004      ISP_ADR 0x300000 config 0x100000 ldrom 0x700000 burn_code_mode
        0x4000c008      ISP_DAT
        0x4000c00c      ISP_CMD 0x21_write 0x0_read 0xc_readDID, 0x22_pageerase, 0x26_chiperase
        0x4000c010[0]   ISP_TRG        

        0xE000ED00	CPUID
        0xE000ED0C  V7M_AIRCR    app interrupt, reset [0] vect reset          [2] system reset    (first 16bit 0x05fa to write)
        0xE000EDF0  V7M_DHCSR    halt, status [0] debugEn, [1] halt, [2] step, [3] MASKINTS, [17] halt status, [20] sde (0 means NS)  
                                 !! manual write DHCSR first 16bit 0xA05F, and if manual write C_STEP, the PC won't update in left pane, can use PinView to check PC.
        0xE000EDFC  V7M_DEMCR    exception, monitor [0] VC_CORERESET        [24] TRCENA  , other bits are catching errors
        0xE000EDF4  V7M_DCRSR    select [16] 1 is write [6;0] reg
        0xE000EDF8  V7M_DCRDR    data
        0xE000EE08  DSCSR        secure [16] 0 means PE in NS mode                

        FPB breakpoint
        DWT_CTRL 0xE0001000	
        FP_CTRL 0xe0002000  bit1 must be 1 to write this reg, bit0 enable
        FP_COMP 0xe0002008  [31:30] 01 upper, 10 lower, 11 both  [28:2] COMP [0] enable

        M480/M2351 etm divider => FPGA for v8m and m23 etm divider and center (0x4000_0230 [31:24] HCLK divider)
        
        when flash lock, ice access, FMC CFG/DID/UID/checksum can be read. peripheral can be access, core reg can be access, sram can be read can't be written
        but cpu can't run code when ice connected, and then core reg can be read but no meaning
                
        [2017WK16] WDT and debugger relation YUNG2015 WK2, 2014 WK24
            DBGACK_WDT - why don't use? some didn't have? <- yes, old chip doesn't have, and if cpu free run, it still count.
            CWDTEN config0[31] - force enable, can't disable by SW
            ICE 連線會先試著關 WDT, 若 CWDTEN 打開, WDT 關不掉, 就設 WTIS watch dog timeout interval 到最大 26s
            if WDT reset, DAP didn't reset, why we need reconnect? - SWD read memory will fail anyway
            以上目前只做在 IAR, ICP
            
            KEIL 用 HW reset 可解, 因為如下
            system reset - 無法reset WDT
            hardware reset - 雖可以reset WDT, 但是有可能在放開reset pin到halt target’s cpu 這之間, target又可能已run到相關code開啟WDT設定.
            用under reset 應仍也可解 -> offline flow 先 Connect(CONNECT_NORMAL, RESET_AUTO); 若失敗再 Connect(CONNECT_UNDER_RESET, RESET_HW);
            儘管 CWDTEN, 但 hw reset WDT, 而且 WDT ICEDEBUG (AKA DBGACK_WDT) default enable, 所以新chip under reset 可解這個問題
            (under reset 放開 reset 後, ice 才會對 target 下 halt, 它只是在 connect 時under reset, 故還是有一小段時間差)
            看 ICPTOOL FLASH ALGO 可以看到相關處理

        [2017wk20]
            doc review sprom - sprom has 3 mode, normal (0xff) debug (0xaa) can set breakpoint & sprom can read const from inside but can't from outside, secure (others)
            sprom last byte of ICPTOOL 行為, load sprom binary and display its last byte on tool 

        ICPTOOL offline program 順序, config->aprom. online program 順序 aprom->config 因為 online config 會馬上生效 icpen on/off, 而offline是一開始config開, 最後rom都燒完才icpen off生效.            
            
        test burn code mode - VENEER has LDR, they push {r0,r1}  LDR to r1 position, pop {r0, pc} 
            2nd dev must call NSC to program, but LDR can't load DCD after burn code mode enable.
                FMC_ISPADDR = 0x70_0000
                FMC_ISPCMD   = 0x21            

            
        ;board
            Learning board, 上週邊, 跑 sample
            NuMaker Brick 
                main control board is equipped with Bluetooth function, which controls and coordinates data transfer. By setting the parameters of various modules via the NuMaker Brick app. Onboard modules include the temperature and humidity sensor, gas detection module, infrared module, gyroscopes, accelerator, sonar, LED and buzzer. (talking each other by I2C). App provides mechanism for Brick to trigger phone function in case a sensor value meets threshold.            
            NuMaker-PFM
                NuMaker-PFM-M453 platform is equipped with security, communication, and device management modules and supports low-power Bluetooth, Thread, Wi-Fi, 802.15.4/6LoWPAN, TLS/DTLS, CoAP, HTTP, MQTT and lightweight M2M. Embedded with 32 KB SRAM and 256 KB Flash
            NuMaker Tomato 
                single board computer (SBC), It is embedded with the 32-bit ARM926EJ-S NUC976DK62Y processor core which runs up to 300 MHz.
                runs on the Linux operating system, built-in 64MB DDR2 RAM, supports Python 
                connect to the Internet via the Ethernet cable or Wi-Fi through a USB Dongle. Network is also possible via various RF modules and built-in SPI/I²C interfaces
            NuMaker Uni 
                IoT application development board based on the NuMicro® NANO100NE3BN microcontroller (MCU) specially designed for Makers. With small dimensions of 3.5cm by 3.5cm, it is especially suitable for wearable devices.It integrates the 802.11 b/g/n WiFi module and bluetooth module, as well as four instantly operable modules including the accelerometer, temperature-humidity sensor, IR tranceiver and RGB LED light
            NuMaker Uno 
                Arduino compatible hardware using NUC131. arduino ide has its own language -> wire.begin() for i2c, serial.begin() for uart, program through ISP.
                

        ;;FAT big size binary
            1. KEIL 5.24
            2. optimize O0
            3.  const int arr[16000] = {99, 0, 88};
                int i;
                int32_t main(void)
                {		
                        i = arr[200];
                }
                
        ;;;nuc505
            ICP mode: Nu-Link發送ICP command到IBR (Boot code), 權限大, 可處理MTP Encryption相關, 但限制多, 速度慢
            ICE-SPI mode: 就是M0/M4 SWD mode, 無法處理加密的部分, 速度快.
            原先NUC505的脱机烧录就是使用ICP mode. 後來改成 ICE mode
            燒2MB, from 4m30s to 2min
            nuc505 icptool online icp mode to handle mtp (因為需要target MTP info, 所以一定要接 target chip), offline use ice mode to boost burning.            
            
            [2017wk15]
                flashbp issue from ythao - priority sw hw flashbp, hw first may use all and no left hw bp for flash address
                               - nuc505 isp fw will move all 1st page to sram, that will remove ths set sw bp and can't stop cpu when select 'run to main'
                               - sw, flash bp can't be seen from memory windows, it will be auto replaced by backup instruction in our ice driver.
                nuc505 16kb 之後當 aprom 16k之前是 ldrom, 要先把 ldrom 搬到sram 是因 spi 不能燒自己且效率差. isp sw 搬掉自燒前 16kb 的行為.
                
            [2017wk34]
                nuc505 document (signature 若是encrypt 就要自己填"解碼出來"的plaintext, 不是直接填encrypted bin 的密文, 填錯hardware verified fail 的話target chip就boot fail. 
                             MTP option(Hex) 填一個 byte 讓 firmware boot 起來可以去 check 是不是自己填進去的值, 若不是firmware可以hang, 類似 UCID.
                             offset設定在0x100之後較好, 前面是stack and vector table)
        
        ;;;m031
            cupid == m0
                if (0x40003ffc == 0x20171011)
                        offset 0x4000_xxxx
                else
                        offset 0x5000_xxxx

        ;;;m451
            m451 hd means 256/128 aprom, 32kB sram M451VG6AE. 
            m451 ld means 72/40 aprom (8kB dataflash), 16KB sram M451VD3AE  
            (HD or LD 可以從 6 and 3 區分)
            
            m451 has pgff

        ;玩轉新唐   "C:\work\codegen\玩转新唐M0_M4_V1.05.pdf"
TD  PDMA CRC
            CLK
                M0/M4系列因为有多个时钟源，所以CPU和外设都有多个时钟源可以选择。系统初始化的步骤如下：
                 使能外部/内部晶振，并等待晶振稳定（PWRCTL寄存器和CLKSTATUS寄存器）
                 选择CPU时钟源（CLKSEL0寄存器）
                 选择外设时钟源（CLKSEL1/CLKSEL2等寄存器）
                 使能外设时钟（APBCLK寄存器）
                 设定GPIO的功能（PA_L_MFP/PA_H_MFP等寄存器）
            
                HIRC(一般是22.1184M，也有的是12M或者16M), LIRC(一般是10K，有的是32K), HXT(范围一般是4~24M), LXT(32K), PLL
                注意：有的芯片外部晶振HXT和LXT是共用引脚的                    
                为了省电，上电之后，默认只有HIRC是起振的，其他都需要软件使能才会起振。起振之后也不是马上供给各个IP，也需要软件使能之后该IP才会有时钟，它的寄存器才能被访问和读/写
                选择IP时钟源，一般有上面5种可以选择。如果某个IP的时钟源不能选择，则它的时钟源就是HCLK（就是CPU的时钟）。选择时钟源之前，IP默认选择的时钟源和将选择的时钟源必须都要保持使能。不然IP将不工作。一般IP默认选择的时钟都是HIRC，如果IP想选择HXT做时钟源，必须先使能HXT(如果没有修改过Config0，上电后HIRC默认是使能的)，然后IP才能切换时钟源。千万不能先关闭HIRC，再切IP的时钟源，这样IP会不工作的，或者工作不正常。虽然在切时钟源的时候IP也许并没有工作，但是也要保证2个时钟源（当前选择的和将要选择的）都是使能的才能切时钟源
                
                默认CPU和内部总线以及各个IP大都选择内部高速晶振作为时钟源。除了极少数IP：WDT选择内部10K，LCD和RTC选择外部32K
            
                新唐的M0/M4一般都有时钟输出功能，用于调试内部时钟频率，或者产生时钟给其它芯片使用
                这个功能引脚一般叫CLKO/FCLK，设定寄存器是FRQDIV
                M051 can output HCLK on CKO, 有的芯片输出的频率至少要/2，那么输出的频率就是HCLK/2了

                有些芯片可以用外部32K  
                trim内部HIRC。一般HIRC全温度范围误差2%左右，trim之后HIRC精度可以达到0.25%左右。Trim功能一旦使能就不会停止。如果32K晶振频率飘出范围（内部设定的范围比较大一般是20K
                ~47K左右），trim就会停止并发生中断。所以需要在中断里面重新启动trim功能

                注意：如果外设时钟不等于CPU时钟(比CPU时钟慢)，写外设寄存器的时候需要SW自己同步。看门狗一般选择内部10K时钟做时钟源，我们就以看门狗代码为例，代码如下：
                WDT->CTL = WDT_TIMEOUT_2POW14| 0 |
                (0 << WDT_CTL_WTRE_Pos) |
                (1 << WDT_CTL_WTWKE_Pos);/*喂狗周期2^14，使能唤醒功能*/
                Delay(200);/*Delay 200us*/
                WDT->CTL | = WDT_CTL_WTE_Msk ;/*使能看门狗*/
                上面的代码连续写两次CTL寄存器，第二次写和第一次写之间需要等2个看门狗时钟周期，就是2个10K时钟，大概200us
                如果上面的代码改成这样：WDT->CTL = WDT_TIMEOUT_2POW14| WDT_CTL_WTE_Msk |0 | (0 << WDT_CTL_WTRE_Pos) | (1 << WDT_CTL_WTWKE_Pos);/*喂狗周期2^14，使能唤醒功能，同时使能看门狗*/
                这样就不需要delay了，因为同一个寄存器只写一次。
            reset    
                我们常用System reset切到APROM运行，或者切到LDROM运行
                其实用CPU reset也可以 但是System reset的好处是它会将所有的IP都复位，防止它们在新的程序里面乱动作
                
                低压复位一般有3个东西：BOD、LVR、POR
                所谓BOD就是低电压检测，类似于家里电压不稳时，灯闪烁。LVR也是低电压检测。BOD的好处是它有多个电压可以选择，LVR一般是固定的电压。
                POR就是上电复位，需要很低的电压才会触发它，一般是0.2V。就是电压掉到0.2V以下，才会触发POR复位；或者系统刚上电时也是POR负责复位所有的逻辑。
                有的MCU BOD和LVR都有，有的只有BOD。一般LVR和BOD总要使能一个，在掉电的时候做复位。否则，例如电压掉到1.2V又升到3.3V，MCU可能会工作不正常，这时候就要靠BOD或者LVR起作用了。
                NANOBN 只有BOD，如果软件关闭了BOD，那要掉到约0.2V(LDO)才会触发POR复位。
                NUC100 BOD和LVR都有
            
            GPIO
                NUC472和NUC442 Vbat负责PG.14、PG.15、PA.0和PA.1，这些脚由Vbat负责供电，所以Vbat一定要有电，即使不接电池也要和VDD接到一起。另外PG.14和PG.15默认为晶振功
                能用于外接32K晶振，如果想改为GPIO需要修改Config area。
                
                M451 有Vbat、VDDIO 和VDD 共3 个power domain。Vbat 负责PF0 ~ PF2，VDDIO 负责 PE.8 ~ PE.13
                并且Vbat 和VDD 以及VDDIO 这3 个电压可以不同，例如：VDD 给5V， VDDIO 可以给3V，
                Vbat 可以给3.6V，这可以用于板子上有多个电压的情况
                
                GPIO IP有个寄存器叫OFFD(OFF Digital)，关闭相应管脚的数字通路的意思。如果某个管脚配置为模拟功能，例如：ADC、DAC、ACMP、SEG、COM、DH1、DH2、V1、V2、V3等功能，这些管脚对应的OFFD bit应该使能，关闭到数字区域的通路，避免内部数字器件不停的打开、关闭而漏电。
            
            TIMER
                (pin) TCx (time capture) and TMx (事件計數)
                
                timer freq upto PCLK
                
                NANO100BN Timer功能介绍以及如何精确捕获信号频率
                血氧中弱灌注信号的频率变化只有0.4%甚至0.2%，频率可能有400K ~ 500K，要测量到如此高的频率，并且变化很小的数据，就需要非常精准计数的Timer和高效的CPU
                定时功能
                    单次模式、周期模式、反转输出模式、连续计数模式
                捕获功能                    
                    free counting, trigger counting, reset mode
                    如果没有开debounce, 最高捕获的输入频率是Timer工作的频率/3
                    如果有开debounce, 最高捕获的输入频率是Timer工作的频率/10

                pwm 頻率計算
                第一种方法用Time Capture然后polling     捕获标志TCAP_IS计录信号个数，同时软件读捕获到的值TCAP寄存器进行计时；
                第二种是通过Inter-Timer模式，由硬件进行计数，两个Timer自动成一组，一个负责计数信号个数，一个负责计时 <-to measure input frequency precisely
                    
                    
            ADC
                新唐的ADC采样速度目前从300KSPS~1MSPS不等，通道8～16个不等。一般只有1组ADC，各个通道轮流采样。也有的是2组ADC，可以同时采样2个通道，例如:M0519
                有的芯片有外部参考引脚Vref，有的只能使用AVDD（模拟电路电源脚）做参考。有的芯片有内部参考和温度传感器。
                但是内部参考一般不太准，全温度范围一般误差10%左右。使用内部参考的时候如果MCU有Vref引脚可以从Vref输出，然后接1uF到地，
                这样内部参考更稳定。内部温度传感器使用ADC采样, ADC采样得到的电压值，减去Offset，然后每降低1.68mV温度上升一度
                
                ADC有3种工作模式：单次、单次循环和连续循环模式
                  单次：就是在某个使能的通道上完成一次转换就停止
                    单次循环：就是在所有使能的通道上完成一次转换就停止
                    连续循环：就是在所有使能的通道完成一次转换，再完成一次转换，连续不断的转换，直到软件将其停止
                ADC的信号有2种输入模式：单端，差分
                 单端：就是采样单个通道
                 差分：就是两个通道的信号相减再采样
                要让ADC工作很容易，但是要用好ADC是不容易的。ADC的转换结果受参考电压的影响很大，如果希望转换结果更准确，参考电压就不能波动。另外如果使能了多个通道轮流采样，因为内部只有一个采样电容，各个通道之间会互相影响。这个时候可以通过外加电容，并降低ADC的工作频率，增加ADC的采样时钟等办法来解决。
                例如：使用ADC检测VDD电压。使用两个400K电阻分压然后拉到PA.0采样，同时PA.1也使能用来采样其它的信号。这时候如果PA.1的电压比PA.0高，检测到的VDD电压会偏高，否则会偏低
                用示波器看PA.0的信号，也会看到信号是波动的，这个波动很正常。因为PA.1比PA.0高的时候，采样PA.0时，内部采样电容会放电，将PA.0的电压拉高。这时候降低ADC的工作频率，增加采样时钟个数，测到的PA.0的值就会正常了。如果PA.1比PA.0低，这时候PA.0外部需要接对地电容，它可以对PA.0快速充电，测到的PA.0的值就会正常了

            I2S
                新唐的I2S接口可以外接audio codec，例如：接新唐的NAU8822，NAU8810等。一般支持I2S数据格式和MSB Justified数据格式，有一些支持PCM mode A和PCM mode B格式。可以作为I2S Master和I2S slave，一般情况下都是作为I2S slave使用，不然播放不同采样率的音频，MCLK引脚出不同的频率给audio codec比较困难
                (pin)
                I2SMCLK：由I2S Master提供。I2S做Master时提供MCLK给audio codec，它应该=采样频率*2*256，例如：如果采样频率=44.1K则MCLK应该给=44.1*2*256 = 22.5792M
                LRCLK：由I2S Master提供。是左右声道的时钟信号
                I2SDO：I2S数据输出
                I2SBCLK：由I2S Master提供。I2S收/发数据时每个bit的时钟。它应该=分辨率*采样率*通道数。例如: 16bit， 48K，stereo的数据，BCLK输出的频率=16×48×2 = 1536K
                I2SDI：I2S数据输入
                
                I2S可以收发数据而已，如果连接了audio code，还要通过I2C去初始化audio codec
                
                44.1KHz 要準要 trim
                
            LCD
                NANO100系列和NANO112都有带段式屏的驱动。一般最多6个COM，40个SEG
                C-Type优点是可以保持电压，即使系统VDD已经掉到段式屏期望电压以下，V1/V2/V3输出的电压仍可以保持，缺点是比较耗电
                R-Type和Ext_C-Type都不能保持电压，就是说当系统VDD往下掉的是，LCD IP打出的波形电压也会跟着往下掉。R-Type是在V1/V2/V3上接电阻分压，缺点是因为到地一直有个通路，将一直漏电。优点是IP内部有带分压电阻，外面引脚可以不用再接电阻了，但是仍需要接电容到地。
                Ext_C-Type是最省电的方式，在V/V2/V3接电容到地即可。这种模式不会漏电
                
                上面的代码因为LCD要用外部32K做时钟源，所以先使能32K晶振并等待晶振稳定。因为LCD只能选择32K做时钟源，所以不用再选择时钟源
                
            RTC
                RTC实时时钟，就是用来显示时/分/秒、年/月/日/星期等信息的。上电之后，初始化完成，只要不断电，
                它就一直自动记录当前时间。任何时候都可以从它内部的寄存器读出当前的时间和日期
                RTC一般使用外部32K做时钟源，RTC准不准，关键就看32K晶振是否准了。一般32K晶振都会有一定的误差。
                如果希望RTC非常准，32K晶振就要进行补偿。新唐的RTC一般都带频率补偿寄存器。补偿值需要软件自行填入
                一般一批32K晶振误差都差不多，使用频率计数器测一下晶振，然后将补偿值填入RTC就可以了
                RTC除了做时钟，还能产生Tick中断和Alarm中断，并能唤醒系统。
                RTC中有两个特别的寄存器INIR和AER，上电之后需要写0xa5eb1357到该寄存器，让RTC退出复位状态；
                AER是读/写使能寄存器，默认RTC的大多寄存器只能读，有的读都不可以。写0xA965到该寄存器可以解锁寄存器读/写 512 ～ 1024个 RTC时钟周期不等，不同的芯片这块规定不同。
                RTC的时钟源为32K，512个clock就是16ms，一般设定RTC功能，这个时间都够用了
                NUC505的RTC需要特别介绍一下，因为这个RTC支持按键开机/关机功能
                
            SPI
                常用的4线1-bit模式，有的还有two-bit和Quad Mode。做slave时还可以不用片选信号SS，就是常说的3-线模式。另外，片选信号有的芯片有2根SS0和SS1。
                SPI一般4根线SPI_SS、SPI_CLK、SPI_MOSI、SPI_MISO
                SPI的CLK频率最快一般可以达到30M，不同的芯片有点差异，有的快些有的慢些
                SPI还支持使用PDMA收/发数据，或者用FIFO收/发数据。FIFO一般2级~8级。其实测试下来FIFO模式收/发数据比PDMA快，因为SPI可以连续接收数据到FIFO中，SPI总线上的数据之间可以没有间隔，只要软件来得及读走，这个速度可以达到SPI的极限；但是PDMA收/发需要时间，SPI收到数据，通知PDMA，然后PDMA读走数据，再通知SPI可以触发下一笔了，这之间需要很多个SPI IP时钟。目前测试最慢需要23个PCLK时钟。
                所以如果要将SPI速度调到最大建议使用FIFO模式，如果SW要做其它事情，来不及收数据，PDMA+FIFO是很好的选择
                
                下面的代码将SPI配置为SPI_MASTER，MSB优先，波形为 SPI_MODE_0，每笔数据 32bit长，SPI_CLK频率2M。写SPI TX寄存器就会将数据发送出去，读SPI RX寄存器就会得到从MISO引脚收到的数据。可以将SPI0接口的MISO0和MOSI0对接，这样发送出去的数据就会从RX寄存器读到。
                所谓波形就是设定CLK idle 极性，上升沿/下降沿发送，上升沿/下降沿锁存。
                SPI_MODE_0就是CLK默认低电平，下降沿发送，上升沿锁存。
                按照SPI规格定义，SPI总共有4种波形，其它波形也都大同小异

            ACMP
                比较器有两根输入脚分别命名为：正端(positive)和负端(negative)外加一根输出脚。比较两根输入脚的电压，如果正端电压大于负端，输出高电平，否则输出低电平。
                比较结果可以输出到引脚上也可以读比较状态寄存器得到（输出引脚就可以当作普通IO使用）
                负端输入电压有几个选择：比较器负端引脚(由外部输入电压)、内部阶梯电阻分压、内部参考电压和模拟地。如果选择内部阶梯电阻分压，分压公式如下：
                比较电压 = AVDD x (1/6 +CRV/24)， CRV = 0 ~ 15
                比较器工作原理很好理解，要用好比较器，还需要理解它的很多电气特性
                 Input Offset Voltage：输入电压偏移，就是输出为0时，N端接地，P端需要施加的电压
                 Output Swing：是指输出摆幅，就是输出信号最大值和最小值之间的差值
                 Input Common Mode Range：是指输入共模电压范围，就是(N+P)/2的范围
                 DC Gain：是指放大倍数，40db就是指放大100倍。输出/输入 放大100倍
                 Propagation Delay：是指传输延迟。
                 Hysteresis：是指迟滞。例如：P比N大输出不是马上变high的，而是P要比N高10mV才会变high；P比N低的时候也不是马上变low，而是P比N低10mV之后，输出才会变low
                 Stable time：比较器的输出从低电平变高电平，或者从高电平变低电平所需要的时间
                但是ACMP IP不止上面的功能，有的芯片中的ACMP还支持Single SLOP和Sigma_Delta模式。Single SLOP就是单斜式，一般用于测量热敏电阻，例如：PT100的值。
                Sigma_Delta 测量精度比较高，但是速度不快，一般10几次/s
            
            WDT
                的寄存器是写保护的，配置WDT和喂狗都需要解锁才行, 看门狗除了复位系统功能，还可以将系统唤醒
                WDT一般不能选时钟源，只能以内部低速晶振(10K)做时钟源
                软件可以轮询该标志喂狗或者使能WDT中断在中断里面喂狗
                1.6ms - 6.4ms - 25.6ms ...-> 26.214s
            
            WWDT 
                窗看门狗和看门狗的区别就是WWDT上电之后一旦使能，就不能关闭，并且不能随意喂狗，
                WWDT计数器是下数计数器，它的值在0 ~ WINCMP之间时，才能写WWDTRLD寄存器喂狗，否则WWDT将复位系统
                这可以防止软件跑飞误将看门狗关闭，或者误喂狗。它用HCLK做时钟源，所以power down时它不能工作
                窗看门狗一般固定是用HCLK/2048做时钟源，超时时间是固定的64个时钟周期。但是WWDT有自己的预分频寄存器，可以将超时时间最多延长2048倍
                10.9ms - 21.8ms - 43.7ms ...-> 22.3696s
            
            PDMA
                有一个限制就是源地址和目标地址必须4对齐
            CAN
                速度1K ~ 1Mbps， 1Mbps大概可以传40m，5kbps可以传10公里
                CAN总线是多主机的，所以必须加入冲突检测，方法为CSMA/CR：冲突检测多路访问/冲突解决
                这些错误处理的机制导致CAN的一大特点：抗干扰能力很强。有人会将CAN和RS485比较，
                认为都是差分传输的，抗干扰能力是不是一样？差别在出错之后的处理。CAN检测到错误，硬件会帮忙处理，而RS485需要软件做；另外CAN的传输距离非常远，5kbps可以达到10公里
        ;;;M480
            ;m480 trm note
                clock
                	12 MHz High-speed Internal RC oscillator (HIRC) trimmed to 2% accuracy that can optionally be used as a system clock
                	10 kHz Low-speed Internal RC oscillator (LIRC) for watchdog timer and wakeup operation
    	            Up to 480 MHz on-chip PLL, sourced from HIRC or HXT, allows CPU operation up to the maximim CPU frequency without the need for a high-frequency crystal
                    
                    system clock will auto switch to HIRC if HXT clock stop, re-enable HXT to see if work and switch back or not
                    power down mode LIRC LXT and peripheral adopt them are still alive                    
                    
                reset
                    Watchdog Timer Reset (WDT)
                        handle the failure of MCU after watchdog time-out reset by checking WDTRF(SYS_RSTSTS[2])
                    CPU Lockup Reset
                        When chip enters debug mode, the CPU lockup reset will be ignored.
                    CHIP Reset is same with Power-on Reset
                        The MCU Reset SYSRESETREQ(AIRCR[2]) is similar with CHIP Reset. The difference is that BS(FMC_ISPCTL[1]) will not be reloaded from CONFIG0 
                SRAM 
                    total 160KB, 3 bank - 32KB (parity, stable),96,32 (can switch to spim flash cache)
                    three banks address space can be accessed simultaneously
                    can remap to 0x10000000
                auto-trim function
                    the HIRC trim (12 MHz RC oscillator), according to the accurate LXT (32.768 kHz crystal oscillator) or USB SOF (Start-Of-Frame), automatically gets accurate HIRC output frequency, 0.25 % deviation within all temperature ranges
                gpio
                    push pull - H/L both strong, like square waveform
                    open drain - H weak, low strong
                    quasi-bidirect - H 拉強一下子就不拉, 下來還是快
                    open & quasi - 不拉L 時都可讀到外部 pin H/L value
                    quasi H強拉的一小段能否讀到值看誰 driving 強
                spim
                    either SPIM_KEY1 or SPIM_KEY2 is 0, spim cipher will be disable. cipher_off bit 1 also makes cipher disable
                    
                uart            
                    Six sets of UARTs with up to 17.45 MHz baud rate.
                    Supports low power UART (LPUART): baud rate clock from LXT(32.768 KHz) with 9600bps in Power-down mode even system clock is stopped
                    
                    1. 接收端的取樣時機: 一般 UART 硬體設計的取樣時機是每個 bit 的 50% 之處. 也就是說 start bit 的取樣時機是 start bit 下降緣後 50% bit period 處.
                    2. 如果接收端的時序比發送端慢 1%:
                    Start bit 會在 51% 取樣, bit 0 會在 52% 取樣, ... bit 7 會在 59% 取樣, bit 8 (如果有) 會在 60% 取樣, Stop bit 會在 61% 取樣.
                    4. 如果短距離, 現代收發設備 (RS-232 剛有的時候的硬體速度可沒有像現在這麼快) . 在 60% 處取樣, 應該是沒有問題的.
                    5. 依此類推, 對誤差很小的 device 通訊時, 一個誤差率達 +-5% 的 device 會達到容錯的極限. 
                    6. 當然對 data length 是 7 bits, +-6% 或許是可能的. 
                    7. 如果發送端與接收端各 share 同樣的 tolerance, 那麼 +-2.5% 是可考慮的最大值.
                    8. 但是對於較長距離的傳送時, 尤其對高速傳送時 Slew Rate 就不可不考慮了. 所以對於公用設備的 tolerance 最好不要超過 +- 1~1.5% 較好. 對中低速傳輸, 如 9600 或 19200 bps 以下, 這是很容易的事.
                    9. 然而兩個誤差是同一邊時 (同時大或同時小) 再大的誤差也能接受. (意思是說: 若是有雙方協議時, 誤差又是另一回事), 由於高速傳輸多屬專用機 (例如 1M bps), 因此, 是否遵循常用 baud rate 那是另一個問題.
                    10. 也就是說, Microchip 在列舉 BRG 誤差時常將 5-10% 的誤差列出 (甚至有 30~50% 的數值), 這多是發生在低速 MPU 的 高 baud rate 時才會有此誤差. 列出的目的是供設計者選用 '時基' 的比較參考用, 是告訴設計者, 如果考慮整數 '時基' 時, 內部 timer 可能較便利, 但是通訊可用的 baud rate 就會有所限制. 但若以通訊為主要考量時 又會如何? 這自需設計者自行折衷的意思了
                    
                    假如使用dsPIC30F，20MHz，無倍頻，目標baud rate=9600bps
                    BRG=(20MHz/4)/(9600*16)-1=31
                    實際baud rate=(20MHz/4)/(16*(31+1))=9765
                    BAUD RATE 誤差率=(9765-9600)/9600=1.7%
                    1.由算式看BAUD RATE 誤差率，只是表示目標與實際baud rate的差而已
                    2.只要BAUD RATE 誤差率不是太大，資料收發都不會有問題。(BRG=29~33收發應該都不會有錯誤)
                    
                    /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
                        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
                    
                    The frequency of UARTx_CLK should not be greater than 30 times HCLK
                    
                    In IrDA function mode, the baud rate generator must be set in mode 0. More detail register description is shown in UART_BAUD register. There are three setting mode.
                    
                    uart mode
                        smart card - stop bit 0.5/1.5
                        irda - baudrate limit
                i2c
                    Supports Standard mode (100 kbps), Fast mode (400 kbps), Fast mode plus (1 Mbps) and High speed mode (3.4Mbps)
                    normal case master/slave - write/read data need different interrupt handler to control status
                    multi read/write - w/o interrupt
                    multi master
                rtc
                    pin config - X32_OUT/IN, tamper0-5
                    different power domain, diffrent clock source
                    supports periodic RTC Time Tick interrupt with 8 period interval options 1/128, 1/64, 1/32, 1/16, 1/8, 1/4, 1/2 and 1 second.
                    supports 1 Hz clock output (CLKO)
                    supports up 3 pairs dynamic loop tamper pin or 6 individual tamper pin.
                    TAMPER
                        When the transition condition defined in RTC_TAMPCTL is detected, tamper detected interrupt flag TAMPxIF (RTC_INTSTS[13:8]) will be generated. Meanwhile, the 80 bytes spare registers (RTC_SPR0 ~ RTC_SPR19) content will be cleared automatically by hardware to prevent the security data be disclosure and current RTC time and calendar will be loaded to RTC_TAMPTIME and RTC_TAMPCAL registers, these values only can be cleared automatically or update again when all TAMPxIF are cleared
                adc
                    12-bit resolution and 10-bit accuracy is guaranteed.
	                Up to 16 single-end analog external input channels or 8 pair differential analog input channels.
                    Up to 5.14M SPS(sample per second) conversion rate (m451 1msps)
                pwm
                    (pin) share with timer (TMx PWMx_CH0, TMx_EXT PWMx_CH1)
                    independent/complementary mode 
                    both has mask/break/polarity
                    complementary has deadtime
                    
                    deadzone, deadtime (two complementary wire)
                    通常大功率电机、变频器等，末端都是由大功率管、IGBT等元件组成的H桥或3相桥。每个桥的上半桥和下半桥是绝对不能同时导通的
                    
                    break has edge (0/1 pwm resume at next start when clear 0/1 its own IF) and level mode (0/1 pwm both resume at next start when clear either 0 or 1 IF)
                    break source 
                    1. external input signals 
                    2. two from internal ACMP comparator signals
                    3. system fail events (clock fail, BOD detect, SRAM parity error and CPU lockup)
                    4. software trigger brake event                    
                    
                epwm 
                    (pin) break0-1, pwm_ch0-5, sync_in/out
                    epwm (pll, with group/sync mode) diff pwm (pclk) -> counter, comparator, prescaler bit num are the same
                fmc
                    [2017wk12]FMC history: AP LD need switch -> APUEN (boot from AP can update AP) 
                    -> AP with IAP (boot from AP, cpu can see LD, LD/AP can call each other)
                    flash (isp) / system (cpu) memory map
                    
                    In system memory map without IAP mode, CPU still can access Boot Loader(0x0080_0000~0x0080_7FFF) and SPROM(0x0020_0000~0x0020_0FFF)
                    
            ;m480 ICE dongle
                schematic
                    \\copcb04040\PT30\Nulink\document\schematics\LAG018_ETM\ETM\Schematic
                
                M484SIDAE	LQFP64 (7x7)	flash512	sram160
                ETMC FIFO 16words 64bytes
                
                ETMC usage
                    bugs are timing sensitive/depend on interrupt execution order/dangling pointer is overwriting memory
                
                ;ETMC performance
                    68cycle (4WORDS) x 4 (16WORDS) = 272 cycles
                    O0 ETMCPDMA+USBDMA 228 cycle 
                        手算 94cycles (11/10新收到 firmware)
                    O2 ETMCPDMA 68 -> 37 cycles

                    ETMC PDMA 512bytes to SRAM
                        68cycle x 512/16 = 2176 cycle

                    USBDMA from INTERNAL SRAM to USB BUF 
                        512bytes -> 1488 cycles
                        1KB -> 2866 cycles
                        2KB -> 5582 cycles

                    O0   FW:pingpong 50KB EP 3KB     PC: BUF 100KB   RESULT: 3.7MHz traceclk

                nxp m7 test kit (kv5x series) twr-kv58f220m
            ;M480 performance (ychsu 2017 wk3)
                v6635 test result
                SRAM: M480 ICE BULK 12MHz, cpu 160MHz access 1MB sram R 1.9s W 1.9s. NUC100 ICE BULK 12MHz, CPU 48MHz, access 1MB R 13s W 13s (same 1w1r nulink protocol) improved from 77KB/s -> 500KB/s
                        以上 1w1r, ychsu 改 20w1r, SWD 12MHz 667KB/s, 24MHz 1.1MB/s
                        old nulink (read timing is same with write)
                            ICE clock	1M	        2M	    4M	    8M	    12M	    20M
                            Write	    22.92 sec	17.27	14.59	13.32	13.05
                        M480
                            Write	    13.14 sec	6.99	3.91	2.25	1.93	1.40
                flash: M480 e+p+v (512KB) 時間icp online nulink1.0 - 30s, nulink2.0 - 20s 
                       v6635 offline download m480 512KB nulink1.0 take 40secs, m480nulink 22secs            
                       SPI flash: indirectly path (ICE -> SWD -> target chip  -> SPI flash) 2MB, improved from 3min to 1min, direct to SPI flash 
                           direct path (ICE -> SPI flash) ~25sec (M480 ICE only)

                max target CPU clock rate depends on ETM data save to ICE SRAM (192MHz), PC DRAM (20MHz)

                m480 物理極限:
                    block erase (4 page) 3sec, page erase (11.5sec), mass erase (0.2sec) 
                    program 32bit (5.5sec) multi (1.5sec, but ICP decrypt is too slow and when register empty, multi will be stop, so now icptool is still word program)
                    verify 32bit read (0.1sec)
                    diffie hellman, encrypt and decrypt, swd transfer, multi program            

                [kywu 20151105 mail] In the flash macro of TC8222, Byte Program time : 20us (min), Page erase time : 20ms (min) and Mass erase time : 20ms (min).    
                [ccma 20151105 mail]
                                    erase
                                        512kB about 5.1x seconds
                                        page (sector) erase  20ms  (page size 512bytes or 2kbytes are the same)
                                                        20ms      (m451, nuc472)  
                                                        2ms (nuc100dn, m0564)  
                                                      80-160ms (m481)  realchip 90ms. block erase 16KB realchip 32blocks 2.87s, bank erase 2banks realchip 180ms)
                                        chip erase       60ms   (m451)  10ms (nuc100dn, m0564) 
                                                         m481 80-160ms (realchip 200ms)
                                        config erase 22ms

                                    Program
                                        512kB also 5.2x seconds
                                        
                                        1word 
                                        Mini51/58: 60us
                                        M451 60us, nuc100dn/m0564 20us, m481 8-16us (from kywu, setup time typ 5us, hold 20ns) 
                                                                              (from ychuang, word-prog 5.418s, multi-program 512KB 1.332sec)
                                        nuc472 20-40us 
                                        Others: 40us 

                                        If multi program (8 bytes to 128bytes or 256bytes) in m451, reduce setup time and hold time
                                        1st byte 60us, other 127bytes are 40us
                                    read 
                                        m481 512kB, 32bits 87ms, 64bits 43ms
                                        
                    flash DC electrical characteristics: flash endurance - 10000 (m481) 20000 (m451) 100000(nuc100dn), data retension - 100year (m451) 20year (nuc100)
                
                ITM can support logic analyzer, RTOS awareness debugger                
                
            ;SecureISP Tool M480
                secureISP VS ICP Tool，燒SPI Flash填了SPI Key0/1，用ICP Tool的SPI Flash有加密，燒寫相同方式但SecureISP Tool”無”加密

        ;;;m2351
            Q: m2351 multi aprom binary , m2351 icp IB online/offline calculate by MKROM?
            A: now one bin file, but can separate IB 6 regions. IB calculate by PC tool itself.
            
            Q: WAITCPU should be use?  
            A: register 安排在 DP, hw reset 清不掉, default 是 freerun, 只能由 ICE set to wait <- but this only useful for nulink. 
               先不加, 只要code不要放太前面, 相關問題 connect under reset 都可以解

            Q: target flash is empty, read DHCSR get "LOCKUP and not S_HALT", but SRAM can be R/W
                set VC_CORERESET and SYS_RESET is still "LOCKUP + not S_HALT"
            A: you have to set DHCSR dbgen if you want Vector_Catch take effect
                SYSRESET 是可以 reset, 救起 LOCKUP 的
            Q: 如果 m2351 scrlock, ice read 0x40000000, cpu 也會跑進去 secure hard fault 嗎? 
            A: ice 錯誤存取不會讓cpu 進 hardfault
            Q: non-secure project SRAM 可以直接設定 0x30010000?
            A: 跑完 Scu config , 0x30010000 才能存取    
            
            2nd dev kprom unlock can be key in by 2nd developer
            YCC: do we support flash bp? - can be use in 1st develop. but cannot when SCRLOCK/KPROM & 2次無法use flash bp.                
            
            ws said secure hardfault happen has chance to jump to NS hardfault

            Review V8M can't halt problem, 這個最早先的問題是 NS region NO CODE 的情況, 因為 NuLink firmware 原始 flow 是 halt -> vc_sysReset -> halt, 
            在 NS flash 為空, SCRLOCK的時侯, 用原本NuLink firmware flow連接會halt不住CPU. 因為這種 case 一跑到NS code 馬上進到 S hardfault, 所以原先flow直接下第一個 halt
            會失敗跳出, 要改一下 flow, 不要有第一個halt, 先下第二個 reset vector catch, 再下 system reset, 就可以 halt 在 NS 1st line.
                    
            iar m2351 2nd, the iar FLM archtecture not have Init() to get PID, so ycc put keil.FLM into IAR nulink driver, and move keil.flm to SRAM and call Init manually
            iar c-spy m2351, a delay needed for secure code set NSC and chip reset, in ewarm
            xom erase (connect time we can control - then chip reset - then program///  put in keil algo), 

            
            NSCBA, SCRLOCK, Secure boot keys, ARLOCK. can only be esased by FLASH Mass Erase ISP CMD (0x26)

            m2351 online scrlock/sbk/xom need do chip reset, icpen didn't work, need to reload sram and run after chip reset. offline chip erase didn't chip reset to take effect, and then program others at a time, so offline part didn't use chip reset.

            ;secureISP m2351

                CMD_DH_KEY	用來交換產生 DH key 
                CMD_AUTH_KEY  輸入 kProm key0, 1 , 2  錯誤的話，會回 err

                xom need reset 3 time - erase, program, IB cal
                burn NS bound, 上方緊接著的是 IB, 若設 XOM, IB讀不出來會掛, NS bound 第一個page設 XOM, 跳進來CCTu said 也會掛 (maybe)
                mass erase will make uart select pin change? yes, mass erase mkrom can't backup config0/3, becuase SRAM also will be cleanup. 
                    but general config0 change, config3 UART pin will be kept                
                xom use crc to calculate IB
                config change 1bit need chip reset to enable
                mass erase don't need to change config0 bit[13] mass erase enable bit, it only enable by ICPEN
                ICPTool 是設計成勾選 Secure Key 時會順便更新 IB
                
                user 在non-secure lock 時, 是可以燒 key 的,  Secure lock 後 key 就不能燒了. 
                而在 non-secure lock 時, 燒過 key 後, 再重覆燒第二次key就會顯示下圖的 error
                選ok繼續進行, 就會用 user 提供的 key 算 IB, 只是這算出來的 IB 和芯片內的一定不符合是嗎?

                mkrom 只吐 nsbound, ap size, a/scr lock, kprom enable. ib 算出來的沒吐               
                MKROM
                    二次開發的人也可以燒/更改 KPROM
                    lock SRCLOCK or ALOCK, 只要輸入 kprom match 後, 就可以 program 2nd NS region, secure region任何人都不能寫
                    kprom設定key的位置都是落在 secure region
                    mkrom 權限很大, 能燒的不限於 NS region
                    通常出新系列 , MKROM 才會去改


                ; mkrom features 
                    ; scrlock & boot from mkrom -> must be secure booting
                    ; secure code can't be programmed by MK if scrlocked. mkrom can't offer Scode update function w/o mass erase.
                    ; secureISP can connect MKROM in 2 situations, first is secure boot fail, second is 1stDev call MKROM_INIT() and MK will wait for connection.
                ; consensus
                    ; when secure boot, S/NS code all have the needings to upgrade
                    ; kprom can be programmed by 1st/2nd, that have to share that key if all need code upgrade.
                ; what's the role that tools play?           
                        secureISP - for 量產後, 留後門主動權在客戶 1st (chip erase)/2nd 可 upgrade fw, 從usb/uart
                        ISP - for 量產後, 若 1st 對我們 Secure boot tool 提供的方式不滿意, 給他們 sample code 自刻, 可不用 chip erase. 2nd 基本上 call MKROM_INIT + secureISP 即可
                        ICP - 最後救援, 拆殼全部重燒

                        ; secureISP - post-MP updating (UART USB)
                            ; S update
                                ; secure boot fail for unknown reason, mass erase -> re-program all
                                ; secure boot fail on purpose (tamper code by some trigger) -> secureISP -> mass erase -> re-program all
                                ; secure boot pass but some behavior can trigger MKROM_INIT() by 1stDev fw -> secureISP -> mass erase -> re-program all
                            ; NS update (S has to provide NSC for NS call MKROM_INIT)
                                ; secure boot pass at SCRLOCK, S or NS use some trigger to call MKROM_INIT for NScode upgrade.
                                ; secure boot pass at ARLOCK, S or NS  use some trigger to call MKROM_INIT for NScode upgrade. (KP needed)
                        ; isptool (UART USB) - post-MP updating (UART USB)
                            ; S update
                                ; customizing code by user, update secure code partially, 1stDev needs to make isp fw carefully, and have to update IB by himself
                            ; NS update
                                ; call MKROM_INIT + secureISP
                                (minor) ; customizing code by user, 2ndDev write his own code by calling MKROM APIs.
                        ; icptool - pre-MP updating (thru ICE)
                            ; S update
                                ; can update S/NS before LOCK
                                ; can't do S update after SCRLOCK, can only chip erase -> re-program all
                            ; NS update
                                ; can update NS after SCRLOCK
                                ; can't do anything after ARLOCK,  can only chip erase -> re-program all
                
            m2351 ulink use nulink flash algo -> Do remember to set larger SRAM!! 0x800 is not enough!
            
            bootloader code
            file:///C:/work/project/v8m/TC8234_BSP/SampleCode/MaskRom/MKROM_DebugInAROM
        
            to judge SCRLOCK or not
            #define V8M_DHCSR                             0xE000EDF0UL  bit20 define V8M_DHCSR_SDE                      0x00100000UL   value 1 can invasive debug
            
            * interrupt vector table 
            gdb disassembly, set in assembler code?
            keil axf.c will get LOAD region of elf file to specify where KEIL load to?	
            
            ;;gcc m2351
                [compile option]
                    arm-none-eabi-gcc -march=armv8-m.base -mthumb -mcmse -g3 -c main.c
                    arm-none-eabi-as -march=armv8-m.base -mthumb startup.S -g3 -o startup.o
                    arm-none-eabi-ld -Tflash.ld -o output --cmse-implib --out-implib=nsclib.o
                    
                    VSS M2351 folder 抓下來的 BSP TZ sample 少了 -mcmse option, _ARM_FEATURE_CMSE=1 
                    .gnu.sgstubs放在RAM會 assert.  arm-none-eabi-ld: BFD (GNU Tools for ARM Embedded Processors) 2.26.2.20160923 assertion fail /home/build/work/GCC-5-build/src/binutils/bfd/elf32-arm.c:4185

                    .gnu.sgstubs :
                    {
                        . = ALIGN(4);
                        *(.text)
                        . = ALIGN(4);
                    } >FLASH   


                NSCBOUND 0x200800[23:0]
                SCRLOCK 0x200804[7:0] 0x5a means unlock
                SCB_NS 0xe002e000  VTOR offset 0x8

                coremark
                    M451 (YChuang's code)
                    MDK454 2.17
                    MDK514 2.67

                    MDK514+GCC5.4
                    O2(Time) 2.453
                    O3  2.600

                更改 scatter loader , .axf 以及 .bin 都會記錄 execution region 的改變. .bin 會帶 VMA 資料.
                
                void __attribute__ ((section (".FUNCTIONA"))) testTerry(void);

                
                [MDK option] --import-cmse-lib-out .\Objects\nsclib.o
                [gnu option] -mcmse     –with-newlib
                
                GCC modify:
                    __Vector to __isr_vector
                    add __TZ_set_MSP_NS in cmsis_gcc.h
                    idau_ref -- mark temporarily
                    SCB->VTOR = (uint32_t) &isr_vector;
                    
                    #if defined ( __GNUC__ )
                    #pragma GCC diagnostic ignored "-Wsign-conversion"
                    #endif
                    
                [eclipse setting]
                    project/workspace/global setting of eclipse
                    ${cross_prefix}${cross_c}${cross_suffix}        
        
        ;;;8051
            [2017wk16](ycc)
                icp n76e  003/885/616  n79e  4t  (尾名不看)
                nugang without 8051
                use isp-icp's gang (003 has implement, but tien sir didn't test yet)
                keil 8051 all supported
                [wk19]
                8051 with sprom /885/616/003
                8051 nugang serial number, bcd mode, not write what burn what

            icp know 8051 did, can limit 002 only to 10KB. 
            Supported SFR Page Selection., Supported SPROM mapping (64k version ml51) can access memory windows to get, chip before ML51, memory window can't edit

            ;ml51 ram 256B scratch-pad ram, 4/2/1/0.5 XRAM (access by MOVX)
                The lower 128 bytes of internal RAM are present in all 80C51 devices. The lowest 32 bytes as general purpose registers are grouped into 4 banks of 8 registers. Program instructions call these registers as R0 to R7. Two bits RS0 and RS1 in the Program Status Word (PSW[3:4]) select which Register Bank is used.
                
                SFR has 3 pages can be changed at 91H
                
        ;;peripheral
            ;rs232, ;uart
            serial port complete
                communication protocol - full duplex, flow control (hw/sw)
                message protocols - 

                baud rate < bit rate (decrypt from encrpted data) (in most case they are the same)
                auto detect baud rate - sender send from lowest baud rate, send 00, receiver takes every low as start bit, if can't detect stop bit at given time, sender try another baud rate.
                
                async transmit bit 0 LSb first, sync is MSb(the pic said)
            a，軟體交握：在傳輸中，接收方發現由於CPU忙於其他工作，輸入buffer已經滿了。為了暫時停止傳輸，接收方發送XOFF，典型的值是十進位19，即十六進位13，直到輸入buffer空了。一旦接收方準備好接收，它發送XON，典型的值是0x11，繼續通信。輸入buffer半滿時，LabWindows發送XOFF。
            b，硬體交握：RTS（Request to Send）和CTS（Clear to Send）。當接收方準備好接收資料，它置高RTS線表示它準備好了，如果發送方也就緒，它置高CTS，表示它即將發送資料。另一組線是DTR（Data Terminal Ready）和DSR（Data Set Ready）。這些現主要用於Modem通信。使得序列埠和Modem通信他們的狀態。例如：當Modem已經準備好接收來自PC的資料，它置高DTR線，表示和電話線的連接已經建立。讀取DSR線置高，PC機開始發送資料。一個簡單的規則是DTR/DSR用於表示系統通信就緒，而RTS/CTS用於單個資料包的傳輸。
            rs485 (differentiate transfer TX+ TX-, define 電器特性接多個 devices - rs232 只能二個 devices 對接)    

            file:///C:/data/nuvoton/peripheral/UART、I2C、SPI三介面特性.html
        
            usart (reach 4 Mbps, more power comsuption than uart)  
            

    ;google ;chrome
        續傳 chrome://flags/#enable-download-resumption
        
        Ctrl+Shift+T 鍵	重新開啟您最近關閉的分頁。「Google 瀏覽器」會記住您最近關閉的 10 個分頁。(按一次開一個)
        Ctrl+B 鍵	開啟與關閉書籤列。
        開啟連結並切換至連結網頁	按住 Ctrl + Shift 鍵，然後按一下連結
        在新的背景分頁中開啟連結	按住 Ctrl 鍵，然後按一下連結
    
    ;office
        multi boot menu -> msconfig, boot tag

        sslvpn.nuvoton.com
    
        ;address
            高雄市左營區立文路77號17樓之2        
            17F.-2, No.77, Liwen Rd., Zuoying Dist., Kaohsiung City 813, Taiwan (R.O.C.)
        
        ;NB 
            電腦名稱 pc name OANBE02773, (財編 MSITEQT02773) Lenovo X270 (29500NTD)
                edition win10 enterprise 2016 LTSB, version 1607
                cpu intel core i5-7200u 2.5ghz, 8gb ram, 64bit cpu/os 
                update Java Version 8 Update 161
                
            OANBE01937, ACER TravelMate 8481G-52464G32ncc  
        ;VSS
            select \\Nthcrdvss01\pu00\PU00\srcsafe.ini and use OA account to log in
        ;source insight
            變更Source code的字型
            Options->Document options->Screen Fonts->大小 --> 加大字型。
            固定字型Courier New

            將Tab鍵改為多格空白
            先進入Options->Document options
            a. 先打勾Expand tabs
            b. 裡面的editing options群組有 Tab width
            可以更改tab為空白

            建立project時，添加特定類型的文件（文件類型過濾器）
            如我之前常寫8051會有*.def
            在Options->Document Options裡面，點左上的Document Type下拉選單，選擇x86 Asm Source File，然後在右邊的File filter裡*.asm；*.inc；的後面加上*.def；接著CLOSE就可以了

            如果覺得 if,for,while的{}對齊方式不太順
            options->Document options 裡面的 "Auto Indent..."按鈕, 將裡面 Indent Open Brace,Indent Close Brace取消.

            自定義快捷鍵
            選擇Options/Key Assignments，在彈出的Key Assignments窗口中可自由添加自己喜歡的快捷鍵。 比較值得推薦的有如下幾個快捷鍵定義：
            如: 按小鍵盤的/*-+螢幕都會亂跳
            options->Key Assignments, 裡面在command鍵入
            Navigation: Scroll Half Page Down
            Navigation: Scroll Half Page Up
            Navigation: Function Down
            Navigation: Function Up
            就可以修改，並順便改一些你常需要的功能.

            displaying full path of a file in title bar
            Options -> Preference -> Display -> Trim Long Path Names With ellipses
        ;enviromental varialbe
            HTTP_PROXY
            http://ccma@Terry705@nthcwgcls:8080
            HTTPS_PROXY
        
            ;user
                PATH
                    C:\Program Files\GNU Tools ARM Embedded\7 2017-q4-major\bin;
                    C:\Program Files\Java\jre1.8.0_91\bin;
                    C:\yotta\python;C:\yotta\python\Scripts;
                    C:\Program Files\Microsoft VS Code\bin   
                
                UV4 c:\keil\524p\UV4\UV4.exe
            ;system
                C:\cygwin\bin;C:\Program Files\GnuWin32\bin\UnxUpdates;
                C:\Program Files\GnuWin32\bin;C:\ProgramData\Oracle\Java\javapath;%SystemRoot%\system32;
                %SystemRoot%;
                %SystemRoot%\System32\Wbem;
                %SYSTEMROOT%\System32\WindowsPowerShell\v1.0\;
                c:\Program Files\Microsoft SQL Server\90\Tools\binn\;
                C:\Program Files\Windows Kits\8.1\Windows Performance Toolkit\;
                C:\Program Files\Microsoft SQL Server\110\Tools\Binn\;
                C:\Program Files\TortoiseSVN\bin;
                C:\Program Files\TortoiseGit\bin;
                C:\Program Files\Java\jre1.8.0_91\bin;
    
        ;android app
            touch lock -- touch screen disable to watch youtube
            
        ;scope ;osc
            探棒上的倍率, 10X代表先將擷取的訊號/10後再*10 
            
        ;LA ;logic analyzer        
            LA logic analyzer brand 皇晶科技 Acute TL2236B
            1MHz SWD, LA sampling rate 5MHz is too slow, better to larger than 10MHz
            LA 操作注意, 地線是分多個 group, pin16 and pin1 都有它自己的 GND, 另外若要觀察 pin5, pin6, 采集的 channel 數要是9, channel 數6不行, 因為 0-6 > 6
            
            语句式连续条件触发, sequenced by "custom rising", then set DATA individual (notice that picture is very help) and you can see the diff between next and thenIF (next is right next wave, thenIF is not continuous). thenTrig is an end
            
            usb view to see descriptor

            
        ;word
            shift F5 找到上次編輯的位置
            
        ;printer
            size -> letter
            new ricoh
            old hp p3005
        ;toshiba小白
            win7 64, win10 64
            
        always open file "partnumber.cpp" <- use my favorite of IE
        
        cmder (alias e.=start.)
        cd %odf%  <- odf set by UI
        
        rename/move dir, shortcut will follow
        "file:///C:/shortcuts/as.lnk"  <- click and goes to link dir directly
        
        is there any way to check IIS server is running automatically?
            Type in Services.msc at the search bar
            Look for the World Wide Web Publishing Service

        ;用鍵盤移動視窗的密技 alt+space
        
        ;cmd.exe command window
            当cmd里输入路径包含空格的时候 用缩写。比如c:\Program Files缩写为c:\Progra~1
            如果多个文件前6字符一样怎么办？ 则三个目录分别表示为：C:\Progra~1; C:\Progra~2; C:\Progra~3;
            
            environment variable - 改上面的 User variable, 重開 cmd.exe (因為不同 process 所以要重開值才可能被其它人改到) 輸入 echo %PATH% 可以看到 PATH 變化
                                    cmd.exe 裡面去改 varible只是暫時, 不會影響到到視窗界面那個根本的
            
            reg query HKEY_CURRENT_USER\Environment /v TEMP   (/v to indicate specific var, can be omit)
            reg delete HKEY_CURRENT_USER\Environment /v USER_EXAMPLE /f

    
        ;outlook
            received:>=2017/5/06 AND received:<=2017/6/06 content:sprom
            
            received:>=10/1/06 AND received:<=10/5/06       Items that arrived between 10/1/06 and 10/5/06.
            sent: yesterday
            subject:status
            cc:"bobby more"
            hasattachment:yes
            attachments:presentation.pptx
            bobby NOT moore 	                            Items containing bobby, but not moore.
        weekly report word file transform to txt file
            install libreoffice first, add soffice.exe into PATH 
            C:\Program Files\LibreOffice 5\program;
            then run  "file:///C:/personal/doc2txt.bat"
    
        windows preview pane .py file            
            computer\HKEY_CLASSES_ROOT\.py
            新增 key string PerceivedType text
        ;excel
            =IF(ISNA(VLOOKUP(E3, $C$131:$D$156, 2)),"",VLOOKUP(E3, $C$131:$D$156, 2))
            =IF(ISNUMBER(J20), J20, 0) + IF(ISNUMBER(L20), L20, 0) + IF(ISNUMBER(N20), N20, 0)
            =COUNTIF(午餐!$I$3:$I$66, E4)
            
        windows crontab
            win10
                search "scheduler"
                
            win7
                control panel -> administrative tools -> task scheduler -> create basic task
                batch file -> copy C:\weekly-report\worknote.yaml C:\weekly-report\worknote-.yaml 不用絕對路徑 copy 會找不到檔案
                pause   最後不希望 command windows 消失, 加pause        
                選左邊頁面的 task scheduler library 可以看到設定的項目
         
        windows cmd create recursive dir -> mkdir "dir/dir" <-- must have ""
        
        jump to c:\  -->  cd\
        
        ;backup
            \\nuvoton.com\deptshare	
            \\nuvoton.com\public
            \\nuvoton.com\prjshare
            \\coPCB04040
            \\nuvoton.com\prjshare\MCU_FAE
            
            ;cmder alias
                alias -> to list alias
                gco=git checkout $*
                win10 may not work, cmd.exe -> property -> use legacy console
                
        ipconfig /all ==to list all network device 
        
        windows system variable:         
        windows commmand line: set
            set /?   -- list help
            set x=   -- delete x
            set x=11 -- set x to 11
            echo %x% -- display x
        close all command windows and reopen to enable the effects

        outlook archive
        file:///C:/Users/CCMA/Documents/Outlook%20Files
        
        windows file explorer
            Alt + Up – Switches to the parent folder in the hierarchy
            Alt P – Toggles the Preview pane
            Alt+Enter – Opens Properties for the selected object

        devmgmt.msc
        appwiz.cpl

    ;cygwin
        /  <- C:\cygwin
        ~/ <- C:\Users\CCMA
    
    ;npp
        crush and rescue
            C:\tool\npp.6.7.5.bin\backup
        
        npp jump back to previous cursor position
            location navigate plugin
                
        npp how to list all hotkey -- setting -> shortcut mapper  (remember to disble plugin shortcut, like COMPARE)
        fold to level one - first alt+0 to fold all, then shift+alt+1 to unfold to that level

        shortcut mapper
                bookmark CAS+V
                explorer CAS+E
            main menu
                move to another view C+k  (delete origin comment C+k)
                trim trail CS+k 
                find match delimiter CS+b
                join lines C+j
                Move Up Current Line CS+up        
                CA enter (insert blank line up), CSA enter
                C pgup/down (next tab)
            macro
                delete blank line CAS+D (plug-in shortcut map)
                google search A+F2
                open file A+F5 (F6 new instance)
                    file_path   CAS+P
                    replace_space  CAS+S
                send editing file CAS+O
                print   C+P
                delete lines - C-L (clipboard), C-S-L
            scintilla
                C del, CS del, C bs, CS bs, C l (cut line), CS l (del line) 
                C t, change to copy line => original, CS t (copy line), C T(transpose with previous)
                C Home (jump to start), CS Home (jump to start and selection), C end, CS end
                C [, C ] paragraph down/up
                
        setting->preference->multi-editing
        
        delete blank lines         
            按ctrl+h，跳出搜索替换框，把查找模式定义为扩展（\n，\r…） 查找目标：\r\n\r\n  替换为：\r\n
            Textfx插件 TextFX Edit -> Delhiete Blank Lines
            ^ +$，替换为空              
                                   
        vertical block 區塊選取的功能     
        1. 先按住ALT鍵後，然後用滑鼠左鍵來拖曳要選取的範圍
        2. 同時按住ALT跟SHIFT鍵後, 用方向鍵來拉出要選取的範圍
        
        auto-complete
        settings -> preference -> auto-complete

        make file clickable
        e.g. file:///C:/Users/CCMA/Documents/Outlook%20Files
            SPACE    ->    %20
              !      ->    %21
              $      ->    %24
              '      ->    %27
              ;      ->    %3b
              [      ->    %5b
              ]      ->    %5d
              ^      ->    %5e
              `      ->    %60
              {      ->    %7b
              }      ->    %7d
              ~      ->    %7e
        
        plugin
            multiclipboard - ctrl shift V 
            explorer
            location navigate
    ;markdown;md
        markdown shortcut
        - tab , shift tab
        - This is [an example][id] reference-style link.
          [id]: http://www.kimo.com/  "Optional Title Here"
        - [myhtm](http://127.0.0.1/arm.html)
            C:\inetpub\wwwroot
        - #![img](htm\a.JPG)
    
    ;vs code
        function list - C S o
        TD  "program": "${workspaceFolder}/Debug/m0_test.elf",            
            "miDebuggerServerAddress": "C:\\Program Files\\GNU ARM Eclipse\\OpenOCD\\0.10.0-201709050644-dev\\bin\\openocd.exe",            
    
    
    ;sublime
        ?? how to know who calls class Flash() of flash/flash.py        

        Python PEP8 Autoformat is a Sublime Text plugin
            Use cmd+shift+P shortcut then Package Control: Install Package
            Look for Python PEP8 Autoformat and install it.
            Windows: ctrl+shift+r
            GNU/Linux: ctrl+shift+r

        - right click on sublime project, you can rebuild the CTAGS
        - sublime trace code, "alt -" back to original place, "F12" jump into definition
            jump into: C-t, C-t
            jump outof: C-t, C-b
        
        在Sublime中，安装插件之前我们需要添加Package Control,打开View——Show Console，输入以下命令：

        import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)

        [buffer indent/scroll](https://github.com/titoBouzout/BufferScroll/tree/st3)    

        ;plugin
            increment selection -> select multiple 0 and hit 'C-A-i', it will generate sequence order
            
            MarkdownEditing
            command + option + k 插入链接
            command + shift + k 插入图片
                ![img](htm/a.JPG)

            安装OmniMarkupPreviewer
            Command +Option +O: 在浏览器中预览
            Command+Option+X: 导出HTML
            Ctrl+Alt+C: HTML标记拷贝至剪贴板

            Hexviewer

            SublimeJEDI
                https://github.com/srusskih/SublimeJEDI
                with Sublime Package Control
                Open command pallet (default: ctrl+shift+p)
                Type package control install and select command Package Control: Install Package
                Type Jedi and select Jedi - Python autocompletion
                
                Go Definition           CTRL+SHIFT+G
                Find Related Names      ALT+SHIFT+F
                Jedi Show Calltip
                    Show calltip in status bar.
                    Exposed command is sublime_jedi_signature
        
        ;config
            Project: Edit
            "folders": [
              {
                 "file_exclude_patterns": ["*.test", "*.out"],
                 "folder_exclude_patterns": ["tmp"],
               ],
               "path": "/path/to/project/folder",
              }
            ],
            You can have multiple workspaces per project.
            
        ;shortcut
            C-p file,@,#   
                file@func  <- can be do as fuzzy
                If you want to go to the line 18 of a file called drunk_snake.py , you can type in drnksnk:18
            C-leftClick (select different positions, then edit all at a time)
            a word selected
                C-d (select next one by one), C-f (all)
            Expand Selection: ctrl+shift+space . It expands the selection in blocks, and expands more if you hit it more times until it selects the whole file.
            ctrl+k ctrl+v - paste history
            
            Ctrl + Shift + F    findall, where可以選<open folders>
            ALT + -   回上一步
            ALT + Shift + -   回下一步
            Ctrl + /	註解與移除註解
            Ctrl + Shift + /	區域註解
            Ctrl + Shift + V	貼上並符合縮排        
            Ctrl + Shift + T	還原最後關閉的分頁
            Ctrl + PgUp	換到上一個分頁
            Ctrl + PgDown	換到下一個分頁
            Ctrl + Tab	切換上一個分頁
            Alt + [NUM]	切換到第[NUM]個分頁
            Alt + Shift + (2, 3, 4)	垂直分割(2, 3, 4)個視窗
            Alt + Shift + 1	回覆到預設
            Alt + Shift + 5	水平垂直分割
            Alt + Shift + (8, 9)	水平分割(2, 3)個視窗
            Ctrl + X	刪除行
            Ctrl + Enter	插入下一行
            Ctrl + Shift + Enter	插入前一行
            Ctrl + Shift + ↑	往上移動一行
            Ctrl + Shift + ↓	往下移動一行
            Ctrl + L	選取整行
            Ctrl + D	選取單字（可重複選取相同的）
            Alt + F3	選取所有已選取的單字
            Ctrl + R	快速到達符號(function, class, etc...)
            Ctrl + ;	快速到達變數
            
            Ctrl + M	游標移動到括號內結束或開始的位置
            Ctrl + Shift + M	選取括號內的內容，繼續操作則會把括號一起選取
            Ctrl + Shift + K	刪除整行
            Ctrl + ]	向右縮排
            Ctrl + [	向左縮排
            Ctrl + Shift + F2	清除所有書籤
            Ctrl + F2	設定/取消書籤
            Ctrl + K + 0	展開所有摺疊程式碼
            Ctrl + Shift + [	先選取程式碼，操作後，摺疊程式碼
            Ctrl + Shift + ]	先選取程式碼，操作後，展開程式碼
            Ctrl + Shift + T	開啟最後關閉的分頁
            
        垂直選取 vertical,    鼠标右键 + Shift
        
        {
            "dictionary": "Packages/Language - English/en_US.dic",
            "font_size": 10,
            "ignored_packages":
            [
            ],
            "vintage_ctrl_keys": false,
            "vintage_start_in_command_mode": false
        }
                
    ;python
        ?? upgrade yotta - [lib>site_packages>serial pywinusb pip], miniterm, hex2bin, hex2dump, hexdiff, hexmerge
        
        s.split == getattr(s, "split")
        f.x = 10 也只是 setattr(f, "x", 10) 的语法糖
        在python中，变量的查找遵循LEGB原则：Local，Enclosing，Global以及Builtin。
        属性的查找首先它会找属性声明的那个对象，然后是创造出对象的类，然后是随着类的继承链往上找，直到object对象
        f.say() 和 Foo.say(f) 没有本质上的区别
        我们应该避免一种情况，那就是类属性和实例属性重名的问题
            class Person(object):
                population = 0
                def __init__(self):
                    self.population += 1
        Python 中的顺序类型，都是可迭代的（list, tuple, string）。其余包括 dict, set, file 也是可迭代的。对于用户自己实现的类型，如果提供了 __iter__() 或者 __getitem__() 方法，那么该类的对象也是可迭代的
        
        ;develop
            ;gif
                ??python dir() to know method, how to know variable?
                ??tkinter - when to use frame

                N: gif 89a/9x neeed support

                pip install ipdb
                pip install pillow
                pip install matplotlib
                http://libusb.info donwload dll and copy to c://windows/system32
                list can't assign if it doesn't exist, must append it first
                isp cmd is 4bytes, pack_id also 4bytes 
                isp firmware USBD_INTSTS_EP3, python dev.write(0x2, data)
                pyinstaller nu_isp_gif , not to import ipdb, io/struct(not sure)
                dev.read(0x81,buf,10000) <- update APROM need timeout
                
                set canvas and geometry size dynamic according to PhotoImage width() and height(), and it works
        
        ;pil
            把一整個目錄的 JPEG 檔轉換為 PNG 檔，那麼寫成一個程式檔會比較方便，例如：
            #!/usr/bin/env python
            from glob import glob
            from os.path import splitext
            import Image
            jpglist = glob( "python_imaging_pix/*.[jJ][pP][gG]" )
            for jpg in jpglist:
                im = Image.open(jpg)
                png = splitext(jpg)[0]+".png"
                im.save(png)
                print png        
                
        ;pyinstaller
            pip install https://github.com/pyinstaller/pyinstaller/ archive/develop.zip
            pyinstaller --onefile             
            http://pythonhosted.org/PyInstaller/
            usage: pyinstaller -F ./xxx.py (-F == --oneline)
            -c <- not show console, if you have UI
        ;yield (generator)                    
            def func():
                return 1
            def gen():
                yield 1
            print(type(func))   # <class 'function'>
            print(type(gen))    # <class 'function'>
            print(type(func())) # <class 'int'>
            print(type(gen()))  # <class 'generator'>

            def square():
                for x in range(4):
                    yield x ** 2
            square_gen = square()
            for x in square_gen:
                print(x)        #0,1,4,9
            
            解讀yield function
                在函数开始处，加入 result = list()；
                将每个 yield 表达式 yield expr 替换为 result.append(expr)；
                在函数末尾处，加入 return result。
        
        ;exit
            exit is a helper for the interactive shell - sys.exit is intended for use in programs.
            os._exit, which exits without calling cleanup handlers, flushing stdio buffers, etc. (normally only be used in the child process after a fork()).
        
        ;logging
            logging.basicConfig(filename="d.log", level=logging.INFO)
            logging.info("Singleton init")
        ;struct
            struct Header
            {
            unsigned short id;
            char[4] tag;
            unsigned int version;
            unsigned int count;
            }
            id, tag, version, count = struct.unpack("!H4s2I", s)
            ss = struct.pack("!H4s2I", id, tag, version, count);
            x	pad byte	no value	1
            c	char	string of length 1	1
            b	signedchar	integer	1
            B	unsignedchar	integer	1
            ?	_Bool	bool	1
            h	short	integer	2
            H	unsignedshort	integer	2
            i	int	integer	4
            I	unsignedint	integer or long	4
            l	long	integer	4
            L	unsignedlong	long	4
            q	longlong	long	8
            Q	unsignedlonglong	long	8
            f	float	float	4
            d	double	float	8
            s	char	string	1
            p	char	string	1
            P	void*	long
            注1.q和Q只在機器支持64位操作時有意思
            注2.每個格式前可以有一個數字，表示個數
            注3.s格式表示一定長度的字符串，4s表示長度為4的字符串，但是p表示的是pascal字符串
            注4.P用來轉換一個指針，其長度和機器字長相關
            注5.最後一個可以用來表示指針類型的，占4個字節
            calcsize(fmt) 計算給定的格式(fmt)占用多少字節的內存
        
        ;pypi
            c:\users\ccma\.pypirc
                [distutils]
                index-servers=
                    pypi

                [pypi]
                repository: https://upload.pypi.org/legacy/
                username: ccma1120
                password: ccma@nuvoton.com

            setup.py
                from distutils.core import setup
                setup(
                    name = 'nu_isp',
                    packages = ['nu_isp'],
                    scripts = [],
                    version = '0.3',
                    description = 'Nuvoton ISP',
                    author = 'jcliu,ccma',
                    author_email = 'ccma@nuvoton.com',
                    keywords = ['Nuvoton'],
                    classifiers = [],
                )
        
            python setup.py sdist upload -r pypi
        
        ;pyisp
TD  alias, strategy, remove pdb, uart detect auto delay time 0.1s, fill up the rest cmds, split command lines
            pip install pyserial
            python isp.py com26 c:\zbin\32.bin
            ord(x) - char x convert to dec 
            chr(x) - dec covert to char
        
        ;UNICODE
            UTF-8	EF BB BF	    indicate UTF8
            UTF-16 	FE FF	        indicate 大端序
            UTF-16	FF FE           indicate 小端序
            e.g. UTF-16 'abc' 
                fe ff 00 61 00 62 00 63  
                if you don't have BOM byte order mark, you can tag this string as UTF-16BE (big endian)
                UCS2 is an obsolete name, UTF-16 can represent more supplement character
            - npp encoding 選 big5, 再用 hex-viewer 轉會看到 utf-8, 應該是 hex-viewer 是將 big5 string 成功 decode後, 重新用 utf-8 encode.
            - encode 是以 str (unicode of python3) 為第一人稱, decode 是以 bytes 為第一人稱
              '元'.encode(big5) -> 元 **default is unicode** and encode to big5                  
              mystr = '元'
              print(mystr.encode('big5'))
              b'\xa4\xb8'
              print(mystr.encode('utf-8'))                  
              b'\xe5\x85\x83'
              print(mystr.encode('big5').decode('big5')) 可以解出 '元', 先encode為big5 bytes 
              print(mystr.encode('big5').decode('utf-8')) 會產生錯誤, 因為 big5 格式用 utf-8 檢查會有問題
             
            open() 的 "encoding = big5" 在 r 時代表讀用 big5 解釋, 在w 時表寫入時轉 big5
            - foo = open("utf2big.txt", 'w', encoding='big5') 只要 open 指定 encoding
              foo.write(content.decode('utf-8')) 儘管 decode 用 utf-8, 還是會以 big5 寫入 target document 
            - open("utf2big.txt", 'r', encoding='UTF-8') 指定 encoding utf-8, 不管有沒有 BOM 都可以讀到正確 string (BOM omitted)
              open("utf2big.txt", 'rb') 若 'rb' , 則忠實 byte by byte 讀出 BOM 的內容
            - encoded = b'\xe4\xbb\x8a\xe5\xa4\xa9\xe5\xa4\xa9\xe6\xb0\xa3\xe7\x9c\x9f\xe5\xa5\xbd'
              msg = encoded.decode('utf8')
              print msg  -- 今天天氣真好
            - msg = u'今天天氣真好'   -- python3 不用u, default is unicode
            - experiment path file:///C:/work/keil/TC8234/M2351_AP_NS%20(MKROM)/M2351_AP_NS0.bin/uni.py
                              file:///C:/weekly-report/note/htm/Make_clickable_Notepad++_Community.html    
            
        ;argparse
            EX1
                import argparse
                parser = argparse.ArgumentParser(description="calculate X to the power of Y")
                group = parser.add_mutually_exclusive_group()
                group.add_argument("-v", "--verbose", action="store_true")  #verbose is an attribute and can be access by args.verbose
                group.add_argument("-q", "--quiet", action="store_true")    #minus sign will assign to optional argument automatically
                parser.add_argument("x", type=int, help="the base")
                parser.add_argument("y", type=int, help="the exponent")
                args = parser.parse_args()
                answer = args.x**args.y
                if args.quiet:
                    print answer
                elif args.verbose:
                    print "{} to the power {} equals {}".format(args.x, args.y, answer)
                else:
                    print "{}^{} == {}".format(args.x, args.y, answer)        

                $ python prog.py 4 2
                    4^2 == 16
                $ python prog.py 4 2 -q
                    16
                $ python prog.py 4 2 -v
                    4 to the power 2 equals 16
                $ python prog.py 4 2 -vq
                    usage: prog.py [-h] [-v | -q] x y
                    prog.py: error: argument -q/--quiet: not allowed with argument -v/--verbose
                $ python nu_isp.py -h
                    usage: nu_isp.py [-h] [-v | -q] x y
                    calculate X to the power of Y
                    positional arguments:
                      x              the base
                      y              the exponent
                    optional arguments:
                      -h, --help     show this help message and exit
                      -v, --verbose
                      -q, --quiet
  
            EX2
                LEVELS = {
                    'debug': logging.DEBUG,
                    'info': logging.INFO,
                    'warning': logging.WARNING,
                    'error': logging.ERROR,
                    'critical': logging.CRITICAL
                }
                debug_levels = LEVELS.keys()
                supported_targets = pyOCD.target.TARGET.keys()
                def validate_target(value):
                    if value.lower() not in supported_targets:
                        raise InvalidArgumentError("invalid target option '{}'".format(value))
                    return value

                parser.add_argument("-d", "--debug", dest="debug_level", choices=debug_levels, default='info', help="Set the level of system logging output. Supported choices are: " + ", ".join(debug_levels), metavar="LEVEL")
                parser.add_argument("-t", "--target", dest="target_override", default=None, help="Override target to debug.", metavar="TARGET", type=validate_target)
                
                dest is var name e.g. args.debug_level
                
            
        ;module;import
            import sys
            sys.path.append("..")            
            import mod1  <- mod1 is at upper level dir 
            
            比如一个工程，它有两个目录modules和common_lib，如果modules目录的脚本想引用common_lib里的内容，
            通常我会使用sys.path.add(os.path.abspath("../modules"))
            
            sys.path.append(..) linux 沒用 win 有用, win 連 sys.path.append("../..") 都 work, 只是 print sys.path 沒看到 .. 的部份
            sys.path.append('c:\\xxx\\b.py')

            > import sys
            > print '\n'.join(sys.path)
                C:\yotta\python\lib
                C:\yotta\python\lib\site-packages
            
                Python 搜索模塊的路徑：
                1)、程序的主目錄
                2)、PTYHONPATH目錄（如果已經進行了設置）
                3)、標準連接庫目錄（一般在/usr/local/lib/python2.X/）
                4)、任何的.pth文件的內容（如果存在的話）.新功能，允許用戶把有效果的目錄添加到模塊搜索路徑中去
                .pth後綴的文本文件中一行一行的地列出目錄。
                這四個組建組合起來就變成了sys.path了

            import all function and class in fileA
                from fileA import *
                you can also do
                from fileA import classA
                from fileA import funcA
                import module                  #call 法是 module.func() 不能直接 call func()
                from package import module   #package 內一定要有一個 __init__.py, 否則 import 會失敗
                                             #上述寫法會把 module.py 所有 func() 都 import 進來, 並蓋掉本檔同名的 func()
                from test1 import *          #這個寫法可以直接 call test1 中的 func(), 但有趣的是, 若原檔也有 func() 竟然是原檔的           
                
                若不看import 單看 python 的 function, 同檔案中func 無法 overload, def a() then def a(n) , 後面一定要 call a(n)不然會error then要求 1 arg                

        ;object
            __class__ 
                class abstract1 (object):
                  def __init__(self):
                    if self.__class__ == abstract1: 
                      raise NotImplementedError("Interfaces can't be instantiated")
                What is the purpose of that? terry guess: abstract class abstract one
                if call a=abstract1() in __main__ directly, it will enter raise exception                 
                
                self.__class__ is a reference to the type of the current instance.

                For instances of abstract1, that'd be the abstract1 class itself, which is what you don't want with an abstract class. Abstract classes are only meant to be subclassed, not to create instances directly:

                >>> abstract1()
                Traceback (most recent call last):
                  File "<stdin>", line 1, in <module>
                  File "<stdin>", line 4, in __init__
                NotImplementedError: Interfaces can't be instantiated
                For an instance of a subclass of abstract1, self.__class__ would be a reference to the specific subclass:

                >>> class Foo(abstract1): pass
                ... 
                >>> f = Foo()
                >>> f.__class__
                <class '__main__.Foo'>
                >>> f.__class__ is Foo
                True
                Throwing an exception here is like using an assert statement elsewhere in your code, it protects you from making silly mistakes.

                Note that the pythonic way to test for the type of an instance is to use the type() function instead, together with an identity test with the is operator:

                class abstract1(object):
                    def __init__(self):
                        if type(self) is abstract1: 
                            raise NotImplementedError("Interfaces can't be instantiated")
                        
            __init__ and __call__
                The first is used to initialise newly created object, and receives arguments used to do that:

                class foo:
                    def __init__(self, a, b, c):
                        # ...

                x = foo(1, 2, 3) # __init__
                The second implements function call operator.

                class foo:
                    def __call__(self, a, b, c):
                        # ...

                x = foo()
                x(1, 2, 3) # __call__

            __repr__ __str__ 
            >>> repr(1.0 - 0.8)
                '0.19999999999999996'
                >>> str(1.0 - 0.8)
                '0.2'
                >>>
            雖然你也可以用 (1.0 - 0.8).__repr__()、(1.0 - 0.8).__str__() 來取得字串，不過在 
            Python 中，底線開頭暗示著你不要直接呼叫或使用，因此上面的示範中，使用 repr 及 str 函式來取得字串
            簡單來說，用 __repr__ 來傳回沒有岐義的（Unambigous）字串表示，用 __str__ 來傳回具可讀性的（Readable）字串表示
        
        "file:///C:/weekly-report/note/htm/Python 3 – Quick Reference Card.html"
        
        ;env 
            C:\yotta\python;C:\yotta\python\Scripts
            C:\tool\WinPython-32bit-3.6.1.1Qt5b2\python-3.6.1
            C:\tool\WinPython-32bit-3.6.1.1Qt5b2\python-3.6.1\Scripts;
                
            set PATH C:\tool\WinPython-32bit-3.6.1.1Qt5b2\python-3.6.1\Scripts
            and then you can use easy_install.exe, pip.exe..

                
        ;pip
            "Wheel" is a built, archive format that can greatly speed installation compared to building and installing from source archives
                
        ;control
            for loop with index
                for idx, val in enumerate(ints):
                print(idx, val)
            
        ;pdb;ipdb            
            python -m ipdb xx.py
            post-mortem  pdb.pm()
            
            import pdb
            pdb.set_trace()
            python xxx.py <- then it will break at that line

            pdb look inside python object 
            p self.__dict__
            p dir(self)
            p hex(var)
            
            help
            !<expr>
            run [args]
            a - args, current function received
            unt - run out of loop
            n - run over the func
            bt, (w)here - backtrace
            b line, c - cont to bkpt
            b(reak) [[filename:]lineno | function[, condition]]
                break 13 # Set breakpoint on line number 13
                break divide # Set breakpoint on divide function
                break divide, denominator == 0 # Set breakpoint in divide function only if denominator is 0
            
            w(here) - Print a stack trace            
            b - to read all bkpts
            tb - temporary break
            cl - to clear all bkpts
            disable/enable [bkpt number]
            ignore bp# [count] <- bp re-activated when the count becomes 0
            condition bpnumber [condition]
            commands [bpnumber]
                In commands mode the prompt is (com). To end the commands use end.
                (Pdb) commands 1
                (com) args
                (com) p "Inside divide()"
                (com) end
                We can also use commands like cont, next etc. But these commands will also act as end because these commands can lead us to next breakpoint which may have its own set of commands and then debugger will be confused about whose commands to run next.
                (Pdb) commands 1
                (com) silent
                (com) cont      <- not stop when encount bp, and not show bp-hit message this time
            jump - jump to and skip code
            l - start from 1 not 0
                        
            run
                $ python -m pdb script.py 10 5
                    (Pdb) !import sys
                    (Pdb) p sys.argv
                    ['script.py', '10', '5']
                (Pdb) run 30 40
                    (Pdb) !import sys
                    (Pdb) p sys.argv
                    ['script.py', '30', '40']
            
            alias
                (Pdb) alias squares [i**2 for i in xrange(%1)]
                (Pdb) squares 5
                [0, 1, 4, 9, 16]
                Here %1 is the argument that our alias expects(5 in the above example), if it expects more then we can use %2, %3 etc
                
                We can also create aliases using existing aliases
                (Pdb) alias squares_7 squares 7
            To run Python code in debugger we can use ! followed by the code we want to run.
                >>> !c=2 (w/o !, c becomes cont)
            
            ipbd for auto complete
            pp locals() and pp globals()
            enter to repeat last cmd
            multiple cmd in single line, use ;; as separator
        ;super()
                   +-----+
                   |  T  |
                   |a = 0|
                   +-----+
                 /         \
                /           \
            +-------+    +-------+
            |   A   |    |   B   |
            |       |    | a = 2 |
            +-------+    +-------+
                \           /
                 \         /
                   +-----+
                   |  C  |
                   +-----+
                      :
                      :    instantiation
                      c
            >>> class T(object):
            ...     a = 0
            >>> class A(T):
            ...     pass
            >>> class B(T):
            ...     a = 2
            >>> class C(A,B):
            ...     pass
            >>> c = C()
            
            >>> super(C,c).a
            2
            You may call A the superclass of C, but this is not a useful concept since the methods are resolved by looking at the classes in the MRO of C
            
        ;@property
            class Student(object):
                @property
                def score(self):
                    return self._score
                    
                @score.setter
                def score(self, value):
                    if not isinstance(value, int):
                        raise ValueError('score must be an integer!')
                    if value < 0 or value > 100:
                        raise ValueError('score must between 0 ~ 100!')
                    self._score = value
        
            >>> s = Student()
            >>> s.score = 9999
                Traceback (most recent call last):
            attribute can be modify without boundary, add this to refine that.
        
        ;variable
            ;global
                如果你要在别的函数里使用全局变量,只要在被调用全局变量函数的里事先用global声明一下:
                globvar = 0
                def set_globvar_to_one():
                    global globvar    # 需要用global修饰一下globvar
                    globvar = 1
                def print_globvar():
                    print globvar     # 如果要读globbar的值的话不需要用global修饰
                set_globvar_to_one()
                print_globvar()       # 输出 1

            ;nonlocal
                x = 10
                def outer():
                   x = 100         # 這是在 outer() 函式範圍的 x
                   def inner():
                       nonlocal x
                       x = 1000    # 改變的是 outer() 函式的 x
                   inner()
                   print(x)        # 顯示 1000
                outer()
                print(x)           # 顯示 10
                
        ;virtualenv
            purpose - 1. app1 use gglib_ver1, app2 use gglib_ver2. 
                      2. no access permission of site-packages
            $ virtualenv ENV
            $ cd ENV
            $ source bin/activate           
            在 Windows 環境中則改用：
            > \path\to\env\Scripts\activate.bat
            
            requirements.txt
                Step 1 Get the list of modules in the current virtualenv
                source /path/to/current/bin/activate
                pip freeze > requirements.txt
                
                Step 2 Create a new virtualenv. Either change into a suitable directory before executing the virtualenv command or give a full path.
                deactivate
                virtualenv -p python3 envname
                 
                Step 3 Install modules
                source envname/bin/activate
                pip install -r requirements.txt  

            Just use the --python (or short -p) option when creating your virtualenv instance to specify the Python executable you want to use, e.g.:
                virtualenv --python=/usr/bin/python2.6 <path/to/new/virtualenv/>
            For Python 3.3 or later
                python3 -m venv <myenvname>
            
        ;enum
            from enum import Enum

            Month = Enum('Month', (
                'Jan', 'Feb', 'Mar', 'Apr',
                'May', 'Jun', 'Jul', 'Aug',
                'Sep', 'Oct', 'Nov', 'Dec'    
            ))
                
        ;string            
            TypeError: 'str' object is not callable     <- you're defining that str = something else, masking the builtin definition of str()

            str <- can't be modified
            len(str) length
            if s0.find('$t') != -1:  #find $t in s0
            
        ;garbage collection
            >>> class Some:
            ...     def __del__(self):
            ...         print('__del__')
            >>> s = Some()
            >>> s = None
            __del__
            >>> s1 = Some()
            >>> s2 = s1
            >>> del s1
            >>> del s2
            __del__
        
        ;super
            class Base(object):
                def __init__(self):
                    print "Base created"
            class ChildA(Base):
                def __init__(self):
                    Base.__init__(self)
            class ChildB(Base):
                def __init__(self):
                    super(ChildB, self).__init__()
            print ChildA(),ChildB()
            super()的好处就是可以避免直接使用父类的名字.但是它主要用于多重继承
            注意在Python3.0里语法有所改变:你可以用super().__init__()替换super(ChildB, self).__init__()
            
        ;class
            
            
            __getattr__(): 在 attribute 不存在時才會被呼叫到。
            __getattribute__(): 不管 attribute 存不存在，都會先被呼叫到。如果有定義此 function 的話，得手動呼叫 __getattr__() 或是 raise AttributeError，否則就算有定義 __getattr__() 也不會被呼叫到
                class Chain(object):
                    def __init__(self, path=''):
                        self._path = path
                    def __getattr__(self, path):
                        return Chain('%s/%s' % (self._path, path))
                    def __str__(self):
                        return self._path
                    __repr__ = __str__

                >>> Chain().status.user.timeline.list
                /status/user/timeline/list
      
            class Some:
                def __new__(clz, isClzInstance):
                    print('__new__')
                    if isClzInstance:
                        print(object)
                        return object.__new__(clz)
                    else:
                        return None
                def __init__(self, isClzInstance):
                    print('__init__')
                    print(isClzInstance)
            Some(True)              #new->init->true, create object, then init object
            Some(False)             #false, create object only
            
        ;metaclass 
            "file:///C:/weekly-report/note/htm/Python-metaclass.html"
            file:///C:/weekly-report/note/htm/python-type-object-relation.html
            file:///C:/weekly-report/note/htm/python-type-object-relation2.html
            file:///C:/weekly-report/note/htm/python-object-class.html
            新式类 class A(object), 旧式类 class A()
        
        ;decorator
            "file:///C:/weekly-report/note/htm/Python-decorator.html"
            
            callback function 和 decorator 有何不同。 基本上，他們兩個完全是不同概念的東西。 callback function 是指 A function  呼叫 B  function 時，傳入 C function 作為參數。B function 在做一些事情後，可能會呼叫 C function。 C function 在這個情境下就是 callback function
            def demo_callback(callback);
                #do something if need
                callback()
                #do something if need
                
            而在 python 中的 decorator  是個語法糖衣。讓程式設計師，可以在不修改原本函數的內容下，為原本函數加上新的功能。實作上，就只是把建立一個新 function ，與原本 function 同名，把舊的 function 蓋掉
            def call_after(func):
                def wrapper(wrapped_func):
                    def inner_wrapper():
                        func()
                        wrapped_func()
                    return inner_wrapper
                return wrapper
             
            def update_counter():
                print 'update counter'
             
            @call_after(update_counter)
            def demo_func():
                print 'do something'
             
            demo_func()
            上面這個例子是，利用 decorator  來做到確保每次執行 demo_func 前，會先執行 update_counter。使用 decorator   可以在不修改原先 function 下，進行新功能。
            附帶一提， callback function 可以在 runtime 時決定，不過 decorator  卻是寫完 code 大概就知道會做那些事了
    
            decorator
            引入日志
            增加计时逻辑来检测性能
            给函数加入事务的能力
                单个Decorator，不带参数. (也可帶)
                def deco(func): 
                    def call_method(*args): 
                        print ("before call method" )
                        func(*args) 
                        print ("after call method" )
                    return call_method 

                @deco 
                def func(a,b): 
                    print ("in func" )
                    return a + b 
                    
                func(1,2)
                    before call method
                    in func
                    after call method

                    
                修饰类和修饰函数差不多，修饰类是把@decorator放在class上面，用以修改类的属性
                def func(self):
                    return "func"
                 
                def deco(kclass):
                    kclass.func = func
                    kclass.name = "Hello"
                    return kclass
                 
                @deco
                class test(object):
                    def __init__(self):
                        print "in init",self.name
                        print "call func: ",self.func()
                test()            

                相当于在 player里面定义了一个 is_persistent()的方法。
                在需要Persistent的地方加上@Persistent就行了，当然也可以在每个需要@Persistent的类里面重写这个方法，但是当对象多的时候，自己也不知道自己写了没有了
                def is_persistent(_self):
                    return False
                             
                def Persistent(klass):
                    """
                    类的decorator，用来修饰Entity的子类。如：
                    @Persistent
                    class player(Entity):
                        ...
                    这样的类才会被序列化到mongodb中
                    """
                    klass.is_persistent = is_persistent
                    return klass
                 
                @Persistent
                class player(object): #object is Entity above
                    pass
                    
                pp=player()
                print(pp.is_persistent())   #print false
            
        ;lambda param1, param2, ... : expression 只處理一個運算式, 其中的expression不能放assignment，也就是這一行指令不能放=等號
            lambda is anonymous function, below code test ok
            
            f = lambda x: x ** x
            print(f(1))
            print(f(2))
            
            def lambda_demo(n):
                return lambda x: x ** n + x * 2 + 1             
            i = 1
            f = lambda_demo(2)
            while i <= 10:
                print(f(i))
                i += 1
                
        ;operation
            ternary - a if test else b

        ;dir()
            print(dir())  to see how many symbol defined until now
            dir(builtins)

        ;recursive
            def recurse():
                recurse()
            In most programming environments, a program with infinite recursion does not really run forever. Python reports an error message when the maximum recursion depth is reached (1000)

        ;""";docstring
            A docstring is a string at the beginning of a function that explains the interface (“doc” is short for “documentation”). Here is an example:
                def polyline(t, n, length, angle):
                    """Draws n line segments with the given length and
                    angle (in degrees) between them.  t is a turtle.
                    """       
            
        ;misc
            python 大小寫是有差的, class/func 大小寫 sensible
                        
            symbolic link can't excute - python.exe symlink.py  <- fail
                            
            file:///C:/tool/WinPython-32bit-3.6.1.1Qt5b2/python-3.6.1/Doc/python361.chm
            
            file:///C:/work/python/npp_python_auto_complete
            
            ImportError Bad magic number in 
                solution; rm *.pyc
            MRO Method Resolution Order
            
            class 語句在跑 .py 時會每一個從上到下順序進入執行內容, def 不會
            
            shebang #!/usr/bin/env python3      <-python2.6 will do!!
            chmod 755 , 就不用 python ./test.py  而可以直接 ./test.py
            
                $ /usr/local/bin/python -V
                Python 2.6.4
                $ /usr/bin/python -V
                Python 2.5.1
                $ cat my_script.py 
                #!/usr/bin/env python
                import json
                print "hello, json"
                $ PATH=/usr/local/bin:/usr/bin
                $ ./my_script.py 
                hello, json
                $ PATH=/usr/bin:/usr/local/bin
                $ ./my_script.py 
                Traceback (most recent call last):
                  File "./my_script.py", line 2, in <module>
                    import json
                ImportError: No module named json
                The json module doesn't exist in Python 2.5.
                
                
            當你執行一支 .py 檔時，Python 會先看看有沒有這支 .py 檔的 .pyc 檔，如果有，而且 .py 檔的修改時間和 .pyc 檔一樣時，Python 就會讀 .pyc 檔
            執行 .py 檔並不一定會產生出 .pyc 檔，通常是被來做 import 的 .py 檔才會產生出 .pyc 檔

            word.upper()  A method call is called an invocation; in this case, we would say that we are invoking upper on the word
            >>> name = 'bob'
            >>> name.find('b', 1, 2)
            -1
            For example, in find(sub[, start[, end]])
            
            If the flow of execution gets to the end of a function and no return expression, the return value is None, which is not the absolute value of 0
            Once the program is working, you might want to remove some of the scaffolding or consolidate multiple statements into compound expressions
            scaffold of recursive function can add space(tab) into it, indent make recursive log more readable 

            do type checking, if input (1.5), factorial will become infinite
            def factorial (n):
                if not isinstance(n, int):
                    print 'Factorial is only defined for integers.'
                    return None
            def is_reverse(word1, word2):
                if len(word1) != len(word2):
                    return False        
            Any nonzero number is interpreted as “true.”
            if x < y:
            elif x > y:
            else:    

            >>> '   spacious   '.strip()
            'spacious'
            you can do .lstrip() and .rstrip()
            firstTwoChar = (cmd.strip())[0:2]
            
            Python 2 provides a built-in function called raw_input that gets input from the keyboard. In Python 3, it is called input. When this function is called, the program stops and waits for the user to type something. When the user presses Return or Enter, the program resumes and raw_input returns what the user typed as a string    
        
            If you have more than a few numeric arguments, it is easy to forget what they are, or what order they should be in. It is legal, and sometimes helpful, to include the names of the parameters in the argument list - polygon(bob, n=7, length=70), These are called keyword arguments because they include the parameter names as “keywords”
            
    
            只要定义类型的时候，实现__call__函数，这个类型就成为可调用的。换句话说，我们可以把这个类型的对象当作函数来使用，相当于 重载了括号运算符
            
            * and ** parameter, yield vs return, global var, nonlocal var
            
        ;usb ;pyusb
            linux
                https://github.com/walac/pyusb/
                下載 github，解壓縮以後，進入資料夾，輸入 sudo python setup install，就完成安裝了
                >>> import usb
                >>> dev = usb.core.find(idVendor=0x046d, idProduct=0xc016)
                >>> dev
                對照組
                sudo apt-get install libusb-1.0-0
                $ lsusb            
            windows
                pip install pyusb
                copy "C:\tool\libusb-win32-bin-1.2.6.0\bin\x86\libusb0.dll" and libusb0.sys to "C:\Windows\System32"
                and usb.core.find can find its libusb backend
            if install libusb and do experiment on nu-tiny, has to remove bulk driver and delete driver file first, re-plug a libusb-win32 device will display
            
            for self.intf in self.cfg:
                print "intf= " + str(self.intf)  

        ;try except else finally raise
            file:///C:/weekly-report/note/htm/python-try-raise.html
            try:
                 try:
                     raise EOFError('XD')
                 except EOFError as e:
                     print(e.args)
                     raise IndexError('Orz')
            except IndexError as e:
                 print(e.args)
                 print(e.__context__.args)      #如果你在except中raise某個例外，則原except所比對到的例外，無論有無使用raise from，e.__context__.args 都會show 'XD'
                 print(e.__cause__.args)        #如果你在except中raise某個例外，則原except所比對到的例外，要使用raise from，e.__cause__.args 才會show 'XD', 不然會error
            output ---
            ('XD',)
            ('Orz',)
            ('XD',)
            ('XD',)

        ;with as, __enter__()與__exit__() 
            file:///C:/weekly-report/note/htm/python-with-as.html
            class FileReader:
                def __init__(self, filename):
                    self.filename = filename
                
                def __enter__(self):
                    self.file = open(self.filename, 'r', encoding='UTF-8')
                    return self.file
                
                def __exit__(self, type, msg, traceback):
                    if type:
                        print(msg)       # 作你的例外處理
                    self.file.close()
                    return False

            接下來你就可以在FileReader物件上使用with as語句。例如：
            with FileReader('demo.py') as file:
                for line in file:
                    print(line, end='')
            
        ;metaclass
            class FooChild(Foo):
                bar = True
            等同於
            FooChild = type('FooChild', (Foo,),{'bar':True})

            当你写如下代码时 
            class Foo(Bar):
                pass
            Python做了如下的操作：            Foo中有__metaclass__这个属性吗？如果是，Python会在内存中通过__metaclass__创建一个名字为Foo的类对象（我说的是类对象，请紧跟我的思路）。如果Python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。
            现在的问题就是，你可以在__metaclass__中放置些什么代码呢？答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以。
            
        ;shutil
            from shutil import copytree, ignore_patterns
            copytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*'))    
            at my win7 NB
                copytree(r"../../work/present/", r"../../work/present/pytest/", ignore=ignore_patterns('*.txt'))
            copytree implement
                def copytree(src, dst, symlinks=False):
                    names = os.listdir(src)
                    os.makedirs(dst)
                    errors = []
                    for name in names:
                        srcname = os.path.join(src, name)
                        dstname = os.path.join(dst, name)
                        try:
                            if symlinks and os.path.islink(srcname):
                                linkto = os.readlink(srcname)
                                os.symlink(linkto, dstname)
                            elif os.path.isdir(srcname):
                                copytree(srcname, dstname, symlinks)
                            else:
                                copy2(srcname, dstname)
                            # XXX What about devices, sockets etc.?
                        except OSError as why:
                            errors.append((srcname, dstname, str(why)))
                        # catch the Error from the recursive copytree so that we can
                        # continue with other files
                        except Error as err:
                            errors.extend(err.args[0])
                    try:
                        copystat(src, dst)
                    except OSError as why:
                        # can't copy file access times on Windows
                        if why.winerror is None:
                            errors.extend((src, dst, str(why)))
                    if errors:
                        raise Error(errors)            
        ;os
            os.chdir("newdir")  mkdir() getcwd() rmdir() 
            
            fn = os.path.join(os.path.dirname(__file__), 'my_file')
            os.path.dirname <- python a/b/c.txt  (only split __file__, will get a/b)
            os.path.abspath(os.path.dirname(__file__)) <- will call os.getcwd()
            os.path.abspath()与os.path.realpath()的区别
            两者都返回指定文件的绝对路径， 而如果这个文件是你为其他文件创建的一个软链接(symlink), os.path.realpath()还可以获取其真实的路径，而os.path.abspath()不可
            
            demo
            "file:///C:/tool/WinPython-32bit-3.6.1.1Qt5b2/python-3.6.1/Lib/ccma/py-os.py"
            
            os.system("命令加参数") 把命令和参数传递给你系统的shell中. e.g. os.system("命令 < 出入文件 | 另一个命令 > 输出文件")
            stream = os.popen("命令和参数")

            Processes (module subprocess):
            res = subprocess.call(["hostname","-f"], stderr=subprocess.DEVNULL)
            res = subprocess.call("ps axu | grep ^root", shell=True)
            output = subprocess.check_output(["mycmd", "myarg"],universal_newlines=True)
            Module os:

            os.pathsep    os.sep          os.pardir       os.curdir       os.linesep
            os.startfile("index.html")
            os.popen("ps ax").readlines()
            os.listdir("/usr/local")              # ['bin', 'etc', ...]
            os.glob("*.txt")                      # ['test.txt', 'out.txt', ...]
            Module os.path:

            os.path.split("/usr/bin/go.sh")       # ('/usr/bin', 'go.sh')
            os.path.join("/usr/bin", "go.sh")     # '/usr/bin/go.sh'
            os.path.splitext("/usr/bin/go.sh")    # ('/usr/bin/go', '.sh')
            os.path.abspath("../bin/go.sh")       # '/usr/bin/go.sh'
            os.path.isfile("go.sh")
            
        ;filter()
            >>> def fn(x):
            ...     return x if x > 5 else None
            ...
            >>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
            >>> b = filter(fn, a)
            >>> b
            [6, 7, 8, 9]    
        ;map()
            >>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
            >>> def fn(x):
            ...     return x*2
            >>> c = map(fn, a)
            >>> print(list(c))
            [2, 4, 6, 8, 10, 12, 14, 16, 18]  
            
            print([fn(i) for i in my_list])  #等同 map(fn,my_list)            
            
            >>> def abc(a, b, c):
            ...     return a*10000 + b*100 + c
            ... 
            >>> list1 = [11,22,33]
            >>> list2 = [44,55,66]
            >>> list3 = [77,88,99]
            >>> map(abc,list1,list2,list3)
            [114477, 225588, 336699]
                        
        ;reduce () 前二項先做, 結果跟第三項做, 結果跟第四項做, and so on
            >>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
            >>> def fn(x, y):
            ...     return x+y
            >>> d = reduce(fn, a)
            >>> d
            45            
            
        ;regular expression

            exercise
                # print 'test'  -> logging.debug('test')                
                    (# print )(.*)$             <- sublime find option remember to select regular expression
                    logging.debug("$2")
                    
                howto 開頭一堆空白或tab不想動到, 想加東西在前面 e.g.    UART   ->   o.UART 
                    search  ====   (^[^\w]*)
                    replace ====   $1o.
                
                刪掉非 # 開頭的行
                    ^[^#].*$
        
            file:///C:/weekly-report/note/htm/regex.html

            ;escape
                consider 'abc\'de', r'\\path' <- r 還是會讓 \ 跳脫它緊接著字元對 interpreter 的特別意含 (e.g. \t, \n, '), 但加了 r, \ 會留在 print result, 沒加r, eascape \會消失
                    \newline	Ignored
                    \\	Backslash (\)
                    \'	Single quote (')
                    \"	Double quote (")
                    \a	ASCII Bell (BEL)
                    \b	ASCII Backspace (BS)
                    \f	ASCII Formfeed (FF)
                    \n	ASCII Linefeed (LF)
                    \r	ASCII Carriage Return (CR)
                    \t	ASCII Horizontal Tab (TAB)
                    \v	ASCII Vertical Tab (VT)
                    \ooo	ASCII character with octal value ooo
                    \xhh...	ASCII character with hex value hh..

                >>> print 'hit\ber'
                hier
                >>> print 'hit\\ber'
                hit\ber
                >>> print r'\'     
                error
                >>> print r'\''                
                \'                 
                >>> print r'\n'    
                \n                 
                >>> print r'nn'nn'            
                error
                >>> print '\n'                 
                                               
                >>> print '\\n'            
                \n                         

                python \只有當接有意義的字元才會特別處理, 反之否
                >>> print '\gg' 
                \gg             
                >>> print '\ng' 
                                
                g               
                
                re.search("\n", "\n")  # 找得到(語言自己判斷為特殊字元)
                re.search("\\n", "\n")  # 也找得到(regex 函式庫判斷特殊字元)
                re.search("\\n", "\\n")  # 找不到
                建議 re.search(r"\n", "\n")  # 找得到, 全交由 regex 函式庫判斷            

                不是每個語言像perl 都將「/」當成分隔符號，好比說 Python , 所以 re 也能支援不跳脫「/」的情況。
                re.match(r"<Name>([^<]+)<\/Name>", "<Name>飛天雞</Name>") # 抓得到~
                re.match(r"<Name>([^<]+)</Name>", "<Name>飛天雞</Name>")  # 也抓得到~            

                text = """
                雞腿
                雞心
                雞肝
                """
                re.search("雞.*", text)  # '雞腿'
                雖然前面有說過「.」代表任意字元，但其實不包含換行，當碰到第一個換行時，就會停止抓取，所以最後只抓到「雞腿」就停止了。如果要讓「.」也能代表換行字元，就要加上「DOTALL」這個 flag 才行。

                text = """
                雞腿
                雞心
                雞肝
                """
                re.search("雞.*", text, re.DOTALL)  # '雞腿\n雞心\n雞肝\n'
                「^」和「$」的情況比較像反過來，前面說過兩者分別代表文章的「開頭」和「結尾」，但有時我們可能會希望這個「開頭」或「結尾」代表的是「行」的開頭和結尾，這時可以加上「MULTILINE」這個 flag。

                text = """
                雞腿
                雞心
                雞肝
                """

                re.findall("^雞.*", text)  # []
                re.findall("^雞.*", text, re.MULTILINE)  # ['雞腿', '雞心', '雞肝']
                
                
            Here’s a complete list of the metacharacters (元字符)
            . ^ $ * + ? { [ ] \ | ( )
            
            if re.search(r'\s\$t\s|\s\$d', s0) is not None: 
                | 二邊接字串就是或字串
                [] 裡面是一個一個字元的或
            \d [0-9] \D [^0-9] \s[ \t\n\r\f\v] \w [a-zA-Z0-9_]
            
            match()	决定 RE 是否在字符串刚开始的位置匹配
            search()	扫描字符串，找到这个 RE 匹配的位置
            findall()	找到 RE 匹配的所有子串，并把它们作为一个列表返回
            finditer()	找到 RE 匹配的所有子串，并把它们作为一个迭代器返回

            group()	返回被 RE 匹配的字符串
            start()	返回匹配开始的位置
            end()	返回匹配结束的位置
            span()	返回一个元组包含匹配 (开始,结束) 的位置

            >>> import re
            >>> p = re.compile('[a-z]+')
            >>> m = p.match( 'tempo')
            >>> print m
            >>> p = re.compile('\d+')
            >>> p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')
            >>> iterator = p.finditer('12 drummers drumming, 11 ... 10 ...')
            >>> iterator
            >>> for match in iterator:
            >>>     print match.span()

            考虑表达式 a[bcd]*b
            重复是“贪婪的”
            .*    <- greedy,  .*?  <- non-greedy
            e.g. <strong>小雞</strong>, re.search("<.+>", text) VS re.search("<.+?>", text) # <strong>          
            re.search("<[^>]+>", text)  # <strong>
            
            Python 的 raw 字符串表示；在字符串前加个 "r" 反斜杠就不会被任何特殊方式处理
            p = re.compile(r'\bclass\b')
            if raw then means word boarder, else it's backspace
            print ('\b'+'class'+'\b'+'e')  <- result is clase
            print ('abc\bf')  <- get 'abcf'

            p=re.compile(r'(a)(bc)\1') <- can match 'abca'  group0=abca group1=a group2=bc

            DOTALL, S	使 . 匹配包括换行在内的所有字符
            IGNORECASE, I	使匹配对大小写不敏感
            LOCALE, L	做本地化识别（locale-aware）匹配
            MULTILINE, M	多行匹配，影响 ^ 和 $
            VERBOSE, X	能够使用 REs 的 verbose 状态，使之被组织得更清晰易懂

            split()	将字符串在 RE 匹配的地方分片并生成一个列表，
            sub()	找到 RE 匹配的所有子串，并将其用一个不同的字符串替换
            subn()	与 sub() 相同，但返回新的字符串和替换次数
 
            re.sub用于替换字符串中的匹配项。下面一个例子将字符串中的空格 ' ' 替换成 '-' :
            print re.sub(r'/s+', '-', text)
            re.sub的函数原型为：re.sub(pattern, repl, string, count)
            其中第二个函数是替换后的字符串；本例中为'-'
            第四个参数指替换个数。默认为0，表示每个匹配项都替换。
            还允许使用函数对匹配项的替换进行复杂的处理。如：re.sub(r'/s', lambda m: '[' + m.group(0) + ']', text, 0)；将字符串中的空格' '替换为'[ ]'。
     
            pattern_option->repeart->anchor->set_argument
            
            npp, replace blank line, left bottom select 'regular expression', and replace "^\s\n" with ""
            
            [\b]	比對退位字元（Backspace character）
            \b	比對英文字的邊界，例如空格      例如 /\bn\w/ 可以比對 “noonday” 中的 ‘no’ ;
            /\wy\b/ 可比對 “possibly yesterday.” 中的 ‘ly’
            \B	比對非「英文字的邊界」	例如, /\w\Bn/ 可以比對 “noonday” 中的 ‘on’ ,
            另外 /y\B\w/ 可以比對 “possibly yesterday.” 中的 ‘ye’

            {n}	比對前一個字元 n 次，n 為一個正整數
            {n,}	比對前一個字元至少 n 次，n 為一個正整數
            {n,m}	比對前一個字元至少 n 次，至多 m 次，m、n 均為正整數

            (x)	比對 x 並將符合的部分存入一個變數	/(a*) and (b*)/ 可比對 “aaa and bb” 中的 “aaa” 和 “bb”，並將這兩個比對得到的字串設定至變數, use \1  \2  取用

            /a.{5}b/	a 和 b中間夾五個（非換行）字元        

            [^\^]	不含 “^” 之字串，例如 “xyz”, “abc”	“xy^”, “a^bc”
            /^xy/	以 “xy” 開始的字串，例如 “xyz”, “xyab”（若要比對 ^，請使用 \^）	“axy”, “bxy”
            /xy$/	以 “xy” 結尾的字串，例如 “axy”, “abxy”以 “xy” 結尾的字串，例如 “axy”, “abxy” （若要比對 $，請使用 \$）	“xya”, “xyb”

            \d	數字	[0-9]
            \D	非數字	[^0-9]
            \w	數字、字母、底線	[a-zA-Z0-9_]
            \W	非 \w	[^a-zA-Z0-9_]
            \s	空白字元	[ \r\t\n\f]
            \S	非空白字元	[^ \r\t\n\f]

            
        ;tkinter
            Tkinter._test()
            
            http://www.kaiching.org/2012/12/Python-Basic-Concept-of-GUI.html

            ImportError: No module named '_tkinter'
            sudo apt-get install python3-tk

            import Tkinter as tk
            win=tk.Tk()
            root.title("My First Tk GUI")
            root.resizable(0,0)
            root.mainloop()

            def keydown(e):
                print 'down', e.char            
            root.bind("<KeyPress>", keydown)
            root.bind('<Return>', self.parse)

            layout
                pack, grid, place
                
                w.pack(fill=X)  橫向填滿
                padx (水平外邊距) pady, ipadx (水平內邊距), ipady
                
                var = IntVar(root)
                Label(root, text="dd").grid(row=0,column=0)
                OptionMenu(root, var, 8, 9, 10).grid(row=0,column=1)            
            
            class
                Button	按鈕 Canvas	畫布 Checkbutton	複選方塊 Entry	文字欄位 Frame	視窗 Label	文字標籤 LabelFrame	標籤視窗 ListBox	選取清單
                Menu	選單 MenuButton	選單元件 Message	對話視窗 OptionMenu	下拉式選單 PanedWindow	面板 RadioButton	單選方塊 Scale	控制桿
                Scrollbar	捲軸 SpinBox	旋鈕 Text	文字方塊 image, bitmap, Toplevel	頂層視窗元件            
            ttk 推出的新元件 :
                Combobox, Notebook, Progressbar, Separator, Sizegrip, Treeview
            
            
        https://sourcemaking.com/design_patterns/strategy/python/1    
        
        ;delay;time
            import time
            
            s = time.time()
            time.sleep(0.1)     # delays for 0.1 seconds
            e = time.time()
            print "{} time".format(e - s)
            
        ;except
            try:
            except Exception:       <- without Exception keyword, all except will be trapped, and even C-c can't leave the program
                print('into')

            >>> def catch():
            ...     try:
            ...         asd()
            ...     except Exception as e:
            ...         print e.message, e.args
            ... 
            >>> catch()
            global name 'asd' is not defined ("global name 'asd' is not defined",)
            But it doesn't catch BaseException or the system-exiting exceptions SystemExit, KeyboardInterrupt and GeneratorExit:

            >>> def catch():
            ...     try:
            ...         raise BaseException()
            ...     except Exception as e:
            ...         print e.message, e.args
            ... 
            >>> catch()
            Traceback (most recent call last):
              File "<stdin>", line 1, in <module>
              File "<stdin>", line 3, in catch
            BaseException                
        
        ;list 
            len,min,max
            in, not in,  
            count(d) <- d appear how many times, 
            a.extend(b) <- a is actually change, a+b has the same concatnation, but a is not changed
            a.index(x) <- output item x
            remove：移除列表中某個值的第一個匹配項. a.remove('me')
            list.pop <- pop out last item.  list.pop(1) <- pop out item 1
            list.append("hello") <- append to the last.    list.insert(1, 'nihao') <- insert into item1 position
            reversed函數：反轉一個對象，返回一個疊代器(iterator). x for x in reversed(range(10)) 也可以用 range(10)[::-1]反轉
            [x*2 for x in L if x>2] 
            
        ;dict (map in other lang)
            >>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
            >>> d['Michael']
            95
            
            和list比较，dict有以下几个特点：
                查找和插入的速度极快，不会随着key的增加而增加；
                需要占用大量的内存，内存浪费多。
            而list相反：
                查找和插入的时间随着元素的增加而增加；
                占用空间小，浪费内存很少。
            
            dict的key必须是不可变对象, 这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）
            
        ;tuple, 指向固定不能改, 被指的東西若是list, 此list可改. tuple can't use append, insert, pop
            a=(1)  <- a calculated as 1
            a=(1,) <- a is tuple 1
            x = 1,2,3
            x = (1,2,3)
            x[1]
            a,b,c = x
        ;staticmethod classmethod
            class A(object):  
                bar = 1  
                def foo(self):  
                    print 'foo'  
             
                @staticmethod  
                def static_foo():  
                    print 'static_foo'  
                    print A.bar  
             
                @classmethod  
                def class_foo(cls):  
                    print 'class_foo'  
                    print cls.bar  
                    cls().foo()  
          
            A.static_foo()  
            A.class_foo()
        
        ;file manipulate                                
            TypeError: a bytes-like object is required, not 'str'    <- if you open 'wb', you can't write string in it
            
            seek(offset[, from])  0,start. 1,current. 2,end
            tell() how many bytes from the beginning
            
            f.readline 是在該行任意位置呼叫所得均同? ans - no, 若從下一行 seek(-3,1), 只能讀出從 cursor 到行尾, -3 大概就最後一個char
            
            with open(filename,'rb') as f:
                while True:
                    line=f.readline()
                    if not line: break
                    process(line)

            #get numbers of string of file 
                def file_len(fname):
                    with open(fname) as f:
                        for i, l in enumerate(f):
                            pass
                    return i + 1        
            
            #check if certain string in file
                if 'blabla' in open('example.txt').read():
                    print "true"        

                #!/usr/bin/env python3
                import mmap
                with open('example.txt', 'rb', 0) as file, \
                     mmap.mmap(file.fileno(), 0, access=mmap.ACCESS_READ) as s:
                    if s.find(b'blabla') != -1:
                        print('true')
                You could also use regular expressions on mmap e.g., case-insensitive search: if re.search(br'(?i)blabla', s):
            
        ;print
            file:///C:/weekly-report/note/htm/printf_PyFormat.html

            p ",".join('%04x' %i for i in trans_buf)
            
            print array in hex value
                print "".join([hex(i) for i in buf])
            
            print " ".join(["{:02d}".format(x) for x in l])
            
            print hex value
                print (hex(gg.value))
                print ("%x" % gg.value)

            print r'C:\\nowhere'
            print(1, end=' ') # default value of `end` is '\n'
            python2 print "ya", means no new line

            print (o.__str__(), "strcat")  you can't print(o + "strcat") directly, but you can print(o)
                    
            C://weekly-report/note/htm/python-read-file.html
            
            return 'Account({0}, {1}, {2})'.format(self.name, self.number, self.balance)

            
        ;threading
            method1 - inherit Thread
                from threading import current_thread
                import  threading, time
                count =  0    
                class  Counter(threading.Thread):    
                    def  __init__( self , lock, threadName):    
                        '''@summary:初始化對象。   
                           
                        @param lock: 瑣對象。   
                        @param threadName: 線程名稱。   
                        '''    
                        super(Counter,  self ).__init__(name = threadName)   #注意：一定要顯式的調用父類的初始化函數.  
                        self.lock = lock    
                        
                    def  run( self ):    
                        '''@summary:重寫父類run方法，在線程啟動後執行該方法內的代碼. '''    
                        global  count    
                        self.lock.acquire()    
                        for  i  in  range(1000):    
                            print current_thread()
                            print current_thread().name
                            count = count +  1    
                        self .lock.release()    
                lock = threading.Lock()    
                for  i  in  range(5):     
                    Counter(lock,  "thread-"  + str(i)).start()   # Open 5 隻線程  
                time.sleep( 2 )    #確保線程都執行完畢    
                print("Count={0}!".format(count)) 
            
            method2 - threading class
                import  threading, time
                count =  0    
                lock = threading.Lock()    
                def  doAdd():    
                    '' '''@summary:將全局變量count逐一的增加10000。   
                    '''    
                    global  count, lock    
                    lock.acquire()    
                    for  i  in  range( 1000 ):    
                        count = count +  1    
                    lock.release()  
                      
                for  i  in  range( 5 ):    
                    threading.Thread(target = doAdd, args = (), name =  'thread-'  + str(i)).start()    
                time.sleep( 2 )    #確保線程都執行完畢    
                print("Count={0}!".format(count))  
            ;semaphore
                # coding=UTF-8  
                import threading, time, random   
                  
                count=0  
                round=3  
                lock=threading.Lock()  
                sem=threading.Semaphore(5)  # Code block can be executed by at most 5 threads concurrently  
                def codeBlock(thd, i):  
                    global count  
                    lock.acquire()  
                    count+=1  
                    print "\t[Info] {0}/{1} entering({2})...".format(thd.name, i, count)      
                    lock.release()      
                    time.sleep(random.randrange(2,10))  
                    lock.acquire()  
                    count-=1  
                    print "\t[Info] {0}/{1} exit({2})...".format(thd.name, i, count)      
                    lock.release()  
                      
                class Guest(threading.Thread):  
                    def  __init__( self , lock, threadName):  
                        super(Guest,  self ).__init__(name = threadName)   #注意：一定要顯式的調用父類的初始化函數.    
                        self.lock = lock  
                          
                    def  run( self ):      
                        '''@summary:重寫父類run方法，在線程啟動後執行該方法內的代碼. '''      
                        global  count                  
                        for  i  in  range(round):  
                            self.lock.acquire()      
                            codeBlock(self, i)      
                            self.lock.release()  
                        print "\t[Info] {0} Bye!".format(self.name)  
                          
                for  i  in  range(10):       
                    Guest(sem,  "thread-"+ str(i)).start()   # Open 10 隻線程  
                執行結果部分 log 如下: 
                ...
                [Info] thread-3/0 entering(4)...
                [Info] thread-4/0 entering(5)...
                [Info] thread-4/0 exit(4)...
                [Info] thread-4/1 entering(5)...
                [Info] thread-0/0 exit(4)...
                [Info] thread-0/1 entering(5)...
                [Info] thread-1/0 exit(4)...
                [Info] thread-7/0 entering(5)...
                [Info] thread-4/1 exit(4)...
                [Info] thread-8/0 entering(5)...
                
        ;tail recursion how to parallel? - 
            normal recursive
                def recsum(x):
                    if x == 1:
                        return x
                    else:
                        return x + recsum(x - 1)

                recsum(5)
                5 + recsum(4)
                5 + (4 + recsum(3))
                5 + (4 + (3 + recsum(2)))
                5 + (4 + (3 + (2 + recsum(1))))
                5 + (4 + (3 + (2 + 1)))
                15

            tail recursive -- it can save stack usage, not necessary to keep current stack after getting into next call
                def tailrecsum(x, running_total=0):
                    if x == 0:
                        return running_total
                    else:
                        return tailrecsum(x - 1, running_total + x)
                
                tailrecsum(5, 0)
                tailrecsum(4, 5)
                tailrecsum(3, 9)
                tailrecsum(2, 12)
                tailrecsum(1, 14)
                tailrecsum(0, 15)
                15                
                
    ;;github
        opennuvoton https://github.com/OpenNuvoton/NUC100BSP.git

    ;;git (recap HEAD, master, maint first)
TD git server authentication         
            github ssh
            server - /etc/ssh/ssh_host_*
            client - ~/.ssh/known-hosts        
            
        git bisect
            git blame -L 12,22 simplegit.rb
            首先你執行 git bisect start 啟動，然後你用 git bisect bad 來告訴系統當前的提交已經有問題了。然後你必須告訴 bisect 已知的最後一次正常狀態是哪次提交，使用 git bisect good [good_commit]
            當你完成之後，你應該執行 git bisect reset 來重設你的 HEAD 到你開始前的地方
            
            $ git bisect start HEAD v1.0
            $ git bisect run test-error.sh
            這樣會自動地在每一個 checked-out 提交裡執行 test-error.sh 直到 Git 找出第一個破損的提交

        git conflict format
            git merge lala
                Auto-merging aa.txt
                CONFLICT (add/add): Merge conflict in aa.txt
                Automatic merge failed; fix conflicts and then commit the result.

                <<<<<<< HEAD
                llllllllllllllllllll
                =======
                adfaf
                >>>>>>> master
        git diff
            @@ -1,7 +1,7 @@
            -1,7分为三个部分，-表示第一个文件,即f1.txt，1表示下面输出的从第1行开始，7表示下面输出的到第7行结束
            
        git log --oneline --graph --decorate
        git log shows the current HEAD and its ancestry.
        git reflog doesn't traverse HEAD's ancestry at all. The reflog is an ordered list of the commits that HEAD has pointed to
        
        .git 
            git log information is from .git folder
            
            .git\config 
            [remote "origin"]

        newline
            行尾eol (end of line) 表示法
                檔案格式        十六進位        控制字元 (Control character)        跳脫字元 (Escape character)     ASCII 名稱
                Linux           0x0a            ^J                                  \n                              LF
                DOS/Windows     0x0d 0x0a       ^M ^J                               \r \n                           CR LF        

            if you see Warning - LF will be replaced by CRLF in git -the file will have its original line endings
            This usually happens when you are on Windows and either core.autocrlf is set to true, or the .gitattributes contains directives to perform line ending normalizations.              
            work like --  CRLF->LF to 'git server' LF->CRLF to win7
            However, if you somehow create a file with just LFs in your working directory, here is what will happen
                When committing, git will "convert" the LFs to LFs, i.e. do nothing
                When checking out, git will convert the LFs to CRLFs
            
        url = https://github.com/doggy8088/sandbox-empty2.git

        fetch = +refs/heads/*:refs/remotes/origin/*
        如果你把 fetch 的 refspec 修改成以下這樣，那麼除了 master 以外的遠端分支，就不會被下載了！：

        fetch = +refs/heads/master:refs/remotes/origin/master

        git push --set-upstream origin FixForCRLF 的同時，會在 .git\config 設定檔增加以下內容：
        [branch "FixForCRLF"]
        remote = origin
        merge = refs/heads/FixForCRLF

        我們在一開始執行 **git clone https://github.com/doggy8088/frontend-tools.git** 的時候，Git 就會預設幫我們建立好 master 分支的對應關係
        [branch "master"]
        remote = origin
        merge = refs/heads/master

        * git push origin master
        * git reset --hard HEAD
        * git reset --hard ORIG_HEAD
                
        reset towards stage
        checkout toward stage and working
        diff towards working
        
            Warning: you are leaving 1 commit behind, not connected to any of your branches:
              bfaa5be tmp
            If you want to keep it by creating a new branch, this may be a good time to do so with:
              git branch <new-branch-name> bfaa5be
        
        Q; git add . 加太多garbage to stage
        A; git reset .
        Q; move HEAD and master back one version and (--hard) to update WD 
        A; git reset HEAD~ --hard 
        
        config
            git config --global --add merge.tool kdiff3
            git config --global --add mergetool.kdiff3.path "C:/Program Files/KDiff3/kdiff3.exe"
            git config --global --add mergetool.kdiff3.trustExitCode false

            git config --global --add diff.guitool kdiff3
            git config --global --add difftool.kdiff3.path "C:/Program Files/KDiff3/kdiff3.exe"
            git config --global --add difftool.kdiff3.trustExitCode false

        branch
            git checkout -b newbranch
        tag
            git tag -a v1.4 -m 'my version 1.4'
            git push --all --tags
            git checkout tag
            git tag -d                          //delete tag
            git show tagname 可看到指定標籤的資料與對應的commit
        rm
            直接在檔案系統中刪除一個檔案，這只是從「工作目錄」中刪除而已，並沒有更新到索引檔
            git rm filename 的時候，除了更新索引檔之外，連工作目錄下的檔案也會一併被刪除
            git rm --cached a.txt 你只想刪除索引檔中的該檔，又要保留工作目錄下的實體檔案
        git 圖解
            git reset -- files          git commit 
            git checkout -- files       git add files            
        checkout    
            move HEAD only (master no move), update WD/stage
                if filename, HEAD not move and copy to WD/stage                        
            git checkout HEAD~ -- a.txt            
        diff
            git diff --cached (HEAD vs stage)                
            git diff HEAD     (HEAD vs WD)
            git diff          (stage vs WD)
        commit 
            (detached) commit only HEAD move, need git checkout -b name來建立一個新的分支
            (not detached) commit HEAD/master move toghter
            git commit --amend  (new HEAD/master share same parent with original HEAD/master)
        reset                   (both HEAD/master will move)
            git reset           (update stage) (default HEAD, and like checkout )
            git reset --soft    (no update WD/stage)
            git reset --hard    (update WD/stage)
        merge (merge, cherrypick 都是在原 HEAD/master 分支下指令, 在原分支往後推一版. rebase 是 HEAD/master 整組跳到 rebase 指定那個 branch 後面)
            git merge master : fast-forward - HEAD/maint move to master 
            git merge other  : master, other and their co-parent 3way merge - HEAD/master merge other and step become new HEAD/master
            git cherry-pick 123456: (HEAD/master one step forward)
            git rebase master: from co-parent to HEAD/topic move after master, master no move, HEAD/topic moved
                在master分支上进行rebase topic 一般来说应该是不对的, 應該如上述在 HEAD/topic 上執行 git rebase master
                永远不要在已经发布到公共仓库的提交对象上做rebase操作，而master分支默认就是公共仓库
                在git push之前，先git fetch，再git rebase origin/master, 维持树的整洁 (git merge 出來的 node會有二個 parents)
            git rebase --onto master 123456: same as above, but not from co-parent but 123456
        stash 
            git stash (save)
            git stash list
            git stash pop stash@{1}         //no stash@{1} will do 0
            git stash drop
        clean working dir
            git clean -n  = see what will be cleaned
            git clean -f -d = force to clean dir and files
            git checkout -- nuicpgui.py
            git reset --hard                ;this will forced clean stage and working dir to HEAD             
            
        config
            list tree file
            git config -l
            git config --global --unset https.proxy      
            git config --global https.proxy https://10.1.8.42:80    <- old proxy
            git config --global https.proxy https://nthcwgcls:8080  <- 20180520 proxy updated                                                    
            git config --global http.proxy http://ccma:passwd@nthcwgcls:8080   <- this is tke key
            
            git config --global --add merge.tool kdiff3
            git config --global --add mergetool.kdiff3.path "C:/Program Files/KDiff3/kdiff3.exe"
            git config --global --add mergetool.kdiff3.trustExitCode false
            git config --global --add diff.guitool kdiff3
            git config --global --add difftool.kdiff3.path "C:/Program Files/KDiff3/kdiff3.exe"
            git config --global --add difftool.kdiff3.trustExitCode false
        
        remote (master, origin/master original master of remote-repo)
            open "git bash"
            git fetch
            git remote -v
            git remote add origin https://github.com/ppony/python.git
            git push origin master                 (push -u if empty project on github)
            
            $ git push origin serverfix
            equal to 
            $ git push origin refs/heads/serverfix:refs/heads/serverfix
            $ git push origin serverfix:serverfix
            
            將 local serverfix 推到遠端 awesomebranch
            $ git push origin serverfix:awesomebranch

            $ git fetch origin
                * [new branch]      serverfix    -> origin/serverfix
                不會有新 serverfix 分支，是無法移動的 origin/serverfix 指標
            遠端分支的內容合併到目前分支，可以執行 git merge origin/serverfix
            想要一份自己的 serverfix 來開發
            Branch serverfix set up to track remote branch serverfix from origin.
            Switched to a new branch 'serverfix'            
            $ git checkout -b serverfix origin/serverfix            
            $ git checkout --track origin/serverfix   <- alternate method
            $ git checkout -b sf origin/serverfix     <- 可取不同名
            從遠端分支 checkout 出來的本地分支，稱為追蹤分支 (tracking branch)。git push，git pull 都是apply到遠端相對分支
            
            delete remote branch
                git push [遠端名] :[分支名]

            1. git fetch             这将更新git remote 中所有的远程repo 所包含分支的最新commit-id, 将其记录到.git/FETCH_HEAD文件中
            2. git fetch remote_repo          这将更新名称为remote_repo 的远程repo上的所有branch的最新commit-id，将其记录。 
            3. git fetch remote_repo remote_branch_name         这将这将更新名称为remote_repo 的远程repo上的分支： remote_branch_name
            4. git fetch remote_repo remote_branch_name:local_branch_name       这将这将更新名称为remote_repo 的远程repo上的分支： remote_branch_name ，并在本地创建local_branch_name 本地分支保存远端分支的所有数据。
            
        misc
            Q; checkout branch/checkout tag/reset to check working dir unstashed files  A; all this three has nothing to do with unstashed files
            
            git add -u 則可以僅將「更新」或「刪除」的檔案變更寫入到「索引檔」中
            show HEAD
            git rev-parse HEAD
            git show-ref --head  <<remember this will do
            cat .git/HEAD
                    ref: refs/heads/terry
            cat .git/refs/heads/terry

            git branch -a                
            git reflog (if HEAD is detached, you can find it back)

            git hash-object 'file name' 
                list blob hash
            git cat-file -p master
                list tree ids
            git cat-file -p 'tree id'
            
            SHA1
                查看文件的SHA1值，用命令
                git hash-object file
                查看SHA1值对应的对象的内容，也可用命令
                git show <SHA1>
                查看commits，可用命令
                git log --pretty=oneline
                这会给出commit的历史记录。每行行首显示了每次提交的SHA1值。然后用

                git show <SHA1>
                显示commit的内容。

                查看每次commit指向的tree，用命令（如对commit 5ca6fc）
                git rev-parse 5ca6fc^{tree}
                会显示5ca6fc指向的tree的SHA1。如果想进一步查看tree的内容，用命力

                git show 5ca6fc^{tree}
                或者

                git cat-file -p 5ca6fc^{tree}
                后者输出形如

                100644 blob 76018072e09c5d31c8c6e3113b8aa0fe625195ca    file1
                100644 blob 5716ca5987cbf97d6bb54920bea6adde242d87e6    file2
                100644 blob 10e2d16377371e6436ba3779e62381fdaf8fcfbf    file3
                040000 tree edf40c2308b255c4aebc34aa9cce134131778a14    src
                可以看出，这个tree包含三个blob和一个子tree。

                查看tag，可用
                git tag
                列出所有的tag。对于某个tag “v1”，用命令

                git rev-parse v1
                查看tag的SHA1值
            
        sudo apt install gitk
        gitk --all

        ssh - push remote with keyin username and password
            ssh-keygen
                have to key in password for id_rsa key
                clip < ~/.ssh/id_rsa.pub
                paste public key on github                
            eval `ssh-agent -s`
            ssh-add ~/.ssh/id_rsa
            ssh -T git@github.com            
        
        nuvoton
            http://hcrdgit4/#/q/status:open        setting -> SSH Public Keys
             
            git clone ssh://ccma@hcrdgit4:29418/M2351/bsp.git M2351_BSP
            git pull
            
    ;;unix
        
        ;vcom
            /dev/ttyUSB0
            
        run python program deadlock. ps -aux | grep python can see that process. close the terminal window can delete that process together.
        
        ~/.wine/dosdevices/c:
        wine uninstaller
        sudo apt-get install winetricks
        sudo lsusb -> to know pid
        
        win7 - set | grep PATH, need grep with color, awk to format print 
        set & share 環境變數 for multi terminal 
        system programming   
        制作路徑變數方便切路徑, cd $libnano

        ;awk
            awk '條件類型1{動作1} 條件類型2{動作2} ...' filename
            awk 主要是處理『每一行的欄位內的資料』，而預設的『欄位的分隔符號為 "空白鍵" 或 "[tab]鍵" 

            $0 代表『一整列資料』的意思, $1 第一欄data, as so forth
            NF	每一行 ($0) 擁有的欄位總數
            NR	目前 awk 所處理的是『第幾行』資料
            FS	目前的分隔字元，預設是空白鍵

            [dmtsai@study ~]$ last -n 5 <==僅取出前五行
            dmtsai   pts/0     192.168.1.100   Tue Jul 14 17:32   still logged in            
            [dmtsai@study ~]$ last -n 5 | awk '{print $1 "\t" $3}'
            dmtsai  192.168.1.100

            echo "a b c d" | awk '{print $2}' # 印出 b
            echo "a b c d" | awk -F' ' '{print $2}' # 印出 b, -F: 依照一個空白分隔切割字串
TD not work in Cmder            echo "a b c d" | awk '{for (i=2; i <= NF; i++) {printf $i" "} printf "\n"}' # 印出 b c d
            echo "a b c d" | awk '{ print substr($0, index($0, " ") + 1); }'
            echo "a b c d" | awk '{ $1=""; print $0 }'

            [dmtsai@study ~]$ last -n 5| awk '{print $1 "\t lines: " NR "\t columns: " NF}'
            dmtsai   lines: 1        columns: 10
            dmtsai   lines: 2        columns: 10

            [dmtsai@study ~]$ cat /etc/passwd | awk 'BEGIN {FS=":"} $3 < 10 {print $1 "\t " $3}'
            root     0
            bin      1

            Name    1st     2nd     3th
            VBird   23000   24000   25000
            DMTsai  21000   20000   23000

            [dmtsai@study ~]$ cat pay.txt | \
            > awk 'NR==1{printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total" }
            > NR>=2{total = $2 + $3 + $4
            > printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'
                  Name        1st        2nd        3th      Total
                 VBird      23000      24000      25000   72000.00
                DMTsai      21000      20000      23000   64000.00            
        ;dd
            建立一個大檔案：
            dd if=/dev/zero of=/root/dd_10mb_file bs=1M count=10
            dd if=/dev/sda of=mbr bs=512 count=1
        
        solved
            lshw

            set -x

            $ type set
            set is a special shell builtin
            Since set is a shell builtin, it is documented in the documentation of your shell.

            sudo apt install autoconf

            find . -name config.cache | sed -n 3p
                under newlib dir / how to vim that file directly? 
                vim can't edit the input pipe file name directly
            vim $(find . -name config.cache | sed -n 3p)
                can do in this way

            grep xxx -r * | nl

            94  /home/cm/work/newlib-nano-1.0_/libgloss/arm/syscalls.c:_sbrk (int incr)        
            grep _sbrk -riw ~/work/newlib-nano-1.0_/ | sed -n 94p | awk 'BEGIN {FS=":"} {print $1}'
            /home/cm/work/newlib-nano-1.0_/libgloss/arm/syscalls.c


            build
            reent , stdio
            cm@cm-X555LD:~/work/newlib-nano-1.0_/libgloss/libnosys$ gcc -c *.c -I../../newlib/libc/include/sys -I../../newlib/libc/include/

            ld *.o ../reent/*.o ../../../libgloss/libnosys/*.o -o a.out


            ubuntu chinese language support


            ssh-keygen





            sudo apt install screen

            ctrl+a d
            screen -r 
            screen -ls

            cm@cm-X555LD:~/work/newlib-cygwin2$ gcc -I newlib/libc/include -I newlib/libc/machine/arm -dM -E -P newlib/libc/sys/arm/syscalls.c
                #define __GNUCLIKE_BUILTIN_NEXT_ARG 1
                #define __SSP_STRONG__ 3

            -MM Like -M but do not mention header files that are found in system header directories
            -gcc -M -MM a.c
            a.o: a.c b.h


            ;cp
                backup files and folder structure
                    find . -name '*.mp3' -type f -exec cp --parent {} ../test/ \;

                cp --parents a/b/c existing_dir
                    /tmp $ mkdir foo
                    /tmp $ mkdir foo/foo
                    /tmp $ touch foo/foo/foo.txt
                    /tmp $ mkdir bar
                    /tmp $ cp --parents foo/foo/foo.txt bar
                    /tmp $ ls bar/foo/foo
                    foo.txt            
            
            copy a set of .txt files, need the directory structure to stay intact, ignore files except those ending in .txt
            cd /top/level/to/copy
            find . -name '*.txt' | cpio -pdm /path/to/destdir
            (-updm for overwrite destination content.)        
        
            &	        Run the command in the background               % long_cmd &
            Ctrl-z	    Stop the foreground process	                    [Ctrl-z] Stopped
            kill	    Kill a process	                                % kill %2
            jobs	    List background processes	                    % jobs [1] - Stopped vi [2] - big_job &
            bg	        Restart a stopped background process            % bg [2] big_job &
            fg	        Bring a background process to the foreground    % fg %1
            
            setenv
            getenv
            unsetenv
            environ <- build in variable, point to all environ variable
            /etc/profile, ~/.bash_profile, /etc/bashrc, ~/.bashrc


            $ nmap github.com -p http,git
            $ nc github.com 9418 < /dev/null; echo $?  #1 is blocked
            $ curl  http://github.com:9418  #7 is blocked
            git config --global url."https://".insteadOf git://
            
            http://wpad.<suffix>/wpad.dat
            PROXY <host:port>; <- proxy information in the bottom

            netstat -ban
            netstat -ntu | awk ‘{print $5}’ | cut -d: -f1 | sort | uniq -c | sort -n  計算每一個 ip 在主機上建立的連線數量
            netstat -anp |grep ‘tcp\|udp’ | awk ‘{print $5}’ | cut -d: -f1 | sort | uniq -c | sort -n 列出從 TCP 或 UDP 連線到主機的 ip 的數量

            echo ABCDE | od -A n --width=1 -v -t x1
    
            diff -u <(seq -w 16) <(seq -w 16 | grep -Ev '^(02|03|14|15)$')
            @@ -1,6 +1,4 @@
            func1 as hunk header, use -p option
            @@ -4,7 +4,6 @@ func1() {

            tr [:lower:] [:upper]
            tr abcd ABCD
            tr a-z A-Z
            tr '{}' '()' < input > output
            echo "this is for test" | tr -s [:space:] '\t'
            echo "the geek" | tr -d 't'
            tr -d [:digit:]
            tr -cd [:digit:]  -- only left numbers
            tr -s '\n' '' < file
            

            Use Ctrl + Left and Ctrl + Right to move between the various parts of line

            clip < c:/Users/CCMA/.ssh/id_rsa.pub
            cd – 	cd 減號；切換目錄到前一個目錄
            ls -F 	附加檔案類型，目錄附加/，執行檔附加`*
            locate 檔案 	搜尋符合的檔案或目錄；必須先用updatedb建立檔名索引。
            locate -b ‘\name’列出名為name的檔案，沒加反斜線的話也會列出部份符合的檔案
            which 執行檔名 	列出執行檔名所在路徑
            Ctrl+L 	清除螢幕，同clear命令
            Esc + . 	顯示上一命令的引數、修改後執行
            Ctrl+A 	游標移回開頭位置
            Ctrl+E 	游標移回最後位置
            Ctrl+U 	剪下游標前方所有文字並複製到暫存剪貼簿
            Ctrl+K 	剪下游標後方所有文字並複製到暫存剪貼簿
            Ctrl+Y 	由暫存剪貼簿貼上Ctrl+U與Ctrl+K剪下的文字
            Ctrl+W 	刪除游標前方的單字(Word)
            Ctrl+Shift+C 	複製標示區的文字到剪貼簿
            Ctrl+Shift+V 	貼上剪貼簿文字到Terminal裡
            標示、滑鼠中鈕 	先用左鈕拖拉選取需要的文字後移動游標到新位置按中鈕
            （兩鈕滑鼠則是同時按左右鈕），標示文字會被複製到新位置
            w 	顯示上線用戶清單
            whoami 	顯示目前用戶名
            uname -a 	顯示系統核心資訊
            cat /proc/cpuinfo 	顯示CPU資訊
            cat /proc/meminfo 	顯示記憶體資訊
            df -h 	Disk Free，顯示磁碟空間資訊
            du 	Directory Usage，顯示目錄的磁碟用量
            free 	顯示記憶體與Swap區的用量

            history | grep sudo\ a*

            print match string and follow-up lines - 印出 g3 相關前後5行 grep -A5 -B5
            grep exact match - grep -w 'word'
            ARMGCCPATH=`pwd`
            echo $ARMGCCPATH 
            /usr/lib/gcc/arm-none-eabi/6.2.1

            find result filter
            find / -name "arm_cmse.h" 2>/dev/null
            find / -name "arm_cmse.h" 2>&1 | grep -v "Permission denied"

            ls -tl --time-style=full-iso
            
            『var="lang is $LANG"』則『echo $var』可得『lang is zh_TW.UTF-8』
            『var='lang is $LANG'』則『echo $var』可得『lang is $LANG』
            變數與變數內容以一個等號『=』來連結，如下所示： 
            『myname=VBird』
            等號兩邊不能直接接空白字元，如下所示為錯誤： 
            『myname = VBird』或『myname=VBird Tsai』
            可用跳脫字元『 \ 』將特殊符號(如 [Enter], $, \, 空白字元, '等)變成一般字元，如：
            『myname=VBird\ Tsai』

            [dmtsai@study ~]$ work="/cluster/server/work/taiwan_2015/003/"
            [dmtsai@study ~]$ cd $work

            [dmtsai@study ~]$ cd /lib/modules/`uname -r`/kernel
       
            indent -st -i2 test.c <- -st means write file, -i2 means indent format
            
            ;bash create directory recursively
                mkdir -p dir/dir    (-p means parent)
            
        ;ubuntu 16.04
            1. package 'vim'has no installation candidate
                sudo apt-get update 
                sudo apt-get upgrade
            2. brightness-controller
            3. install vim
                sudo apt-get update
                sudo apt-get install vim
            4. add environment PATH
                /etc/enviroment 
                source /etc/environment

            ctags
            在source code的最外層目錄輸入指令
            $ ctags -R *
            vim中輸入以下指令來載入對應的tag
            :set tags=/home/sway/src/tags
            
            lspci -nnk
                Broadcom Corporation BCM43142 802.11b/g/n [14e4:4365] (rev 01)
            sudo apt-get install bcmwl-kernel-source

            sudo apt-get install texi2html
            sudo apt install texlive-binaries     

            gnu arm toolchain
            sudo add-apt-repository ppa:team-gcc-arm-embedded/ppa
            sudo apt-get update
            sudo apt-get install gcc-arm-embedded
            sudo apt-get remove gcc-arm-none-eabi

            4  sudo add-apt-repository ppa:apandada1/brightness-controller
            5  sudo apt-get update
            6  sudo apt-get install brightness-controller

           28  sudo app-get exuberant-ctags
           29  sudo apt-get exuberant-ctags
           30  sudo apt-get install exuberant-ctags
           
           sudo apt install indent
           
           install sublime, install jvm, install eclipse CDT

        wireless
            ifconfig -- 用來開啟/關閉介面卡
            iwconfig -- 用設定無線的 SSID, key
            iwlist -- 用來搜尋周圍 AP
            dhcpcd -- 經由 dhcp 得到 ip

            首先，先找出你的無線網卡是哪個名字
            ifconfig -a

            找到介面的名字後，若是沒有打開，就把它打開
            ifconfig wlan0 up

            接著，設定無線網卡的 SSID (在 linux 世界都叫它 ESSID)
            iwconfig wlan0 essid <essid>

            還有設定無線網卡的金鑰
            iwconfig wlan0 key <key>

            最後，設定 ip，若是使用 dhcp，使用指令如下
            dhcpcd wlan0

            指定 ip 則是使用下例指令
            ifconfig wlan0 192.168.1.2
            網路匣道設定
            route add default 192.168.1.1


        teamviewer
            sudo apt-get install libjpeg62
            wget http://download.teamviewer.com/download/teamviewer_i386.deb
            sudo dpkg -i --force-depends teamviewer_i386.deb
            sudo apt-get install -f
            teamviewer --daemon start
            teamviewer
            
        ;;;vim  
            TD vim detect tag, and delete lines with tags
            TD tabnew
            
            refresh vim content
            alias alert
            delete bracket line automatic - 自己用 C 搞定
                For selective deletion of certain lines sed is the best tool. To print all of file EXCEPT section between WORD1 and WORD2 (2 regular expressions), use
                $ sed '/WORD1/,/WORD2/d' input.txt > output.txt

                #!/bin/bash
                # ALL HTML FILES
                FILES="*.html"
                # for loop read each file
                for f in $FILES
                do
                INF="$f"
                OUTF="$f.out.tmp"
                # replace javascript
                sed '/<script type="text\/javascript"/,/<\/script>/d' $INF > $OUTF
                /bin/cp $OUTF $INF
                /bin/rm -f $OUTF
                done
            ctags
                set tags=tags;/
                In case you get here and, like me, are puzzled by tags;/, the ;/ suffix directs vim to do an upward search from the directory 
                containing tags up to the stop directory, in this case /. If you want to use your home directory as the stop-directory, 
                use set tags+=tags;~ or set tags+=tags;$HOME. Or you could use the top directory of your project tree as the stop directory. 
                (See :help file-searching to understand the semi-colon.) Note also that searching for the tags file will be affected by autochdir. 
                I use in my .vimrc set tags=./tags,./TAGS,tags;~,TAGS;~
                                       
                set tags=./tags,tags;$HOME
                set this in ~/.vimrc, tell vim to look for tags file, from current dir up to $HOME
                
            solved 
                set nobackup       #no backup files
                set nowritebackup  #only in case you don't want a backup file while editing
                set noswapfile     #no swap files
            
                indent - crtl+V, jj, >>
                
                folding
                zo	將游標所在處的折疊打開。open。
                zc	將游標所在處已打開的內容再度折疊起來。close。
                zr	將全文的所有折疊依層次通通打開。reduce。
                zm	將全文已打開的折疊依層次通通再折疊起來。more。
                zR	作用和 zr 同，但會打開含巢狀折疊（折疊中又還有折疊）的所有折疊。
                zM	作用和 zm 同，但對於巢狀折疊亦有作用。
                zi	這是個切換，是折疊與不折疊指令間的切換。
                zn	打開全文的所有折疊。fold none。
                zN	這是 zn 的相對指令，回復所有的折疊。
                那這個 zn 和 zR 不是都一樣嗎？不是的，zR 的作用於 foldlevel 這個設定項，是控制折疊的層次，而 zn 則是作用於 foldenable 這個設定項，他是不管層次的，只有全關或全開
                
                :mkview
                :loadview

                pure vi problem 
                set .vimrc 
                set nocompatible
                set backspace=2

                vim -b binaryfile
                %!xxd 
                %!xxd -r

                set dispaly=uhex
                'ga'    - show hex value
                set nowrap
                'g C-g' - display word position
                '100go' - go to character 100

                gf  open in the same window ("goto file")
        
                to delete all lines containing "profile"
                :g/profile/d
                :g!/profile/d  <- to delete all lines NOT containing "profile"                
                :v/error\|warn\|fail/d  <- v == g!, delete all lines except those that contain "error" or "warn" or "fail" 

                :%s/foo/bar/gc
                :%3,10s/foo/bar/gc
                :s/\<term\>/replace/gc
                :'a,'bs/foo/bar/g
                :.,+2s/foo/bar/g	
                :.,$s/foo/bar/g
                :g/^baz/s/foo/bar/g

                :set ic(ignorecase 的??) 忽略大小?
                :set noic(noignorecase 的??) 不忽略大小?
                /\CWord 分大小的查找
                /\cword 不分大小的查找
                :set ai
                :set aw     <- auto save after writing
                :opt
                :mkv[imrc]  <- save into .vimrc
                
                :sp filename for a horizontal split
                :vsp filename or :vs filename for a vertical split
                Ctrl+W, S (upper case) for horizontal splitting
                Ctrl+W, v (lower case) for vertical splitting
                Ctrl+W, Q to close one
                Ctrl+W, Ctrl+W to switch between windows
                
                vim -p file1.txt file2.txt
                C-pgup, C-pgdn to switch tab
                
                vim history
                q:
                :set li<up>
                :set lines=75
            
                exact match word - /\<your_exact_word\>
                用VI寫程式時，常常要到shell中執行Make，這樣exit--edit反覆，很麻煩。

                VI中職行shell command有兩種方法：
                一是只執行一個command:
                 : ! 命令
                另一個是跳到shell，直到用exit回來:
                 : shell

                在要mark的位置，command : m{a-zA-Z}
                (直接輸入command，不用 : 符號和進入edit (insert) mode).
                所以可以mark 26+26 個。
                要到某一個mark : 用
                 `{a-zA-Z}
                連續兩個 ` 會到剛剛mark的位置。

                .要列出所有marks:
                 :marks
                 
                delete marks
                delm a-z0-9

                列出目前所有開啟的file:
                files

                跳到下一個edit的file
                Ctrl - ^
                多檔編輯時，每一個file是一個buffer，buffer的command都是以 b 開頭的：
                :bn  編輯下一個開啟的buffer(file)
                :bp  編輯上一個
                :bd  刪除這一個
                :b{數字} 編輯第N個              

                刪除從游標開始後的word - dw
                刪除從游標開始後至結尾 - d$


        ;;;newlib 
            Newlib-nano cuts some features that were added after C89, which are believed to be rarely used in MCU programming. By limiting the format converter to the C89 standard, format string processing code in printf is greatly reduced. By removing the iov buffering, all IO function sizes are again significantly reduced. Removal of wide char support in non-wide char function further squeezes string IO logic. Newlib-nano also extensively uses the weak symbol technique to exclude features that are rarely used in normal MCU programs. For example, referencing floating point IO and atexit as weak functions dramatically cuts the size of printf() and exit().

            Newlib-nano also re-implements memory allocation functions, to replace the original ones that have overall better performance but with lots of complex logic which increases code size. The so called nano-allocator uses simple and native algorithms to handle allocation, de-allocation, and defragmentation. It works effectively when the total memory that can be allocated is small. More importantly, it is only about one sixth of the original size.        
        
            newlib?? volatile pointer?        
            what's this mean? M32(0x3001FFF0) = 0xe7fee7ff;
                branch to 0xE7FF and stay in 0xE7FE
                0x3001FFF0 E7FF     B 0x3001FFF2
                0x3001FFF2 E7FE     B 0x3001FFF2
            $ ./configure --target=arm-none-eabi --enable-newlib-nano-malloc --enable-newlib-reent-small --enable-newlib-nano-formatted-io --disable-newlib-multithread --disable-newlib-supplied-syscalls
            newlib build problem modification
                Error: lo register required
                C:\git\newlib-2.5.0\newlib\libc\sys\arm\crt0.S Error: lo register required
                C:\git\newlib-2.5.0\newlib\libc\sys\arm\trap.S  @SUB     ip, sp, ip      @ extra stack required for function
            * gitm2351 bsp tz enable DEBUG_ENABLE_SEMIHOST __attribute__((weak)) weak symbol hardfault process fail
            * GCC share library/ dynamic linking --static .so,  practice debug with --static
            why KEIL MicroLib no need HEAP for printf??
            #pragma message
            gdb arrary ub[20]. p ub 為何和 p &ub 不同? printf %x &ub 卻和 ub 相同?
            can retarget _write, but not weak symbol of readelf -s?
            #define errno (*__errno())
            UNIX 或 LINUX 系統程式，Advanced Programing in UNIX Environment。如果想寫網路程式，我們用的是unix network programing。函式庫的書我是直接跟 GNU 買的，就是 GNU C Library Application Fundamentals, GNU C Library System & Network Application.        
            how malloc work on GCC? 羅習五
            _reent - libc/include/sys/reent.h strct _reent{ union struct {}_reent}
            __STDC__ of gcc        
            note        
                有什麼工具可以 disassemble 一小段機械碼
                    直接在 keil 跑在run, 再改ram value, 看 disassembly window 的指令
                    echo "0: e7ff" | xxd -r > disbin1
                    arm-elf-objdump -D -b binary -marm disbin1

                arm-none-eabi-objcopy -O binary xxx.elf xxx.bin 

                check version
                arm-none-eabi-gcc -v
                make -v
                
                GCC inline assembler
                C:\weekly report\note\htm\ARM GCC Inline Assembler Cookbook.html

                --defsym end=__HeapBase -DDEBUG_PORT=UART0_NS
                
                Replacing symbolic names of C functions
                extern long Calc(void) asm ("CALCULATE");
                
                arm v8m project copy to ubuntu and build

                CC=arm-none-eabi-gcc AR=arm-none-eabi-ar ./configure cross_compiling=yes --host=arm-unknown-none

                newlib/Makefile:   
                -O0 -g3 -mcpu=cortex-m0 -D__SINGLE_THREAD__

                unix2dos

                usr/share/arm-gcc-embedded/samples <- try this first

                arm-none-eabi-gcc -g3 -O0 main.c retarget.c ../../startup/startup_ARMCM0.S -mthumb -mcpu=cortex-m0 -L../../ldscripts -T gcc.ld -L. -lc -o retarget-CM0.axf

                diff -cw testdiff1 testdiff2

                echo 'main(){}' | gcc -E -v -
                #include <...> search starts here:
                 /usr/lib/gcc/x86_64-linux-gnu/5/include
                 /usr/local/include
                 /usr/lib/gcc/x86_64-linux-gnu/5/include-fixed
                 /usr/include/x86_64-linux-gnu
                 /usr/include

                newlib libc/include/sys/reent.h
                if defined(__DYNAMIC_REENT__) && !defined(__SINGLE_THREAD__)   

                libc/sys/arm/syscalls.c
                int     _read           _PARAMS ((int, char *, int)) __attribute__((weak));
                int     _swiread        _PARAMS ((int, char *, int)) __attribute__((weak));
            c Language study
                NVCZ flag forget 
                strtok(string, tok)連續2次, 再 strtok(NULL, tok) 就不能正常 output 後面的 token
                tok "--" 和 "-" 好像都一樣
                ctags will fail on _DEFUN? jump to strange position and not it's definition.
                * ctag, cscope  - _DEFUN  
                gprofile
                fscanf - can we decide delimiter and what's the default?
            ;gnu;gcc
            
                arm-none-eabi-objcopy -O ihex "m23_test.elf"  "m23_test.hex"
                arm-none-eabi-objcopy -O binary -j .text "m23_test.elf"  "m23_test.bin"
                              
                source path
                arm-none-eabi-readelf --debug-dump=str tz_gcc.elf

                read .rodata
                arm-none-eabi-readelf -p .rodata main.o

                keil combined source code to elf for debugging set breakpoint
                若是 disassembly and c 對照看, elf file 的 dwarf format 己有 (objdump -S 可得), 沒左欄 source code 也帶得出 main.c, dwarf 似乎也含有檔案路徑, 可以自己找到c source

                        samples-retarget project printf(hello) printf _vfprintf_r __swsetup_r __smakebuf_r _istty_r - _isatty - do_AngelSWI (SVC 0xAB)
                use built-in lib-nano.a         main iprintf __sinit __sfp __sfmoreglue _malloc_r _sbrk_r   
                                                                     std.isra.0 
                                                             _vfprintf_r __swsetup_r __smakebuf_r __swhatbuf_r _fstat_r 
                                                                                                  _malloc_r
                                                                         _printf_i _printf_common
                                                                         __sfputs_r
                                                                         
                                                main puts _puts_r __swbuf_r _fflush_r __sflush_r __swrite _write_r _write
                                                (may be the most correct) main iprintf _vfprintf_r __sfputs_r __sfputc_r __swbuf_r _fflush_r __sflush_r __swrite _write_r _write

                                                getchar() __srget_r __srefill_r __sread _read_r _read
                printf MAX length? setvbuf() buf len? printf experiment, printf > 4096 what will happen, change to C89, limit to 509??
                    From the 1999 standard:
                    --------------------------------------------------------------
                    7.19.6.1 The fprintf function

                    Returns

                    14 The fprintf function returns the number of characters
                    transmitted, or a negative value if an output or encoding
                    error occurred.

                    Environmental limits

                    15 The number of characters that can be produced by any single
                    conversion shall be at least 4095.
                    --------------------------------------------------------------

                    From the 1989 standard:
                    --------------------------------------------------------------
                    4.9.6.1 The fprintf function

                    Returns

                    The fprintf function returns the number of characters transmitted,
                    or a negative value if an output error occurred.

                    "Environmental limit"

                    The minimum value for the maximum number of characters produced by
                    any single conversion shall be 509.
                    --------------------------------------------------------------    

                 gcc -E -dM file.c  <- shows defines in build process
                 gcc -E -P file.c   <- shows preprocessed result
                 
                 arm-none-eabi-readelf -a main.o | grep symbol      <- .rel.text show symbol addr at .text needed to be replaced  
                 arm-none-eabi-objdump -d main.o                    <- see line shown above, the location may be a DCD, which is refer by indirect addressing mode code
                 
                 student st2[5]={
                　　[3]={
                　　　　　　.name = "Titus",
                　　　　　　.age = 22,
                　　　　　　.studentNo = 1041 },
                　　[2]={
                　　　　　　.studentNo = 1042,
                　　　　　　.age = 23,
                　　　　　　.name = "Stephen" },
                }
                
                int a[]= { [0 ... 9]=1, [20 ... 99]=2, [100] =3};
                
                int a[7] = { [4]=29, 33, [2]=15 };
                相當於
                int a[7] = { 0, 0, 15, 0, 29, 33, 0 };

                student st1={
                　　.name = "Peter",
                　　.age = 18,
                　　.studentNo = 1234
                };
                
                typedef struct student{
                　　char name[50];
                　　int studentNo;
                　　int age;
                }student;
                
                s1 strcpy(s2, s3)
                Copies the string s2 into the character array s1.The value of s1 is returned

                strstr, strcat, s1 strcpy(s2, s3) 的指標狀況, s1 is from heap or pointer to s2, s3? how to alloc s1?
                they don't malloc for user, user need to malloc themselves, strcat dest need to havd enough space, strcpy dest need larger than src or there will overflow attack
                            
                GOT PLT shared library
                    "file:///C:/weekly-report/note/htm/GOT_PLT_SharedLibrary.html"
                    "file:///C:/weekly-report/note/htm/Load-time-relocation-of-shared-libraries.html"
                    "file:///C:/weekly-report/note/htm/Position-Independent-Code-(PIC)-in-shared-libraries.html"
                    
                    loadtime relocation
                        global variable 留白
                            46f: a1 00 00 00 00          mov    eax,ds:0x0
                        在 .rel.dyn section 有欄位告訴 dynamic loader 哪裡有global variable 要 relocate.  (加上原 0x470 address 裡的值)
                            00000470  00000401 R_386_32          0000200C   myglob
                        Relocating function calls, flow is quite the same.                   
                        
                        Why was the call relocation needed?
                            function 在 code section, 相對位址不會變, 為何需要 loadtime relocate? <- 此function 可能會被 override
                        Referencing shared library data from the executable
                            myglob 若在 .so function 自 call, 位址會在 share lib load 進去的區間 0x133000, 
                            若是 application main() 有extern myglob, 那位址會被放到 application 同區 0x804a018
                            另外, myglob 初始值也會在 .rel.dyn section 中提到  0804a018  00000605 R_386_COPY        0804a018   myglob
                            
                    PIC    
                        loadtime relocate has 3 problem. 1 - the performance problem  2 - the non-shareable text section problem  3 - having a writable text section poses a security risk
                        offset between text and data sections (GOP) offset can be known at link time.
                        making an IP-relative offset <- push pc into stack, and pop then jump to it.
                        GOP 
                            all variables in code region, are offset to the same GOT table entry, linker can calculate those offsets, 
                            and dynamic loader still has to resolve GOP entry to know variables' absolute address.
                            this fix 3 problem above
                                performance is better at loader.
                                sharable code and secure problem. 
                                    code section are all the same between process, they don't have to be writable as loadtime relocate 
                                    The .data section is writable and not shared between processes                           
                        PLT
                            lazy binding
                        
                        LD_BIND_NOW, LD_BIND_NOT are environment variables can config and choose between 'loadtime reloc' and 'PIC'
                
                gcc預設會去尋找headers的目錄大致有：
                    /usr/include
                    /usr/local/include
                    /usr/src/linux-headers-`uname -r`/include
                    /usr/lib/gcc/i486-linux-gnu/UR_GCC_VERSION/include
                    可以利用多個-I來指定多個headers的路徑
                gcc預設會去找lib 函式的目錄大致有：
                    /usr/lib
                    /usr/local/lib    
                    /usr/src/linux-headers-`uname -r`/lib
                    /lib/modules/`uname -r`/kernel/lib
                    /lib
                    可以利用多個-L來指定多個lib路徑
                static library
                    gcc operator.c -c
                    ar crsv liboperator.a operator.o
                    或者
                    gcc -static operator.c -loperator
                    要與靜態函式作鏈結也很容易
                    gcc main.c /usr/local/foo/lib/liboperator.a -o main
                    或者
                    gcc main.c -L /usr/local/foo/lib -loperator -o main
                link "gcclib.txt"
                
                code optimize can reduce size in unused code in library?? GCC/binutils can do this if you compile with -ffunction-sections -fdata-sections and link with --gc-sections.  
                
                If you want to see the C code together with the assembly it was converted to, use a command line like this:
                gcc -c -g -Wa,-a,-ad [other GCC options] foo.c > foo.lst       
                -Wa,-alhms="*.lst" <- that's excerpted from keil arm-none-eabi option
                -alhms="*.lst" <- if arm-none-eabi-as, use this directly
                
                use -E -dM options instead of -c. Example (outputs them to stdout):
                gcc -dM -E - < /dev/null
                touch foo.h; cpp -dM foo.h
                
            solved
                show hll with assembly, build with -g3, objdump -S
                > iprintf can't find alias printf
                > memchr(origin, '/0', strlen(origin)) <- if there is no /0 char in origin, return null, if there is one, you see nothing from printf, because the string starts from '/0'
                strtol - for (acc = 0, any = 0;; c = *s++) 
                #define	_DEFUN(name, arglist, args)	name arglist args;
                carry/overflow bit C V N Z of arm instruction
                    - overflow has meaning for sign number -- add - if bit6, bit7 didn't carry toghter, OV = 1. sign 8bit represent values from -128 to 127
                    - carry has meaning for unsign number -- add if carry msb carry=1, sub if no borrow carry=1     


                

    ;rtos
        ;why multithread
            server connections and sockets
            GUI, needs to respond user when perform time-consuming operation
            "file:///C:/weekly-report/note/htm/Multi-Threaded-Programming.html"
            
            "C:\weekly-report\note\htm\Advantages of using an RTOS.html"
            
        ;Program,Process,Thread
            在介紹Thread之前,我們必須先把Program和Process這兩個觀念作一個釐清。

            Program:一群程式碼的集合,用以解決特定的問題。以物件導向的觀念來類比,相當於Class。
            Process:由Program所產生的執行個體,一個Program可以同時執行多次,產生多個Process。以物件導向的觀念來類比,相當於Object。每一個Process又由以下兩個東西組成
            一個Memory Space。相當於Object的variable,不同Process的Memory Space也不同,彼此看不到對方的Memory Space。
            一個以上的Thread。Thread代表從某個起始點開始(例如main),到目前為止所有函數的呼叫路徑,以及這些呼叫路徑上所用到的區域變數。當然程式的執行狀態,除了紀錄在主記憶體外,CPU內部的暫存器(如Program Counter, Stack Pointer, Program Status Word等)也需要一起紀錄。所以Thread又由下面兩項組成
            Stack:紀錄函數呼叫路徑,以及這些函數所用到的區域變數
            目前CPU的狀態
            由上面的描述中,我們在歸納Thread的重點如下

            一個Process可以有多個Thread。
            同一個Process內的Thread使用相同的Memory Space,但這些Thread各自擁有其Stack。換句話說,Thread能透過reference存取到相同的Object,但是local variable卻是各自獨立的。
            作業系統會根據Thread的優先權以及已經用掉的CPU時間,在不同的Thread作切換,以讓各個Thread都有機會執行。        
        
        "file:///C:/weekly-report/note/htm/[轉貼]Understanding uC_OS-II (1) @ Iver's Blog __ 痞客邦 PIXNET __.html"
        與共用資源打交道時，使之滿足互斥條件最一般的技巧有：
            enable/disable interrupt.
            performing a test-and-set instruction.
            disabling scheduling.
            using semaphores or spin lock.
    
        mutex&semaphore
            mutex
               two task wait for same resource, same shared function code snippet, wrapped   
               by mutexlock( ) and mutex_release( ).
            semaphore
               one task wait( ) for another task send_ready_signal( )  

        Deadlock (鎖死)
        是指兩個 task 無限期地互相等待對方控制著的資源。假設 task T1 正獨享資源 R1，task T2 在獨享資源 R2，而此時 T1 又要獨享 R2，T2 也要獨享 R1，於是哪個 task 都沒法繼續執行了，發生了 Deadlock。最簡單的防止發生 Deadlock 的方法是讓每個 task 都：
        先得到全部所需要的資源再做下一步的工作。
        每個 task 去申請多個資源時，必須有相同的順序。
        在釋放資源時，必須使用與上述相反的順序。
        kernel 大多允許使用者在申請 semaphore 時定義等待 time-out，以此化解 deadlock。當等待時間超過了某一確定值， semaphore 還是無效狀態，就會回覆某種形式的 time-out 錯誤碼        

        semaphore can do resource exclusion and can also do "synchronization"
        可以利用 semaphore 使某 task 與中斷服務同步,或者是與另一個 task 同步.  unilateral/bilateral(二個task雙向互等) rendezvous
        當某個 task 要與多個 event 同步時，要使用事件標誌.disjunctive synchronization, 即 logical OR. conjunctive synchronization, 即 logical AND
        可以用多個 event 的組合發信號給多個 task
        uCOS，支援 event flag 並提供設置 (SET)、清除 (CLEAR) 和等待 (WAIT) 等服務。且 event flag 可以是獨立型或組合型。
        clock tick and task jitter
        
        spinlock,mutex,semaphore,critical section的作用和區別
            Mutex是一把鑰匙，一個人拿了就可進入一個房間，出來的時候把鑰匙交給隊列的第一個。一般的用法是用於串行化對critical section代碼的訪問，保證這段代碼不會被並行的運行。
            (A mutex is really a semaphore with value 1.)
            Semaphore是一件可以容納N人的房間，如果人不滿就可以進去，如果人滿了，就要等待有人出來。對於N=1的情況，稱為binary semaphore。一般的用法是，用於限制對於某一資源的同時訪問。
            Binary semaphore與Mutex的差異：
            在有的系統中Binary semaphore與Mutex是沒有差異的。在有的系統上，主要的差異是mutex一定要由獲得鎖的進程來釋放。而semaphore可以由其它進程釋放（這時的semaphore實際就是個原子的變量，大家可以加或減），因此semaphore可以用於進程間同步。 Semaphore的同步功能是所有系統都支持的，而Mutex能否由其他進程釋放則未定，因此建議mutex只用於保護critical section。而semaphore則用於保護某變量，或者同步。
            另一個概念是spin lock，這是一個內核態概念。 spin lock與semaphore的主要區別是spin lock是busy waiting，而semaphore是sleep。對於可以sleep的進程來說，busy waiting當然沒有意義。對於單CPU的系統，busy waiting當然更沒意義（沒有CPU可以釋放鎖）。因此，只有多CPU的內核態非進程空間，才會用到spin lock。 Linux kernel的spin lock在非SMP的情況下，只是關irq，沒有別的操作，用於確保該段程序的運行不會被打斷。其實也就是類似mutex的作用，串行化對critical section的訪問。但是mutex不能保護中斷的打斷，也不能在中斷處理程序中被調用。而spin lock也一般沒有必要用於可以sleep的進程空間。        
    

    ;network ;internet
            HUB有兩大特性，一個就是廣播，一個就是半雙工。
            
            switch並不一直廣播，而且是全雙工的。SWITCH會記錄封包中的MAC位址
            要傳送的資料封包每一個都必須經過SWITCH判斷決定要送往哪一台電腦，所以會有一些延遲，電腦數少於五台，用HUB反而比SWITCH快。
            
            IP分享器  假IP網段通常是192.168.X.X，最常見的是192.168.0.X與192.168.1.X。這個IP網段是保留的網段，NAT這個功能負責記錄網卡MAC位址與假IP, 對外轉成WAN ip address            
            算是一個閹割版+功能限定的路由器, 路由器的主要功能是切割IP DOMAIN，可以切割成網內和網外，也可以兩邊都是網內，或者都是網外，而且他通常只負責轉送，並不會對要轉送的封包做手腳。 而IP分享器，只能轉送網內和網外，而且因為NAT的關係，轉送的封包一律會被修改過才轉送出去，用來解決一般民眾IP不足的問題。但是運作的根本原理，和路由器是相同的(一樣轉送兩個不同IP DOMAIN)
    
    ;mfc
        The default stack reservation size used by the linker is 1 MB.
        ;mutex
        "file:///C:/work/microsoft/mfctest/mutex"
        
        ubuntu 
            $cd /mnt/c
        
    ;windows driver
        How Windows Selects Drivers    
        VCOM大集合的driver有過WHQL認證，所以Rank值是0x00ff0001，最前面的一個byte是根據driver如何sign來決定, 00 is the highest. (the lower the higher)
        if same rank, 會從Drive Date來決定。最終Windows會選擇VCOM大集合的driver，因DrvDate比較新(04/06/2016 v.s. 09/24/2013)
        1.	沒有插著裝置時，安裝任何driver的話，Windows會將他們放到Driver Store裡面。然後當裝置出現時，Windows會照它的rule來找出最合適的Driver。
        2.	插著裝置時，使用安裝包的話，若有執行DPInst的command。它會觸發Pnp Manager呼叫UpdateDriverForPlugAndPlayDevices。接著會安照DPInst的command來run。若有/f的話，Pnp Manager便會強制安裝driver不管目前的driver是否更合適。
        (舊的安裝包有執行DPInst /f的command。該command會強制安裝driver即使目前的driver有更好的match)
    
        win10停止強制數位簽章_ win10 停止強制數位簽章.html
        WIN10   http://win10stopsignc.blogspot.tw/2015/09/1.html
        WIN8    http://win81stopsign.blogspot.tw/2014/04/win81.html
        
        Zadig is a Windows application that installs generic USB drivers, such as WinUSB, libusb-win32/libusb0.sys or libusbK
        
    ;isp
        keil burn isp fw, remember to boot from LDROM, and burn to LDROM
        
        isp uart connect timeout 300ms
        python isp.py com26 c:\zbin\32.bin
        
    ;nulink notes
        ??nulink ice class use singleton?

        usb cdc, interrupt IN can't remove, if remove Windows can't recognize VCOM. but it is actually unused.

        [2017wk11] TC8226 offline download SRAM, sram is 16KB, page size 4KB, current
            stack use 11.x KB, mbed 3.5KB, if to write serial number need one page
            buffer and not enough space (ccli said SN burning is ok)
            
            [wk50]
                ccli - 多寫一讀的錯誤處理, 
                    icecmd.cpp
                    m_u32KeepCmd save write cmd ID
                    ICE::Write_Data if Errno happen, multi write will be disrupted, set m_u32KeepWrite_DataLen=0, and if that len is 0, ACK will be triggered
                    ACK by ICE::AckCommand, update m_u32Errno to new value first, and call USB_SendBackData() to update 
                    ICE object 有二個 member, m_au32Input/m_au32Output, copy to g_au8DeviceReport[MAX PACKET] in HID_SendBackData(), 
                    g_au8DeviceReport copy to EP_BUF in HID_SetInReport(), and wait HOST to get IN report
                    
                    如果 host writeFile 4筆, 再readFile. fail在第2筆, 因沒來readFile, errno 會被第三筆蓋掉, 且第三筆第 3 byte 有機會被 fw 誤解為cmd, fw 會做錯
                    ccli wk51 report fixed it. cmd protocol change, add CMD index
                    Write block第一次傳的封包資料
                        CMD ID	CMD Length	CMD	        ADDR	    LEN	    DATA	Not used	CMD index
                        1 byte	1 byte	    4 bytes	    4 bytes	    4 bytes	48 bytes	1 byte	1byte
                        第2~20次傳的封包資料
                        CMD ID	CMD Length	CMD	DATA	Not used	CMD index
                        1 byte	1 byte	4 bytes	56 bytes	1 byte	1byte
                    
                    four situations for error handling
                        1.	FW端寫中間data出錯
                        從上述的錯誤處理有記錄error code，而且index不會被加1，下次PC端在傳資料過來，都會比對index不符而不會繼續做write data
                        2.	PC端20w中間斷掉不傳了，傳了其他CMD進來，之後才傳write block CMD
                        傳其他CMD一樣FW照做，之後傳write block CMD一樣當成第一筆，之前沒做完的那些address與total length會被新的覆蓋，也是可正常運作。
                        3.	PC端傳完20w最後沒有readfile結果
                        與第二種case類似，FW 處理完20w結果會被之後處理完的command結果覆蓋，也是可以繼續運作。
                        4.	PC端傳writefile過去，但FW沒收到封包，之後PC端呼叫readfile
                        這個在1w1r的情況下一樣，PC端會讀不到東西，因為FW不知道有收到封包而沒處理任何CMD也沒回傳結果。
            
        flash bp run time setting for hw bp only?? yes, if > hw bp num, run time will warning user can't set bp, flash bp only set at the point when stop to run
               if encounter a flash bp and halt, driver will fill instruction back and step, then fill bp back, then freerun
        
        ;diffie
            ga % p = n (send to other)
            na % p = key (殺g取key)
            
            分解
            g^11 %p -> (g^2^3%p)(g^2%p)(g^2%p)
            g^2^3%p -> (g^2^2%p)^2%p -> ((g^2%p)^2%p)^2%p -> (((g%p)^2%p)^2%p)^2%p
        
        ICP offline mode aprom 超過 dataflash 時, 燒到 dongle spi 無法防. 因沒有接 target, 不知target total rom size
        NuLink 只有 level shift, 沒有供電壓的, 吃 pc 5V VCC out, SWD 輸出的部份由level shift 全部轉為 5V, 
        nulink-pro 行為是若偵測 target 有電就不輸出, 若無就依 user 選擇電壓供電
        
        nulink-pro 2000 pieces per year, each 900NTD
        nulink 3000 pieces per year, each 600NTD
        nulink me, no selling, with tiny board 20USD, 20000pcs/yr
        
        ;release website version
            6040
            6103
            6211
            6287 tool update
            6314
            6340
            6386
            6425
            6491
            6535
            6561
            6592
            6629
            6674
            6725
            
        ;competitor
            JTRACE(45000NTD) SDRAM 16MB/128Mb K4S281632O-LI75
            
            ;ulink-pro 
                https://developer.arm.com/products/software-development-tools/debug-probes-and-adapters/ulinkpro-family
                可以支援 cortex M, A, R 以及 DS-5
                1.2 ~ 3.3V
                flash 32KB, sram 1MB, SWD 50MHz
            
        ;build software
            icptool build by vs2008
            keildll2 build by vs2010
            iar8 build by vs2013
        ;ice2
            FlashICENUC100 -> FlashNUC100 -> FlashNuFMC -> Flash
            FlashICEData.cpp -> dongle 沒有 spi flash 改存 dataflash, nulink1 並沒有用到這個
            ice.cpp -> SetFlashMode -> g_MemFlash0->InitObject(..., m_pFlash 
            flashoffline.cpp -> g_MemFlash1->InitObject(..., g_FlashData        g_MemFlash1 <- offline 時專門給 spi flash 搬到 m_pcbuf 用 (r/w 以 mem為視角)
            
            offline memoryDec.copyto 從 flashSPI getdata 然後 decode, flash.cpp setdata -> refreshbuffer -> FlushData  -> m_pFlash->Write 
            (g_MemFlash0 = pDesMemory = FlashAxf.cpp) 
                    

        Q: NuLink set C_MASKINT when step, will F11 get into interrupt handler?? 
        A: 從 debugger 設定 C_MASKINT 確實可以擋掉 interrupt, 實際拿 ISP UART as experiment, it won't into ISR.
           但是若是先在 keil 按 halt 停在 A point, 在還沒按 step 前, interrupt 可能會先發生, 此時按 F11 還是會先進一次 ISR, 這次是殘值, 若持續按 F11 就不會進相同 ISR 了.
           若一開始有設斷點在 A point, 按 F11 進 ISR, 再按 F5 run, 因為剛才是在 ISR, 所以會停回 point A, 再按 F11 因為剛才 F5 又收 interrupt 進來, 又會踏回 ISR, 
           A point 若是一個 function, F11 + F5 會永遠進不了它, 這是于處 2017/11/21 9:51AM 的問題
            
        Q: ICE2 MemoryICECmd and MemoryICE 差異?
        A: 擋外部 ICE command 透過 write FMC register dump data flash data, 有擋掉一些 FMC 寫操作, 讀的部份可以讀出 memory map 0 addr, including dataflash
        
        Q: ICE2 MemorySWD and MemoryV6M 差異?
        A: MemorySWD 外部 ICE command access target IDCODE/BD 用, winhid app 端算出 (idcode/tar/csw.. etc.) define 值, ice 端直接接收define 值丟給底層 setreg() 去設定
           MemoryV6M 是 getdata/setdata 為對外 api, 轉 setuint32/getuint32 -> setuint_/getuint_ -> 拿到 (idcode/tar/csw.. etc.) define 值由底層 setreg() 去設定
        
        Q: nulink firmware upgrade replace .bin file and dump dataflash can hack?? 
        A: 會檢查幾個 APROM FW 幾個 address 有沒有 magic number, 錯的話就不跳過去, hacker無法自己放 .bin 到 ice aprom.
        
        old note
            "file:///C:/work/nulink/ICPtool/encode.txt"
            "file:///C:/work/nulink/ICPtool/decode.txt"
            
            cert 只能用於 online, 因為 icp file 只要 import, option dialog 中的 offline download 就會 un-select (CDialog_NUC1xx::OnSaveAll 不管有沒cert都會取消offline mode)
            DialogMain.cpp 內的 Thread_ReadOnlineInfo Enc_GetInfo 會 get 出 Dialog_nuc1xx 下方 Info tab 的 data
            
            PC side===================================================================
            Thread_ProgramOfflineFlash()
                struct flashEncryptInfo used to burn to ICE dataflash FLASH_ENC_PAGE_OFFLINE_INFO FLASH_ENC_PAGE_OFFLINE_TOTAL FLASH_ENC_PAGE_OFFLINE_SUCCESS 
                            (by SetOfflineEncryptData() aucPassword is rand(), aucUserPassword is in UI option page)
                struct flashOfflineInfo used to burn to ICE SPI 
            
            FW side===================================================================
            Flash.cpp
                FlushData()
                            this->EncodeData(u32ProAddr, pcBuf, u32ProgramSize_P);
                            m_pFlash->Write(u32ProAddr, pcBuf);														//flashoffline.cpp 中設定為 m_pFlash 設定為 FlashAxf
                            this->DecodeData(u32ProAddr, pcBuf, u32ProgramSize_P);
            ICE.cpp
                SetConfig (set m_pDevice, m_pDeviceFlash)
                    case NUC_CHIP_TYPE_NANO100:
                    m_pDeviceFlash = new(&m_flash_buf) FlashNUC100;
                
                SetFlashMode (set m_pFlash)
                    case FLASH_MODE_TARGET_BOARD:
                    m_pFlash = m_pDeviceFlash;        
        
        icptool 上的 chip erase 不用先按 connect button, 直接點就會先用 isp chip erase 再用 icp chip erase, 可以應付像 ICE LOCK bit, 只剩下 icp chip erase 能動的這種
        
        how to print nulink&ICE log, 
        enable EnableLog=1 of selected chip in Nu_Link_Driver.ini
        into debug session and operate, there will be a Trace.log generated under the same folder.
        release version dll only has AGDI command, debug version dll will add ICE level command

        if SWD not ACK_OK, ICE will try 5ms with no delay
            if(eRet == SWIO_ACK_OK)
                return eRet;
            else if(eRet == SWIO_ACK_WAIT)          //re-send SWD waveform immediately
                ;	//Nothing
            else
                ConnectToDevice();                  //reconnect 50's one and re-send SWD waveform
        
        PC side 有二個地方會 polling MCU_STOP, callTargetFunc() & gocmd() 下給 ice 若得到上述 fail 
            就掛點 throw CICEException(_T("ICE: protocol error - Get_MCU_State!"));
        若沒掛在上面, 有另一個timeout refer to flash algorithm flashdev erase & program timeout (m_flashDevice.toProg), others like Init() and Uninit(), set to 2sec.
        這個是若 ICE FW ACK_OK 不會掛點在 ACK_FAULT 5ms 的地方, 卻等不到 cpu halt 的 timeout.
                    
        
        keil flash dev 可以設 program/erase timeout. iar 等到 flash algo 做完為止, 也可能卡到死.

        NuLink FW - Data Flash Emulates EEPROM
            原始 NuLink存取最頻繁的 success / total 己有採取這種做法,
            如每按一次offline download 就要增加的success count (4bytes) 用1page去存分成 128單位, 
            Erase 1page 後, 依順序把數值寫入 data flash
            如00 00 00 01  00 00 00 02 …. 00 00 00 03 <- 1 page 寫滿就 erase page 再循環, 4個4個bytes program
            所以照這算法此二個數值endurance 都有 20000 x 512/4 = 2560000 次
        ICPTool
            ICP tool脫機燒寫模式的燒錄指定區域選項
            如果沒有勾選: 脫機燒寫會將APROM、LDROM、Dataflash都erase才燒寫數據，但是Config的數據都還留著 也不是all chip
                目前流程是: 若沒有勾選CONFIG, ICE Firmware會先讀回CONFIG, 然後做Chip Erase, 再將CONFIG寫回去.
                由於CONFIG的數據會影響APROM/Data Flash/LDROM的size. (e.g. NUC100/MINI51/NANO100 DFEN, NUC123 DFVSEN, ISD91 LDEN, …)
                若是做完Chip Erase卻沒有將原本的CONFIG保留, 可能發生下載檔案的大小與對應的Flash size配不上, 而導致下載失敗.
            如果有勾選: 只會對脫機燒寫設定的區域進行燒寫，不影響其他區域原本的數值，此方式比較符合我們ICP的使用習慣，下一版ICP脫機燒寫模式default此選項
                有勾選的確不會影響其他區域, 離線下載速度就會比較慢. 沒有勾選: 使用Chip Erase; 有勾選: 使用Page Erase.
                以NUC472為例, 下載一個將近512KB的檔案, 使用Chip Erase會比Page Erase快~5秒.
                NUC505 2MB, 大約差10秒. 當Flash越大, 差異就會越明顯
                (若選脫離, 不管是不是勾 specific area, 會把 SPI flash 全洗掉用這次勾的 LD/AP, 它的 specific 是指在按鈕後, target 的 DATA flash 不會被洗掉)
                
            ICPTOOL online 燒寫
                AP/LD/DATA/CONFIG 全勾才會用 chip erase, else page erase (slower)
            
            online cert - factory gen .ict (passwd is in dongle's dataflash ONLINE_ENC_T, and .ict file has ID 4B + PASSWORD 32B, both generated by rand() of PC)
                          developer take .ict and gen .icp, PASSWORD is open, encrypt XOR method is secret, output encrypted AP/LD in .icp file.
                          EFILE 'abcde' is to encrypted/decrypted max_count in .icp.
                          DH between PC and target, PC rand() it's random number a, target random number b is gen from SYSTICK, 
                          flash algo StartRand() -> random delay -> StoreRand() to get systick value. and then calculate their own key respectively.
            offline - user key in password in edit box, that is acuUserPassword, save in flashofflineInfo in SPI flash, and data flash in ICE internal flash.
                      while code write to dongle SPI, there is a rand() generated aucPassword, whenever data in/out SPI flash, must be encoded by this.
                      (flash.cpp) this->EncodeData(u32ProAddr, pcBuf, u32ProgramSize_P);
                      
                      PC side encrypt (dialog_mini51.cpp) XORData(flashOfflineInfo.header.u32RandomSeed, ldromBuffer, sPwd);
                      FW side decrypt (flashOffline.cpp) if (m_u16ScanPos >= m_u16PasswordLength)                 
        
        chip reset 在早期 keil/icp 只有 reset and run會用到, write config0 use icpen to make effect.

        [2017WK15] NULINKPRO    一開始就經由 ADC 看 target 是否有 power, 沒就 ice 供, ice 供會去做以下 polling
                        1. nulink1-pro ACMP_N (灌入 reference voltage 0.75), ACMP_P 測量 TVCC target 電壓是否有低於 0.75v 
                           nulink2-pro (0.825v of nulink2-pro with bandgap as reference)
                        2. ADC 會 check 是否大於 (voltage+6%).
                        以上二點成立ice會斷點, JC 表示應該統一用 ADC 就可以了不用 ACMP (二根同樣來自 target TVCC), 原因是ACMP偵測掉電可能比較快 
                     BANDGAP 永遠是 1.25v, 會有一個參考值 e.g. 1000, 可以從另一個 register 直接讀到2000, 就可以直接得到系統電壓 1.25x2=2.5v
                     SPIM 才能跑 flash code, 跑falsh 也有 QUAD mode, QUAD mode 用到六根, 但只有 data 部份可以用滿其中四根, command 仍只能用一根, data/cmd要一直切換
        
        ice command
            Check_USB_Link      PC side see if bOpenPort            
            CMD_CHECK_LINK      return read IDCODE successful or not (true or false)
            CMD_CHECK_ID        return target DAP IDCODE
            
        mutex
            ShareArea 有 iceglobal77881234 表device己被某 app lock住. 
            還有其它三個 devpath_HID, devpath_BULK, devpath_WinUSB 是用來給各 app lock USB所有權, 搶到的 app 不管上述 iceglobal 就能存取 ICE Command.
            icp/keil/iar enumerate flow 為先用 bulk open 511c, 沒裝 bulk driver open 不會成功, 不成功再 try open hid 511b
            
        USBHID command protocal
            HID.hpp WriteFile 3bytes(00 cmd_idx cmd_len) ice.cpp Write_Flash 12bytes(CMD_WRITE_FLASH, addr, len) 48bytes data 
                if cmd_idx msb = 1 means error happen, cmd_idx range is 0~0x7f
            windows usb HID driver 第一個byte 固定是0 但傳進 writeFile (共65bytes含byte0 dummy zero), first dummy zero 不會送出去實體 USB BUS, 
                從 bus hound 看到第一byte是0的資料, 就是app 與 PC USB driver 間的溝通, 沒有0的就是真的 USB BUS實際data
            如上 nulink1 HID 傳輸我們實體 bus 上是 62bytes (HID/BULK 都是), 有 2bytes 沒用到
            BULK 第一byte 不用是0
            
            
        serial number
            Online 當燒寫成功, SN才會+1.
            Offline 每按一下button, SN就會+1
            
        fw upgrade
            LDROM 先看 checksum 對了就跳到 APROM, 若不對則可能會說上次有upgrade動作, 要不要繼續完成
                跳到 APROM 才檢查目前APROM版本和app是否相符並pop up upgrade message
            修改LDROM/APROM之前，先修改config0，確保從能工作的區塊啟動
            APROM有checksum，LDROM啟動時發現checksum不對，會停留在LDROM
            
        FW release note
            cks.bin 主要有二個值要填
            一個是 ICE_M0.bin 的 file size 4bytes
            另一個是 ICE_M0.bin 的 2 bytes checksum, 用 HxD 開 ICE_M0.bin 選 checksum 16

        ;usbd  
            "file:///C:/weekly-report/note/usb.pptx"            
            file:///C:/data/nuvoton/peripheral/usb
            hid report descriptor
            
            terminology 
                A USB function is a set of one or more related interfaces that expose a capability.
                a device might provide both a printer and a scanner function.
                Hubs and peripherals are devices. The host assigns a unique address to each device on the bus.
                A composite device has one bus address but multiple, independent interfaces that each provide a function. Each interface can use a different driver on the
                host. For example, a composite device could have interfaces for mass storage and a keyboard.
                
                模式(Configurations)：
                一次只能使用一種模式，不可能同時有兩種模式並行的運作狀態，常見的應用是將 USB 裝置切換至 Firmware 的更新模式，做韌體升級，此時該硬體的一般模式將沒有作用。

                介面(Interfaces)：
                一個 USB 裝置可能有很多個輸入或輸出介面，舉例來說，若是有一個帶麥克風的耳機，就會有兩個介面，分別為『聲音 Input』和『聲音 Output』所使用。用一個特殊的例子『3G Modem』可更容易說明：

                3G Modem 擁有至少三個介面：
                Serial for modem
                Serial for information update
                Mass Storage
                
                Endpoint 的傳輸形態分為control,interrupt,bulk,iso.
                
            ideal usb bulk speed -> 1.2 MB/s at full speed, 53 MB/s at high speed, and 400 MB/s at SuperSpeed
            usb transfer -> transaction(s) -> token+data+handshake packet -> token (pid+addr+ep+crc) data (pid+data+crc) pid
            speed
                low (1.5Mbps) full (12Mbps) high (480Mbps)
            packet size 
                full (interrupt 1ms/bulk 64bytes) high (interrupt 125us 1024, bulk 512)
            descriptor 
                plug in -> device detect (to see if USBDM/USBDP pulled up to judge low/full (high pull up USBDP same with full, then send high speed package known as JK chirp))
                -> get device descriptor (vid, pid is here) -> config descriptor (# of interfaces) -> interface (which class e.g. HID, # of ep)
                
        ;ICE firmware
            ICE Cmd error 可以查 KeilDll2/SWErrno.h                    
            wait mcu reset timeout 是什麼error 造成的 <- mcu_reset 即 connect 就連不上
            "Wait core register access timeout" <- core reg fail
            Get register data error <- read memory fail
            ICE error total; Open/read/write USB, core reg/memory access, mcu reset/stop, flash read/write/page erase/chip erase

            USB PID
                最新的fw 靠pin 區別 511D / 511C  
                最新的fw 是511c (含hid and bulk), 舊的 icp application 會去偵測 both 511c and 511b 的 hid (舊 app can't detect 511d)
                舊的fw 是 511b hid only  
                nulink2 vid pid  0x0416, 0x5200
                
            Nulink1 packet size 64                Index 1byte, command size 1byte, data 62byte
                                                    m_acBuffer[0] = 0x00;           <- 這個在windows application 有, for hid only, 實際不會傳出去
                                                    m_acBuffer[1] = (CHAR)ucCmdIndex;
                                                    m_acBuffer[2] = (CHAR)dwCmdLength;
            Nulink2 Packet size 1024              Index 1byte, command size 2bytes, data 1021bytes

    ;dp ;design pattern 
        decorator "file:///C:/weekly-report/note/pic/UML2_Decorator_Pattern.png"
        
        Template method pattern: compile-time algorithm selection by subclassing
        Strategy pattern: run-time algorithm selection by containment
        The template pattern is used when a particular operation has some invariant behavior(s) that can be defined in terms of other varying primitive behaviors. The abstract class defines the invariant behavior(s), while the implementing classes defined the dependent methods. In a strategy, the behavior implementations are independent -- each implementing class defines the behavior and there is no code shared between them. Both are behavioral patterns and, as such, are consumed in much the same way by clients. Typically strategies have a single public method -- the execute() method, whereas templates may define a set of public methods as well as a set of supporting private primitives that subclasses must implement.
        The two patterns could easily be used together. You might have a strategy pattern where several implementations belong to a family of strategies implemented using a template pattern 
        
        template method
        class ConcreteAlgorithm : AbstractTemplate
        {
            void DoAlgorithm(int datum) {...}
        }
        class AbstractTemplate
        {
            void run(int datum) { DoAlgorithm(datum); }
            virtual void DoAlgorithm() = 0; // abstract
        }

        Strategy pattern 
        class ConcreteAlgorithm : IAlgorithm
        {
            void DoAlgorithm(int datum) {...}
        }
        class Strategy
        {
            Strategy(IAlgorithm algo) {...}
            void run(int datum) { this->algo.DoAlgorithm(datum); }
        }

        design pattern  沒有要別人特別去做什麼事，但有個人在我某個狀態改變之後，他就會自己去做某件事，做這件事情的時候他也不必告訴我。甚至，會自己做別的事情的人還不只一個。這種一對多的關係，叫做 Observer。
        一件事情雖我可自做，但假如這個時候出現了一個特別的人，當我要做這件事情的時候，我可以問他我該怎麼做，或是當我告訴他的時候，他可以因此做某件事情。這種一對一的關係，叫做 Delegate。
        而如果今天我要寄信，我找了郵差，但雖然都是郵差，每個郵差寄信的方式都不一樣，有的開車，有的騎單車，有的信甚至要用航空遞送，所以我必須自己去找一個最適合我的郵差幫我寄信，這叫做 Adapter。當然我也可以找某個窗口，告訴他我的信要用平信、掛號還是要寄到國外，然後只要給我一個郵差就好，而這就是上面提到的 Abstract Factory。            
        而如果一件事情很複雜，需要好幾個人分工合作，你不想要自己去找所有人，而是只想找一個人幫你協調其他幾個人的工作，有什麼事情都只找這個人就好，這就叫做 Facade。因為 Facade 統一事權，所以 Facade 往往也是 Singleton。
        比方說，今天我們有個電子書的軟體，裡頭有個商業促銷的規則，當用戶讀過十本書的時候跳出訊息希望用戶上 App Store 或 Google Play 評分，讀過二十本書的時候，則出現訊息希望用戶上 Facebook 按讚，這個規則只適用在這個版本，三個月之後的下一個版本，要拿掉這條規則。你有幾種選擇—直接把程式碼寫在電子書檔案 viewer 的部份，把按讚的邏輯
        、讀過幾本書的 counter，與如何解析 epub 格式、處理換頁的程式碼寫在一起；或，你把按讚的規則抽離出來變成一個新的物件，每當 viewer開啟了新的檔案，這個物件就會收到通知，自己改動讀過多少書的 counter，發現到了特定數量之後，就跳出該出現的訊息，這個物件訂閱了 viwer 開啟檔案的事件，viwer 不知道這個物件的存在。你用上了 Observer Pattern

        
        head first design pattern (HFDP)
            strategy pattern vs template method
                Template method pattern: compile-time algorithm selection by subclassing
                Strategy pattern: run-time algorithm selection by containment

                template method
                    class ConcreteAlgorithm : AbstractTemplate
                    {
                        void DoAlgorithm(int datum) {...}
                    }

                    class AbstractTemplate
                    {
                        void run(int datum) { DoAlgorithm(datum); }

                        virtual void DoAlgorithm() = 0; // abstract
                    }
                    
                Strategy pattern
                    class ConcreteAlgorithm : IAlgorithm
                    {
                        void DoAlgorithm(int datum) {...}
                    }

                    class Strategy
                    {
                        Strategy(IAlgorithm algo) {...}

                        void run(int datum) { this->algo.DoAlgorithm(datum); }
                    }
                
            strategy - problem of inherit, if superclass method need override heavily, it's bad to override method in each subclass.
                   if you put pure-virtual (interface) in superclass, to implement every pure-virtual method in subclass is also redundant. (if some same, some not)
                   主體 class A 只 call 要strategy 的 method, 這個 method 是另一個 class B 的 pure-virtual, B-subclass 去 implement pure-virtual method.
                   A 在instantiate 時init 可以挑B-subclass 其中一個具現為 A obj 中的 B-subobject, 可以傳不同的 B-subobject to A, 動態切換 Aobj call 到的 B-subobject method 
                    
                   program to implement 
                       Dog d = new Dog();
                       d.bark()
                   program to interface
                       Animal a = new Dog();
                       a.makesound();
                   Animal has a makesound() pure-virtual, and Dog/Cat inherit them. the implement content of Dog makesound() is bark()
                       
    ;visual studio
        TBD ProFactor IncludeManager Makes Sense Integrated Visual C++ Include Graph Viewer    

    ;clang
        [2017wk17]
                r+ & w+
                    看說明，r+ 和 w+ 兩者都是同時支援讀和寫，那差異到底在哪裡？答案是：開檔的時候，w+ 會清場，r+ 不會。
                    模式	    檔案存在	                        檔案不存在
                    r+	        打開檔案定位在檔案開頭	            發生錯誤
                    w+	        打開檔案清空檔案內容定位在檔案開頭	創建新檔
                                                                    打開檔案
                                                                    定位在檔案開頭
                    a+	        打開檔案定位在檔案尾巴	            創建新檔打開檔案定位在檔案尾巴
                
                r vs rb           
                    # 
                    我

                    b'#'   
                    b'\xe6'
                    b'\x88'
                    b'\x91'                    
                    
                binfile=open(filepath,'rb') 讀二進位文件
                binfile=open(filepath,'wb') 寫二進位文件
                那麼和binfile=open(filepath,'r')的結果到底有何不同呢？
                不同之處有兩個地方：                
                第一，使用'r'的時候如果碰到'0x1A'，就會視為文件結束EOF。使用'rb'則不存在這個問題。
                第二，對於字符串x='abc\ndef'，我們可用len(x)得到它的長度為7，\n我們稱之為換行符，實際上是'0X0A'。當我們用'w'即文本方式寫的時候，在windows平台上會自動將'0X0A'變成兩個字符'0X0D'，'0X0A'，即文件長度實際上變成8.。當用'r'文本方式讀取時，又自動的轉換成原來的換行符。如果換成'wb'二進位方式來寫的話，則會保持一個字符不變，讀取時也是原樣讀取。所以如果用文本方式寫入，用二進位方式讀取的話，就要考慮這多出的一個字節了。'0X0D'又稱回車符。linux下不會變。因為linux只使用'0X0A'來表示換行。
        ;lib
            memcpy(dst, src, size)
                memcpy (str2,str1,strlen(str1)+1);
                memcpy (str3,"copy successful",16);
            memset(TEST,0,sizeof(struct sample_struct)*10);
            strcpy(dst, src)  stop at '\0', user has to control overflow
        ;preprocessor
            ;gnu preprocessor
                ;Self-Referential Macros
                    #define foo (4 + foo)   <- 只展開一次
                    #define EPERM EPERM     <- 可搭配 #ifdef

                    #define b(arg) a(arg##sb)
                    #define a(arg) b(arg##sa)
                    a(1) -> gcc -E file.c -> a(1sasb)
                    b(2) -> b(2sbsa)
                                        
                    #define c() d()
                    #define b() c()
                    #define a() b()
                    a() -> gcc -E file.c ->     d()
                    
                    #define b(a) a(a)
                    #define a(a) b(a)
                    a(1) -> gcc -E file.c -> 1(1)
                    b(2) -> 2(2)
                ;Argument Prescan
                    Macro arguments are completely macro-expanded before they are substituted into a macro body, unless they are stringized or pasted with other tokens. After substitution, the entire macro body, including the substituted arguments, is scanned again for macros to be expanded. The result is that the arguments are scanned twice to expand macro calls in them.
                    Most of the time, this has no effect. If the argument contained any macro calls, they are expanded during the first scan. The result therefore contains no macro calls, so the second scan does not change it. If the argument were substituted as given, with no prescan, the single remaining scan would find the same macro calls and produce the same results.
                    You might expect the double scan to change the results when a self-referential macro is used in an argument of another macro the self-referential macro would be expanded once in the first scan, and a second time in the second scan. However, this is not what happens. The self-references that do not expand in the first scan are marked so that they will not expand in the second scan either.
                    
                    prescan 只對下面三種case 有影響, 主要功能應是 nested call 
                        Nested calls to a macro.
                        We say that nested calls to a macro occur when a macro’s argument contains a call to that very macro. For example, if f is a macro that expects one argument, f (f (1)) is a nested pair of calls to f. The desired expansion is made by expanding f (1) and substituting that into the definition of f. The prescan causes the expected result to happen. Without the prescan, f (1) itself would be substituted as an argument, and the inner use of f would appear during the main scan as an indirect self-reference and would not be expanded.
                        #define f(a) (a+1)
                        f(f(f(f(f(1))))) 會變 (1+(1+(1+(1+(1+1)))))

                        Macros that call other macros that stringize or concatenate.
                        If an argument is stringized or concatenated, the prescan does not occur. If you want to expand a macro, then stringize or concatenate its expansion, you can do that by causing one macro to call another macro that does the stringizing or concatenation. For instance, if you have
                        #define AFTERX(x) X_ ## x
                        #define XAFTERX(x) AFTERX(x)
                        #define TABLESIZE 1024
                        #define BUFSIZE TABLESIZE
                        then AFTERX(BUFSIZE) expands to X_BUFSIZE, and XAFTERX(BUFSIZE) expands to X_1024. (Not to X_TABLESIZE. Prescan always does a complete expansion.)

                        Macros used in arguments, whose expansions contain unshielded commas.
                        This can cause a macro expanded on the second scan to be called with the wrong number of arguments. Here is an example:
                        #define foo  a,b
                        #define bar(x) lose(x)
                        #define lose(x) (1 + (x))
                        We would like bar(foo) to turn into (1 + (foo)), which would then turn into (1 + (a,b)). Instead, bar(foo) expands into lose(a,b), and you get an error because lose requires a single argument. In this case, the problem is easily solved by the same parentheses that ought to be used to prevent misnesting of arithmetic operations:
                        #define foo (a,b)
                        or
                        #define bar(x) lose((x))
            
            preprocessor is sequencial, so the header guard is to prevent the same .h from being included twice by the same .c file
                #ifndef B_H_
                #define B_H_
                    happen here
                #endif /* B_H_ */
                ...
                #ifndef B_H_
                #define B_H_
                    won't happen here
                #endif /* B_H_ */
            
            
                #define double(x) (2*(x))
                #define call_with_1(x) x(1)
                would expand `call_with_1 (double)' into `(2*(1))'.

                #include_next

                cascade define 
                    #define BUFSIZE 1020
                    #define TABLESIZE BUFSIZE
                    #undef BUFSIZE
                
                #define min(X, Y)  ((X) < (Y) ? (X) : (Y))
                next = min (x + y, foo (z));

                    
                
        Cspec
            An object has a storage duration that determines its lifetime. There are three storage durations: static, automatic, and allocated.        
    
        http://eli.thegreenplace.net/2009/10/21/are-pointers-and-arrays-equivalent-in-c/#id5
        Are pointers and arrays equivalent in C? 
            Pointer arithmetic and array indexing are equivalent
                char arr[] = "don't panic\n";
                char* ptr = arr;
                printf("%c %c\n", arr[4], ptr[4]);
                printf("%c %c\n", *(arr+2), *(ptr+2));
            The semantics of arrays in C dictate that the array name is the address of the first element of the array.
            A pointer is just a regular variable that happens to hold the address of another variable inside.
                char a = array_place[7];
                    0041137E  mov  al,byte ptr [_array_place+7 (417007h)]
                    00411383  mov  byte ptr [a],al
                char b = ptr_place[7];
                    00411386  mov  eax,dword ptr [_ptr_place (417064h)]
                    0041138B  mov  cl,byte ptr [eax+7]
                    0041138E  mov  byte ptr [b],cl
            There is one difference between an array name and a pointer that must be kept in mind. A pointer is a variable, so pa=a and pa++ are legal. But an array name is not a variable; constructions like a=pa and a++ are illegal.
                /* array traversal */
                for (i = 0; i < sizeof(array); ++i)
                    printf("%c ", array[i]);

                printf("\n");

                /* pointer traversal */
                for (; *ptr; ++ptr)
                    printf("%c ", *ptr);            
            gotcha
                char my_arr[256];       (0x20000014)
                extern char* my_arr;
                    my_arr[2] = 87;  //my_arr is an address (0x20000014) point to 1st element of my_arr array above, it will get (0x20000014) value (maybe 0) and 
                                     //store value 87 into address(0 + offset 2 element), and then hardfault
                extern char my_arr[];  //this is totally okay, and save 87 to 0x20000016
                
                long gg;
                extern short gg;        <- 只會存取 16bits, 要extern long gg; 才會存取 32bit
            Arrays passed to functions are converted to pointers
                char **aaddr;
                void foo(char arr_arg[], char* ptr_arg) 
                {
                    char a = arr_arg[7];        //0x2000000c offset 7 
                    char b = ptr_arg[7];        //same process,   0x1150 offset 7, 沒有像放在main時要先從 ptr addr 0x20000070 取string literal addr 0x1150 再offset 7
                    aaddr = &arr_arg;           //aaddr is a pointer point to array 1st element
                    aaddr = &ptr_arg;           //aaddr is a pointer point to pointer ptr_arg
                    arr_arg = ptr_arg;          //arr_arg can be modified like this, arr_arg behavior is different with array_place of main(), array_place can't be alterred
                }
                The C compiler has no choice here, since an array name is a label it replaces at compile time with the address it represents. But a function isn't called at compile time, it's called at run time, where something should be placed on the stack to be considered as an argument. The compiler can't just treat array references inside a function as labels and replace them with addresses, because it has no idea what actual array will be passed in at run time.
                
                addr = array_place;  //addr=0x2000000c
                addr = ptr_place;    //addr=0x1150
                
                char **aaddr;
                char (*aaaddr)[];
                aaaddr = &array_place;      //aaaddr is a pointer point to array address
                aaddr = &ptr_place;         //aaddr is a pointer point to pointer
                //pointer variable 在 sram 有一變數位址放pointer point to 的 addr, array 沒有. DCD 內容 (in flash) pointer 放 pointer var addr, array DCD 就是直接放 array content 的 addr
                
                array[2][3]
                char **aaddr
                sizeof(array);      <- 0x18
                sizeof(aaddr);      <- 4
                sizeof(*aaddr);     <- 4
                sizeof(**aaddr);    <- 1
                
                void foo1(int arr[2][3], int m, int n)
                arr will be treated as int(*)[3] <- so the number of [2] is don't care, you can change to [8] or [], but you can't change [3] or that will compiler error
                and if you use arr[8][2], compiler will be ok and modify wrong addr; if you use arr[0][5], compiler will warning you subscript out of range int(*)[3]
                
                int arr[i][j];            //compiler will do (arr + i * size + j)
                int **ptr; ptr[i][j];     //compiler will do *(*(ptr + i) + j))
                
                void test(int** p)
                {
                    *p = (int *)0x20000088; 
                }
                int *haha;      // original &haha (0x20000084), haha (0x0), *haha=3 will result in hardfault
                test(&haha);    // haha become (0x20000088)
                *haha = 3;      // mem 0x20000088 is 3
                
                what if 
                void test(int** p)                      //p is 0x20000084
                {
                    *p = (int *)0x20000040;         //0x20000084 is 0x20000040
                    p = (int **)0x20000088;         //p is changed to 0x20000088
                    *p = (int *)0x20000098;         //0x20000088 is 0x20000098
                }
                
                int* p = malloc(sizeof(*p));  //malloc return void *
                c is ok (c的 void* and int*可以互轉)
                c++ not ok (c++ int*可以assign to void* 反之則要explicit conversion)
                int* p = static_cast<int*>(malloc(sizeof(*p)));
                int* p = new int;

                void foo(void* vptr)
                {
                }
                int main()
                {
                    int* p = ... /* some initialization */;
                    foo(p);
                    return 0;
                }
                Note that foo expects a void pointer, but we pass it int*. This idiom is employed heavily by the C standard library functions. memcpy, qsort and many others

                void test(int (*p)[4])
                {
                    (*p)[2] = 10;
                }
                int main()
                {
                    int arr[] = {30, 450, 14, 5};
                    test(&arr);
                    printf("%d\n", arr[2]);
                    return 0;
                }
                more clear
                void test(int* p)
                {
                    p[2] = 10;
                }
                ...
                ...
                /* then call */
                test(arr);
                The main use of pointers as function arguments is to either avoid passing whole structures by value, or to modify the object pointed by the pointers. Both are irrelevant needs for pointers to array
                int joe[] = {1, 2, 3, 4};
                void test(int (*p)[4])
                {
                    /* Fine: assign to an element through the
                    ** pointer.
                    */
                    (*p)[2] = 10;
                    /* Works, but won't be reflected in the
                    ** caller since p was passed by value.
                    */
                    p = &joe;
                    /* Error: arrays can't be assigned.
                    */
                    *p = joe;
                }            
                
                // Partial initialization list. arr[0] is
                    // initialized to 5, arr[1] to 6, and the
                    // rest to 0
                    //
                    int arr[5] = {5, 6};
                    // Aggregate initializations can be nested !
                    // The following is equivalent to:
                    //
                    // my_bar.a = 5;
                    // my_bar.b = 6;
                    // my_bar.bars_foo.a = 6;
                    // my_bar.bars_foo.b = 7;
                    // my_bar.bar_arr[0] = 5;
                    // my_bar.bar_arr[1] = 6;
                    //
                    Bar my_bar = {5, 6, {6, 7}, {5, 6}};        //實驗可行
                    struct Foo
                    {
                        int a;
                        unsigned b;
                        float c;
                        double d;
                    };
                    
                    // Here is a convenient method to initialize
                    // all members of a structure to 0
                    //
                    Foo my_foo = {0};                           //實驗結果只有第一項會被assign value

                struct Test
                {
                   unsigned a : 5;
                   the ":" is bit field 

                    
                struct point {
                    int x;
                    int y;
                    int z;
                }

                struct point p = {.x = 3, .y = 4, .z = 5};

                struct 寫法
                    1. 
                    struct A{
                        int hello;
                    }a, b;
                    a, b is struct of A
                    struct A c; 
                    a.hello = 3;
                    
                    2.
                    typedef struct A{
                    }AS;
                    AS a;  
                    
                array[0]='a'; //array[0]以外都是垃圾值
                array部份初始版本2(用大括弧)：沒初始的部份會自動補成0
                char array[10] = ""; //也會自動補0，我猜是因為這相當於char array[10] = {'\0'};
                array 和 struct 這類東西在程式語言裡都被歸類為 aggregate (聚合資料)                

                malloc 運作方法  A: 都靠 compiler, size 由 compiler 決定放到r0 再跳到malloc function. 
                      struct pp * spp = (struct pp *) malloc(sizeof(sizeof(struct pp)));
                      spp->a; 
                      spp->b; 這樣的存取存多少 size 如 byte or word, 還是由 compiler 時就定案
                      "struct pp * spp" ptr spp will occupied one pointer address than "struct pp pptest" direct


                function pointer
                    Wallace 大大所講的是據理推斷, 實際上那是語言標準所定義的. 函式的名字(不包括括號) 是個 "function designator", 這是 C99 語言標準的定義:
                    C99 6.3.2.1p4:
                    A function designator is an expression that has function type. Except when it is the
                    operand of the sizeof operator(54) or the unary & operator, a function designator with type "function returning type" is converted to an expression that has type "pointer to function returning type".
                    所以函式名字除了在 sizeof 及 & 運算子的運作下, 它會自動的轉換成函式指標.
                    如果在函式名字前面加 &, 那就是明確的轉換成函式指標.
                    註腳 54 特別說明 size(func) 的情形:
                    Because this conversion does not occur, the operand of the sizeof operator remains a function designator and violates the constraint in 6.5.3.4.
                    如果函式名字作為 sizeof 的運算元, 它不會轉換成函式指標, 也就是說它還是保留著 "function type" 的特性. 在 6.5.3.4, sizeof 運算子的說明裏, 第一段就明確的寫出 sizeof 不能用在 function type:
                    　　"The sizeof operator shall not be applied to an expression that has function type ..."
                    所以在上面的定義下, 如果 foo 是個函式名字, sizeof(foo) 是不合法的; sizeof(&foo) 才合法.
                    
                    int main() { return (********puts)("Hello"); }
                    C99 [6.5.3.2-4] The unary * operator denotes indirection. If the operand points to a function, the result is a function designator                    
                    
                    int f(){};
                    typedef int (*pftype)();
                    typedef int ftype();
                    typedef double pfdtype();
                    int (*test)();

                    test = f;
                    test = (pftype) f;  
                    test = (ftype *) f;  <- 以上三者均同
                    test = (pfdtype *) f; <- 右邊轉型成return double, incompatible type assign


                    array and string 的不同處

                    由於 C 語言提供了一些 syntax sugar 來初始化陣列，這使得 char *p = ”hello world” 和 char p[] = “hello world” 寫法相似，但底層的行為卻大相逕庭
                    以指標的寫法 char *p 來說，意思是 p 將會是指向 static storage 的一個指標。如此的寫法有潛在問題，因為當開發者嘗試修改 string literals 的內容將會造成未定義行為，
                    而編譯器並不會對存取 p 的元素提出警告
                    值得注意的是，陣列的寫法依據 C99 規範，string literals 是必須放在 “static storage” 中，
                    而 char p[] 的語意則表示要把資料分配在 stack 內，
                    所以這會造成編譯器 (gcc) 隱性地 (implicitly) 產生額外的程式碼，使得 C 程式在執行時期可把 string literals 從 static storage 複製到 stack 中。
                    雖然字串本身並非存放於 stack 內，但 char p[] 卻是分配在 stack內，這也造成 return p 是未定義行為

                    NonSecure_funcptr *callback <- pointer to function pointer? <- yes, no matter how much ****
                                              
                      
        c skill
            int fibs[] = {1, 1, 2, 3, 5};
            /* Entries may not correspond to actual numbers. Some entries omitted. */
            #define EINVAL 1
            #define ENOMEM 2
            #define EFAULT 3
            /* ... */
            #define E2BIG  7
            #define EBUSY  8
            /* ... */
            #define ECHILD 12

            char *err_strings[] = {
                [0] = "Success",
                [EINVAL] = "Invalid argument",
                [ENOMEM] = "Not enough memory",
                [EFAULT] = "Bad address",
                /* ... */
                [E2BIG ] = "Argument list too long",
                [EBUSY ] = "Device or resource busy",
                /* ... */
                [ECHILD] = "No child processes"
                /* ... */
            };
            
                
            宏列表
                #define FLAG_LIST(_)                   \
                _(InWorklist)                      \
                _(EmittedAtUses)                   \
                _(LoopInvariant)                   \
                _(Commutative)                     \
                _(Movable)                         \
                _(Lowered)                         \
                _(Guard)
            
                #define DEFINE_FLAG(flag) flag,
                   enum Flag {
                       None = 0,
                       FLAG_LIST(DEFINE_FLAG)
                       Total
                   };
                #undef DEFINE_FLAG

                enum Flag {
                        None = 0,
                        DEFINE_FLAG(InWorklist)
                        DEFINE_FLAG(EmittedAtUses)
                        DEFINE_FLAG(LoopInvariant)
                        DEFINE_FLAG(Commutative)
                        DEFINE_FLAG(Movable)
                        DEFINE_FLAG(Lowered)
                        DEFINE_FLAG(Guard)
                        Total
                    };

                enum Flag {
                        None = 0,
                        InWorklist,
                        EmittedAtUses,
                        LoopInvariant,
                        Commutative,
                        Movable,
                        Lowered,
                        Guard,
                        Total
                    };

                #define FLAG_ACCESSOR(flag) \
                bool is##flag() const {\
                    return hasFlags(1 << flag);\
                }\
                void set##flag() {\
                    JS_ASSERT(!hasFlags(1 << flag));\
                    setFlags(1 << flag);\
                }\
                void setNot##flag() {\
                    JS_ASSERT(hasFlags(1 << flag));\
                    removeFlags(1 << flag);\
                }
                 
                FLAG_LIST(FLAG_ACCESSOR)
                #undef FLAG_ACCESSOR

            编译时断言
                有些时候，特别是在进行内核编程时，在编译时就能够进行条件检查的断言，而不是在运行时进行，这非常有用.
                /* Force a compilation error if condition is false, but also produce a result
                 * (of value 0 and type size_t), so it can be used e.g. in a structure
                 * initializer (or wherever else comma expressions aren't permitted). */
                /* Linux calls these BUILD_BUG_ON_ZERO/_NULL, which is rather misleading. */            
                #define STATIC_ZERO_ASSERT(condition) (sizeof(struct { int:-!(condition); })    )
                #define STATIC_NULL_ASSERT(condition) ((void *)STATIC_ZERO_ASSERT(condition)    )
                /* Force a compilation error if condition is false */
                #define STATIC_ASSERT(condition) ((void)STATIC_ZERO_ASSERT(condition))
                如果(condition)计算结果为一个非零值（即C中的真值），即! (condition)为零值，那么代码将能顺利地编译，并生成一个大小为零的结构体。如果(condition)结果为0（在C真为假），那么在试图生成一个负大小的结构体时，就会产生编译错误

            goto error handling
                int foo(int bar)
                {
                    int return_value = 0;
                    allocate_resources_1();
                    if (!do_something(bar))
                        goto error_1;
                    allocate_resources_2();
                    if (!init_stuff(bar))
                        goto error_2;
                    allocate_resources_3();
                    if (!prepare_stuff(bar))
                        goto error_3;
                    return_value = do_the_thing(bar);
                error_3:
                    cleanup_3();
                error_2:
                    cleanup_2();
                error_1:
                    cleanup_1();
                    return return_value;
                }
                
                uglier
                int foo(int bar)
                {
                    int return_value = 0;
                    allocate_resources_1();
                    if (do_something(bar))
                    {
                        allocate_resources_2();
                        if (init_stuff(bar))
                        {
                            allocate_resources_3();
                            if (prepare_stuff(bar))
                            {
                                return_value = do_the_thing(bar);
                            }
                            cleanup_3();
                        }
                        cleanup_2();
                    }
                    cleanup_1();
                    return return_value;
                }
                
                goto is also sometimes (though much less frequently) useful for breaking out of deeply nested loops.

                typedef volatile unsigned char  vu8;
                typedef volatile unsigned short vu16;
                typedef volatile unsigned long  vu32;
                #define M8(adr)  (*((vu8  *) (adr)))
                #define M16(adr) (*((vu16 *) (adr)))
                #define M32(adr) (*((vu32 *) (adr)))

                #define outpw(port,value)   (*((volatile unsigned int *)(port))=(value))
                #define inpw(port)          ((*((volatile unsigned int *)(port))))
                #define outpb(port,value)   (*((volatile unsigned char *)(port))=(value))
                #define inpb(port)          ((*((volatile unsigned char *)(port))))
                
                ;precedence
                    (status & MASK) != MASK  <- parenthesis is a must, & is lower than !=

                    a=5,b=1,c=2;
                    why A|B&C is A|(B&C)=5 not (A|B)&C=0

                    You can see the similarity of & vs *, and | vs + here:
                    A  B | A&B A*B | A|B A+B 
                    0  0 |  0   0  |  0   0
                    0  1 |  0   0  |  1   1
                    1  0 |  0   0  |  1   1
                    1  1 |  1   1  |  1   2

                    ++p++   <= will be error, ++(n), n must be lvalue, but result of p++ will become rvalue
                    *p++ is the same as *(p++). *p++=4, 4 will save in addr p, not p+4. tmp=*p++ 一樣tmp 也是得到 p, p到下一expression 才完成++
 
            
    ;c++ notes
    
        
        "C:\weekly-report\note\htm\重载(overload)，覆盖(override),隐藏(hide)的区别 - Sukhoi - C++博客.html"
        Overloading ，引數不同，但函式名稱相同為必要條件。
        Overriding，只發生在「繼承」的關係中，子類別會將父類別的函式覆蓋掉，可以看為函式的改寫
            Overload  重载
            在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数不同（包括类型、顺序不同），即函数重载。
            （1）相同的范围（在同一个类中）；
            （2）函数名字相同；
            （3）参数不同；

            请注意，重载解析中不考虑返回类型，而且在不同的作用域里声明的函数也不算是重载。

            Override    覆盖

            是指派生类函数覆盖基类函数，特征是：
            （1）不同的范围（分别位于派生类与基类）；
            （2）函数名字相同；
            （3）参数相同；
            （4）基类函数必须有virtual 关键字。

            Overwrite：重写
            是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
            （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏。
            （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆)

        #include <iostream>
        using namespace std;
        class Foo
        {
        public:
            // Default constructor
            //
            Foo()
            {
                cout << "Default c'tor was called!\n";
            }
            // Copy constructor
            //
            Foo(const Foo&)
            {
                cout << "Copy c'tor was called!\n";
            }
            // Assignment operator
            //
            Foo& operator=(const Foo&)
            {
                cout << "Assignmnent operator was called!\n";
            }
        };
        int main()
        {
            // #1
            // Just a declaration. f1 will be initialized
            // with whatever the default c'tor was
            // designed  to do
            //
            cout << "Trying init method #1: ";
            Foo f1;
            // #2
            // Direct initialization. The copy c'tor
            // will be called to initialize f2 with f1
            //
            cout << "Trying init method #2: ";
            Foo f2(f1);
            // #3
            // Although the '=' sign is used, this is the
            // same as before, f3 is initialized with f1
            // by the copy c'tor (note, the assignment
            // operator isn't invoked)
            //
            cout << "Trying init method #3: ";
            Foo f3 = f1;
            // #4
            // Does it look like a declaration? It sure
            // does... and it is a declaration allright,
            // but not of Foo object! This is tricky...
            // What is declared is a function called f4,
            // which takes no parameters and returns
            // a Foo
            //
            cout << "Trying init method #4: ";
            Foo f4();
            return 0;
        }

        Best way to declare and define global variables
            A header file only contains extern declarations of variables — never static or unqualified variable definitions.
            For any given variable, only one header file declares it (SPOT — Single Point of Truth).
            A source file never contains extern declarations of variables — source files always include the (sole) header that declares them.
            For any given variable, exactly one source file defines the variable, preferably initializing it too. (Although there is no need to initialize explicitly to zero, it does no harm and can do some good, because there can be only one initialized definition of a particular global variable in a program).
            The source file that defines the variable also includes the header to ensure that the definition and the declaration are consistent.

            //如果要讓 header 伴演 declare & definition+initalize 二相, 不要 maintain declare and definition 在分別 .h and .c 可以如下
            #undef EXTERN
            #undef INITIALIZE
            //因為同一個 Translation Unit 可能會同時需要 declare & definition (各需include 一次共二次), 所以不能用 header guard, 不然只能include 一次
            //而且先undef 如上, 再以 DEFINE_VARIABLES 決定用來 declare or definition
            #ifdef DEFINE_VARIABLES
            #define EXTERN                  /* nothing */
            #define INITIALIZER(...)        = __VA_ARGS__
            #else
            #define EXTERN                  extern
            #define INITIALIZER(...)        /* nothing */
            #endif /* DEFINE_VARIABLES */
            EXTERN int global_variable INITIALIZER(37);
            EXTERN struct { int a; int b; } oddball_struct INITIALIZER({ 41, 43 });
            
            //使用方式
            #include "file2c.h"     /* Declare variables */
            #define DEFINE_VARIABLES
            #include "file2c.h"  /* Variables now defined and initialized */
            
        A variable is defined when the compiler allocates the storage for the variable.
        A variable is declared when the compiler is informed that a variable exists (and this is its type); it does not allocate the storage for the variable at that point.
        
        header build dependency
            若改 header , 所有與此 header 有關的 .c file 都要重 build. 
            如果 top.h include bottom.h, 那只要動 bottom.h, 所有 include top.h 的 .c file 都要重 build. 若 include top.h 的 .c 多的話, 需重build的 .c 就會增加很多
            如果改動 top.h , bottom.h 不動的話, 那 include top.h 的 .c 才需重 build, 只 include bottom.h 的 .c 不受影響
            如果單獨改 c file, 就那隻 c file 需重 build 而己

        A null pointer 
            is known not to point to any object; an uninitialized pointer might point anywhere
            That is, the address-of operator & will never yield a null pointer, 
            malloc returns a null pointer when it fails, and this is a typical use of null pointers
            there is a null pointer for each pointer type
            How do I "get" a null pointer in my programs?  Ans: char *p = 0;
            According to the language definition, 
            "a constant 0 in a pointer context is converted into a null pointer at compile time"
            "However, an argument being passed to a function is not necessarily recognizable as a pointer context.  To generate a null pointer in a function call context, an explicit cast is typically required"
            execl("/bin/sh", "sh", "-c", "ls", (char *)0);
            "都 explicit 轉比較安全"
            #define NULL ((void *)0)
            if(expr)  if(expr != 0)  , if expr is NULL both are ok


        #define Streq(s1, s2) (strcmp((s1), (s2)) == 0)

        style
            function/class 的 "{" 是單獨一行的, 其它的 "{" 都是接在 "()" 後面("()" 後面記得要空一格): ex: while () {, if () { ...
            function 的 "()" 是緊連著 function name, 其它標準的 if/else/while .. 等, 與 () 間有一個空白, ex: function() (沒空格), eval() (沒空格), if () (有空格), while () (有空格)...
            ()內的參數, 若有 "," 隔開, 則 "," 後面要空一格, ex: foo($arg1, $arg2='')
            =,>,<,&&,||, == .. 等 判斷條件, 前後要空格, ex: if ($a > $b), $a = $b && $c ...
            注意: ($a > $b) 這些括號與變數間是沒有空隔的.($a 與 "(", 和 $b 與 ")" 間是沒有空格的)

        #define EINVAL 1
        #define ENOMEM 2
        char *err_strings[] = {
                 [0] = "Success",
            [EINVAL] = "Invalid argument",
            [ENOMEM] = "Not enough memory",
        佔SRAM的size, 改 ENOMEM index 就會增加
        佔Flash的size則根據 array item (how many string) 有幾項決定
            
        
        function pointer
            // define a function pointer and initialize to NULL
            int (*pt2Function)(float, char, char) = NULL;                        // C
            int (TMyClass::*pt2Member)(float, char, char) = NULL;                // C++
            int (TMyClass::*pt2ConstMember)(float, char, char) const = NULL;     // C++
            // calling convention
            void __cdecl DoIt(float a, char b, char c);                             // Borland and Microsoft
            void         DoIt(float a, char b, char c)  __attribute__((cdecl));     // GNU GCC
            pt2Function = &DoMore;   // correct assignment using address operator
            if(pt2Function >0){                           // check if initialized
               if(pt2Function == &DoIt)
                  printf("Pointer points to DoIt\n"); }
            pt2Function funcArr1[10] = {NULL};

            void qsort(void* field, size_t nElements, size_t sizeOfAnElement,
                                int(_USERENTRY *cmpFunc)(const void*, const void*));
            int CmpFunc(const void* _a, const void* _b)
            qsort((void*) field, /*number of items*/ 100, /*size of an item*/ sizeof(field[0]),
                        /*comparison-function*/ CmpFunc);
    
        printf %5d
        %8.5f <- width include decimal point is 8, precision after decimal point is 5
        You can also use a * for the precision size:
        printf("%*.*f", width, precision, value);
    
        i++;		i++;
        這樣的寫法是可以的, disassembly 對照 HLL一次二行的量 

        
        ;const修飾類物件/物件指標/物件引用
        const修飾的物件，該物件的任何非const成員函數都不能被調用，因為任何非const成員函數會有修改成員變數的企圖
        class AAA
        {
           void func1();
           void func2() const;
        }
        const AAA aObj;
        aObj.func1(); ×
        aObj.func2(); 正確
         
        const AAA* aObj = new AAA();
        aObj->func1(); ×
        aObj->func2(); 正確

        5. const修飾成員變數
        const修飾類的成員函數，表示成員常量，不能被修改，同時它只能在初始化列表中賦值。
        class A
        {
           …
           const int nValue;       //成員常量不能被修改
           …
           A(int x): nValue(x) {}; //只能在初始化列表中賦值
        }       
    
        function pointer (bookmark - study - proglang - c - pointer)
            compare
                if(pt2Function >0){                           // check if initialized
                    if(pt2Function == &DoIt)
                       printf("Pointer points to DoIt\n"); }
                    else
                       printf("Pointer not initialized!!\n");

            pass argument
                void PassPtr(int (*pt2Func)(float, char, char))
                {
                   int result = (*pt2Func)(12, 'a', 'b');     // call using function pointer                      

            Return a Function Pointer
                1. float (*GetPtr1(const char opCode))(float, float)
                
                2. typedef float(*pt2Func)(float, float);
                    pt2Func GetPtr2(const char opCode)
                    
            Arrays of Function Pointers
                1. // first way using the typedef
                    typedef int (*pt2Function)(float, char, char);
                    pt2Function funcArr1[10] = {NULL};
                2. // 2nd way directly defining the array
                    int (*funcArr2[10])(float, char, char) = {NULL};
                funcArr1[0] = funcArr2[1] = &DoIt;
                printf("%d\n", funcArr1[1](12, 'a', 'b'));         //  short form
                
                
        __stdcall, __cdecl, define calling convention, generate different funcion name "_, @ and so on", stack cleaning mechanism
                    
        this pointer
            const A & A::fun(const A & a1) const
            a.fun(A a1) -> in fun(), variable m is shorthand notation of this->m, tell apart from a1.m
            return *this; for return type "const A&"
            
        vptr - if A inherit B, object a & b both have a pointer vptr, point to A, B classes methods' table (called virtual function table)
                the entries of A table have redefined & newed functions address, B table entries has original ones.
                i think once A or B has instance, it has to have its own VFT, and each object a1, a2 has to point to their class's VFT 
                Q; A inherit B, but A didn't override B func b1(), will b1() appear in B's VFT.  
                A; Yes, entry of function not redefined has the same target address
        
    
           
        ctraps note
            ‘‘If the input stream has been parsed into tokens up to a given character, the next token is taken to include the longest string of characters which could possibly constitute a token.’’
            y = x/*p        <- will wait until */, rewrite to y = x / *p
            except: a + /* strange */ = 1 means the same as a += 1. These operators are the only cases in which things that look like single tokens are really multiple tokens
            p - > a is illegal
            
            The following two program fragments are equivalent:
            printf ("Hello world\n");
            char hello[] = {’H’, ’e’, ’l’, ’l’, ’o’, ’ ’,
            ’w’, ’o’, ’r’, ’l’, ’d’, ’\n’, 0};
            printf (hello);

            writing ’yes’ instead of "yes" may well go undetected. The latter means ‘‘the address of the first of four consecutive memory locations containing y,
            e, s, and a null character, respectively.’’ The former means ‘‘an integer that is composed of the values of
            the characters y, e, and s in some implementation-defined manner.’’

            (*(void(*)())0)();              <- look 0 first, (void(*)()) is to cast, (*fp)() is to call
            
            c precedence
            1. The operators that bind the most tightly are the ones that aren’t really operators: subscripting, function calls, and structure selection. These all associate to the left
            2. Unary operators are right-associative, so *p++ is interpreted as *(p++) 
            3. Next come the true binary operators, . The arithmetic operators have the highest precedence, then the
                shift operators, the relational operators, the logical operators, conditional operator, assignment operators. The two most important things to keep in mind are:
                One small surprise is that the six relational operators do not all have the same precedence: == and != bind less tightly than the other relational operators.
                a < b == c < d 
                z = a < b && b < c ? d : e
            a = b = c        the same as        b = c; a = b;

            put external declarations into include files

            Only the four C operators &&, ||, ?:, and , specify an order of evaluation

            All other C operators evaluate their operands in undefined order
            y[i] = x[i++];
             
            Commas that separate function arguments are not comma operators. For example, x and y are fetched in undefined order
            in f(x,y), but not in g((x,y)). In the latter example, g has one argument. The value of that argument is determined by
            evaluating x, discarding its value, and then evaluating y

            !10 is zero
            ˜ 10 is –11 (11...110101), at least on a 2’s complement machine

            10||12 is also 1, because 10 is nonzero. Moreover, 12 is not even evaluated in the latter expression, nor is f() in 10||f()

            It is valid to write:
            if (p == (char *) 0) ...
            but it is not valid to write:
            if (strcmp (p, (char *) 0) == 0) ...
            because strcmp always looks at the memory addressed by its arguments.        

            if ((int) ((unsigned) a + (unsigned) b) < 0) complain();

            while ((c = getchar()) != EOF)
            
            #define putc(x,p) (--(p)->_cnt>=0?(*(p)->_ptr++=(x)):_flsbuf(x,p))

            portable problem
              7.3. Are Characters Signed or Unsigned?
              (unsigned char) c

              h = n % HASHSIZE;
              if (h < 0)
              h += HASHSIZE;

              free (p);
              p = realloc (p, newsize);

              n = -n;
        

            
        <nulink>
            app_config 和 dialog 都 include lua.h 及 appconfig.h.  
            因為 CCTu 用不到lua.h
            把 lua.h 放到 appconfig.h include
            他用一個 fake appconfig.h header 可以拿去用
        </nulink>

        Questions
            openocd - src/flash/nor/core.c
            js 的程式入口在哪?
            
            heapsort (select) shellsort (insert) quick sort
            dbg monitor of cortex A
            regtarget.c of secure project 
                1. asm("MOVS    r0, #4                        \n". 
                2. __asm int32_t HardFault_Handler(void)
            LISTING 14.10 is worth to study
            c++ dependency tool (except vs2012 ultimate)
            void() const -- try to tamper with it (compiler error?)
            baseptr = (* baseptr) derive class.  => delete derived obj -> can we see derived destructor?
            DLL and library of visual studio
            c++11 rvalue reference
            (network) mac address is burn on nuvoton chip?
            static method is what?
                #ifdef USE_SW_SPIMODE
                static 
                #endif
                void ConnectToDevice();
                
            1. copy constructor and assignment (need deep copy in general case?)
            const 是否不能傳進 non-const as parameter in func?
                         
                         

            vfprintf(stderr, fmt, va); stderr of visual studio means?
            C++’s scope-resolution operator　::warming
                           
        >>  linux 
            find . -name "*.c" | xargs -p rm -f

            rm -f ./G T Wang.c
            因為檔名包含空白，所以這會會造成 rm 指令無法正確刪除該檔案
            find . -name "*.c" -print0 | xargs -0 rm -rf

            find . -name '*.c' | xargs grep 'stdlib.h'

            ls long-long-filename1.txt long-long-filename2.txt
            cat !$

            ls long-long-filename1.txt long-long-filename2.txt long-long-filename3.txt
            cat !:2

            ls long-long-filename1.txt long-long-filename2.txt long-long-filename3.txt
            pwd
            ??cat !ls:2

            ls long-long-filename1.txt long-long-filename2.txt long-long-filename3.txt
            pwd
            cat !ls:*

            ls long-long-filename1.txt long-long-filename2.txt long-long-filename3.txt
            pwd
            cat !ls:^

            ls long-long-filename1.txt long-long-filename2.txt long-long-filename3.txt
            pwd
            cat !ls:$

            :n1,n2s/word1/word2/g	n1 與 n2 為數字。在第 n1 與 n2 列之間尋找 word1 這個字串，並將該字串取代為 word2 ！舉例來說，在 100 到 200 列之間搜尋 vbird 並取代為 VBIRD 則：
            『:100,200s/vbird/VBIRD/g』。(常用)
            :1,$s/word1/word2/g	從第一列到最後一列尋找 word1 字串，並將該字串取代為 word2 ！(常用)
            :1,$s/word1/word2/gc	從第一列到最後一列尋找 word1 字串，並將該字串取代為 word2 ！且在取代前顯示提示字元給使用者確認 (confirm) 是否需要取代！(常用)

        >>  goto of c lang 
                get out of nested loop
                One good place to use a goto is in a procedure that can abort at several points, each of which requires various levels of cleanup    
            
        >>  eclipse 如何 auto 產生 makefile, makefile
            jserv ** 可以改變 struct, google unitest
            
        >>  typedef volatile unsigned long  vu32;
            #define M32(num) (*((vu16 *)(num))) of flash algorithm
            compiler time will take care those M32/M16/M8 things
            M32(0x20002000) = 0x12345678;  - will load 32bits and store to 0x20002000
            M16(0x20002004) = 0x12345678;  - only load 16bits LSB 0x5678 and store to 0x20002004
            
            
        >>  reference    
            int& getInt()
            {
               static int x = 4;
               return x;
            }
            int& x = getInt(); 

            This is also quite common when implementing Singleton pattern
            Class Singleton
            {
                public:
                    static Singleton& instance()
                    {
                        static Singleton instance;
                        return instance;
                    };

                //protect:
                    //Singleton();
             }
             Usage:
             Singleton& my_sing = Singleton::instance(); // Valid Singleton instance
             my_sing.printHello();  // "Hello"

             以上僅能創建一個 object, 但若不加 protect Singleton
             Singleton s1;
             Singleton s2; 可以造出二個不同的 singleton

        >>  static int variable of class , like a glabol varible 
            static int member function , can use to access static varible of class
             
        ;lvalue
            An lvalue (locator value) represents an object that occupies some identifiable location in memory (i.e. has an address).
            rvalues are defined by exclusion, by saying that every expression is either an lvalue or an rvalue. Therefore, from the above definition of lvalue, an rvalue is an expression that does not represent an object occupying some identifiable location in memory.

            1. ++x 是左值而 x++ 卻是右值        //gcc & keil ++x=4, x++=4 都編不過
            2. int *ptr_val 若 *ptr_val 在等號左邊就是 lvalue, 右邊是 rvalue
            3. the unary '*' (dereference) operator takes an rvalue argument but produces an lvalue as a result
               Conversely, the unary address-of operator '&' takes an lvalue argument and produces an rvalue

               
        >>  function variable arguments - ellipsis
            va_list valist 
            va_start(valist, num)
            va_arg(valist, int)
            va_end(valist)
            
        >>  garbage collection howto?
            implement an counter to record the counter of object instance
            
        >>  static function vs inline function
            In a nutshell, if you use static, then taking the address of the function in different translation units will return different addresses 
           (because you're telling the compiler to generate a function in each TU), but if you use inline, they'll show the same address 
           (because you're defining one function, and just telling the compiler to merge the many definitions together)    

        >> strcat ( char *A, char *B) 將B加到A後面，因為不會自己alloc mem, A要有足夠size
            A = malloc (size), A = "Hello"　再 strcat (A, B) 這樣會有問題因為 A 沒有指向 malloc 的位址而是指向”Hello" 那
            用 strcpy (A, "Hello") 才是正解


        >> [A,B) from A up to, but not including, B 

        >>　string::npos <- means maximum allowable number of characters for a string object, it is one greater than the largest possible index and can be used to indicate failure to find a character or a string

        >>  cout << "test" << 88 ;  int to string?
            cout << 0x16; present in decimal?
            cout << -16
            均照 display
            
        >> return const ref: Max()
            return non-const ref: <<, =
            return object: arithmetic

        >> new & delete should be noticed that : copy constructor and assign operator can only assign pointer not deep copy
            so you have to pay attention and override copy constructor & assign operator
            
        >> function returning object will call copy constructor , but return reference won't
           

        >> if your class has a static data member whose value changes when new objects are created, you should 
            provide explicit copy constructor that handles the accounting.

        >>    (reference &) is refer to "int & xx = oo" take oo's address 
                         int rats = 101;
                         int * pt = &rats;
                         int & rodents = *pt;
                         int bunnies = 50;
                         pt = &bunnies;


        >> constructor order from base to derived
           destructor order from derived to base

        >> virtual inherit
            once the parent virtual, all its childs are virtual, even the prototype doesn't have virtual keyword
            if parent isn't virtual, child1 starts to virtual, childs after child1 are virtual

        >> allegiance of reference, must assign at the first stage, and can't modify later

        >> (self) createfilemapping
            CreateFileMapping 可以在不同 process 創建共享 share memory, 二個process要用同一個 m_tShareName
            去看二個 process 各自CreateFileMapping 回傳的 handle 值相同與否不能斷定是不是用到同一個 share memory 
            MapViewOfFile 傳回的值是各個 process 對照到的 logical address, 就算2個 process不同, 可能是 map to 同一塊 share memory
            CreateMutex 若沒有給名字, 可以達到同一個process各 thread 互斥. 若有給名字, 可以達到各 process 互斥.
            
            CICEGlobalMutex 中的 ShareArea 以 CICEGlobalData 為 template type
            CICEGlobalMutex 有	COneInstance2				m_OneMutex;	//Mutex for this one ICE
                                COneInstance				m_AllMutex;	//Mutex for all ICE
            
        >> vc++ 帶不出部份 .h file. 如 oneInstance.h

        >> struct FuncCaller in AGDI.cpp
            - seems to destruct AXF object, but don't know why don't use destructor of AXF
            - per experiment, CAXF_M0 and CAXF destructor will be call by sequence
            
        >> Containment, private inheritance, and protected inheritance are typically used to implement has-a relationships
            containment: class A contain class B, class A can use class B's public method. but program can't use object A to access B.
            A common way of describing this is to say that the A class acquires the implementation of its member objects but doesn’t inherit the interface.
            object A 本身並不具有 object B method
            inherit & containment 差在哪 - 都是acquires the implementation of its member objects but doesn’t inherit the interface 達到 "has-a" relationships, 功效一樣, 差在做法
            那是否private也可以用? - 需要B宣告A為 friend class 
            In general, you should use containment to model a has-a relationship. You should use private inheritance
            if the new class needs to access protected members in the original class or if it needs to redefine virtual functions.

        >> 記得ABC的 destructor 一定要是 virtual? -> virtual ~Device();

        >> not set DHCSR MASK INT means step and may step into ISR?

        >> ICE fw 的 Heap_Size 0x40 是否用來裝 m_pDevice = new(&m_device_buf) DeviceV6M;
            Stack_Size      EQU     0x00000100 - 屬 ZI_data
            DCD     SWDC_IRQHandler            - RO_data size is word
            Heap_Size       EQU     0x00000100 - change this value but nothing happen
            比對看看 ICE2 在 heap_size 有做什麼手腳?
            
        --------------------------------------------------------------------------------------------    
        <c++ note>
               
        C language 中的 static __inline
            static function: 只有同file內可以呼叫, 若加在 header file, compiler 必用此 inline function optimize
            inline 若沒有加static , 若在本檔以及別的檔都有定義 external inline function, 那有可能會參照二者之一
            refer to "C primer.pdf"

        const
            C language "const" default 是 external linkage, 所以在 A.h 加一個 const int A; 且A.h 被A.c and B.c include, 是無法編得過的
            上述若改成 static const int A; 則編得過
            C++ 把const 的linkage default 改成 static linkage, 所以在 A.h 寫 const int A=0; 可 build 得過, 這樣user 不用記要加static.
            記得, const define 要 initialize. 
            在c++也可以用extern override 掉 const 的internal linkage, 很特別的在extern 去init value. 如下寫法 extern const int states = 50; 但好像沒什麼好處
            KEIL 要用 C++, armcc 會根據是不是有 compile option --cpp 或是副檔名全都是 cpp , 就會直接用 c++ compile
            但中斷 function handler 要加 extern "C" {, 才 call 的到
          
            // in namespace or global scope
            int i; // extern by default
            const int ci; // c extern by default, c++ change to static by default for in header file
            extern const int eci; // explicitly extern
            static int si; // explicitly static

            // the same goes for functions (but there are no const functions)
            int foo(); // extern by default
            static int bar(); // explicitly static     

        macro:
        #define __glC(x) (*__gl_sym[__gl##x].f)


        typedef 解讀法 
        把定義中的 typedef 拿掉, 同時資料型態名稱換成變數的名稱, 就會比較容易理解. 例如: 把 typedef uint8_t Buffer[16]; 去掉 typedef, Buffer 換成變數名 xBuf, 變成 uint8_t xBuf[16];
            example:
            typedef uint8_t   Buffer[16];
            Buffer xBuf; 
            xBuf[0] = 3;
            xBuf[1] = 2;

        const int ** A;  解讀法
            right to left, pointer to pointer to const int
        int * const * A
            pointer to const pointer to int 
            
        inline function and macro 的差異, function 是傳值 macro 是替代 #define SQUARE(X) (X*X)
        a = SQUARE(5.0); is replaced by a = 5.0*5.0;
        b = SQUARE(4.5 + 7.5); is replaced by b = 4.5 + 7.5 * 4.5 + 7.5;
        d = SQUARE(c++); is replaced by d = c++*c++;
        Only the first example here works properly. You can improve as
        #define SQUARE(X) ((X)*(X))
        but SQUARE(c++) increments c twice
             
        function pointer:
            void custom_for_each( int *pArray, unsigned int size, int (*op)( int ) )
            custom_for_each( pArray, size, &power2 );
        使用 typedef 加強可讀性
            typedef int (*CustomOperator)( int );
            void custom_for_each( int *pArray, unsigned int size, CustomOperator op )
        Function Pointer 的陣列
            int (*op[10])( int );
            typedef int (*CustomOperator)( int );
            CustomOperator op[10];

        typedef CFlash_Mini51<CICE_Mini51<CICE_M0_Cache> > FLASH_T;    
            

        儲存類別    關鍵字     宣告位置         持久性(Duration)  有效範圍(scope)
        暫存器變數  register   函式內或區塊內   暫時              區域 Local
        自動變數    auto       函式內或區塊內   暫時              區域 Local
        靜態變數    static     函式內或區塊內   persistence       區域 Local
        外部靜態    static     函式外面         persistence       Global(一個檔案) 
        外部變數    extern     函式外面         persistence       Global(所有檔案)

        *  as "pointer to"   - always on the left side
        [5]  as "array[5] of"   - always on the right side
        ()  as "function returning"  - always on the right side    

        typedef 
            // Wrong definition:
            typedef char * pstr;
            mystrcmp(const pstr, const pstr);
     
            // Correct definition:
            typedef const char * cpstr;
            mystrcmp(cpstr, cpstr);
            
            qualifier
            auto, static, extern, register can't in typedef
            const, volatile can in typedef
            
            // 原始寫法:
            int *(*a[5])(int, char*);
            // 轉換1:
            typedef int *(*pFun)(int, char*);
            pFun a[5];
            // 轉換2:
            typedef int *Func(int, char*);
            Func *a[5];
            
            // 原始寫法:
            void (*b[10])(void (*)());
            // 轉換為:
            typedef void (*pFunParam)();       // 右半部, 函數的參數
            typedef void (*pFunx)(pFunParam);  // 左半部的函數
            pFunx b[10];

            void (*signal(int sig, void (*func)(int)))(int);
            // 轉換成下面的樣子
            typedef void (*sighandler_t)(int);
            sighandler_t signal(int sig, sighandler_t func);

            習慣上, C 語言 (如: standard C library, POSIX) 會在衍生性型別名的後面加上 _t, 像是 size_t.
            定義或宣告變數時, 新設的型別不可以和 signed, unsigned 一起合用 (即便是 原始型別是 int, short, long... 之類的型別). 理由很簡單 signed int 和 unsigned int 是分別的基本資料型態, 意即 signed 和 unsigned 這二個 keyword 並不是 int 的 storage class 或者是 qualifier 之類的修飾 keyword.
            

        signal function of unix
            void ( *signal(int sig, void (*handler)(int)) ) (int);
            breaks down as

                    signal                                          -- signal
                    signal(                               )         -- is a function
                    signal(    sig                        )         -- with a parameter named sig
                    signal(int sig,                       )         --   of type int
                    signal(int sig,        handler        )         -- and a parameter named handler
                    signal(int sig,       *handler        )         --   which is a pointer
                    signal(int sig,      (*handler)(   )) )         --   to a function
                    signal(int sig,      (*handler)(int)) )         --   taking an int parameter
                    signal(int sig, void (*handler)(int)) )         --   and returning void
                   *signal(int sig, void (*handler)(int)) )         -- returning a pointer
                 ( *signal(int sig, void (*handler)(int)) )(   )    -- to a function
                 ( *signal(int sig, void (*handler)(int)) )(int)    --   taking an int parameter
            void ( *signal(int sig, void (*handler)(int)) )(int);   --   and returning void
            The signal function associates a signal (sig) with a callback function (handler), like so:

            #include <signal.h>

            static int interrupt = 0;

            /**
             * The following function will be called when a SIGINT is
             * detected (such as when someone types Ctrl-C)
             */
            void interrupt_handler( int sig )
            {
              interrupt = 1;
            }

            int main( void )
            {
              /**
               * Declare a pointer to the old interrupt handler function
               */
              void (*old_interrupt_handler )(int);

              /**
               * Save the old interrupt handler while setting the new one
               */
              old_interrupt_handler = signal( SIGINT, interrupt_handler );
              while ( !interrupt )
              {
                // do stuff until someone hits Ctrl-C
              };

              /**
               * restore the original interrupt handler
               */
              signal( SIGINT, old_interrupt_handler );
              return 0;
            }
        
        __declspec, which specifies that an instance of a given type is to be stored with a Microsoft-specific storage-class attribute
        dllexport to export function for other application. dllimport is not necessary, if having it, compiler may improve performance
        DLL Implicitly/Explicit  Link


        The "right-left" rule is a completely regular rule for deciphering C declarations. It can also be useful in creating them.
            First, symbols. Read
                * as "pointer to" - always on the left side
                [] as "array of" - always on the right side
                () as "function returning" - always on the right side

            STEP 1
                Find the identifier. This is your starting point. Then say to yourself, "identifier is". You've started your declaration.
            STEP 2
                Look at the symbols on the right of the identifier. If, say, you find "()" there, then you know that this is the declaration for a function. So you would then have "identifier is function returning". Or if you found a "[]" there, you would say "identifier is array of". Continue right until you run out of symbols *OR* hit a *right* parenthesis ")". (If you hit a left parenthesis, that's the beginning of a () symbol, even if there is stuff in between the parentheses. More on that below.)
            STEP 3
                Look at the symbols to the left of the identifier. If it is not one of our symbols above (say, something like "int"), just say it. Otherwise, translate it into English using that table above. Keep going left until you run out of symbols *OR* hit a *left* parenthesis "("

        Illegal combinations include:
                []() - cannot have an array of functions
                ()() - cannot have a function that returns a function
                ()[] - cannot have a function that returns an array


                
        about the opcode, should check v7m document
            BL.W means what?
            .W means 32bits
        
        

    ;prog ;misc
        ;NULL
            NULL 颠覆类型
                在 Java 中，如果我编写 x.toUppercase()，编译器会检查 x 的类型。如果 x 是一个 String，那么类型检查成功；如果 x 是一个 Socket，那么类型检查失败
                toUppercase() 可以被任意 String 对象调用。除非 String 是 null。
                read() 可以被任意 InputStream 对象调用。除非 InputStream 是 null。
                toString() 可以被任意 Object 对象调用。除非 Object 是 null。

            NULL 是一个特例
                char *myChar = 123; // compile error
                char *myChar = 0; //compile ok
            


;bad   
    stu, um typo and layout chaotic. said rapid response, but UM write one week and like sh.
         refuse to do gif firmware, 不去焊 USB connector, 找 SD card
    
;backup
    (cctu) how to exchange data between c++ and js, nusenadj
    (ycc) nulink gang main chip, mbed (LDROM 8K NuMicro_MSC.bin source code), cert offline, nuc505
            diy icp writer
           [2017wk21]     nugang (previous ctmr) nuc121. to henry under testing.
    (cyyu) ecs code, thermal printer, pinconfig code backup, clock config, openocd, eclipse plugin

;出勤
    2018
    4/M health check
    4/19 ychsu 9:20, 18:50 leave
    
    
    


    

